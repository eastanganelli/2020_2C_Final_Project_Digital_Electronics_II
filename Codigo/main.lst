CCS PCM C Compiler, Version 5.076, 56587               29-oct.-20 12:07

               Filename:   C:\Users\Francisco\Documents\!Facultad - UF\Electrónica Digital II\Proyecto Final\tp_final_edi2\Codigo\main.lst

               ROM used:   3346 words (41%)
                           Largest free fragment is 2048
               RAM used:   74 (20%) at main() level
                           127 (35%) worst case
               Stack used: 8 locations (4 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   3D4
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.3
0018:  GOTO   01B
0019:  BTFSC  0B.0
001A:  GOTO   02C
001B:  MOVF   22,W
001C:  MOVWF  04
001D:  MOVF   23,W
001E:  MOVWF  77
001F:  MOVF   24,W
0020:  MOVWF  78
0021:  MOVF   25,W
0022:  MOVWF  79
0023:  MOVF   26,W
0024:  MOVWF  7A
0025:  MOVF   20,W
0026:  MOVWF  0A
0027:  SWAPF  21,W
0028:  MOVWF  03
0029:  SWAPF  7F,F
002A:  SWAPF  7F,W
002B:  RETFIE
002C:  BCF    0A.3
002D:  BCF    0A.4
002E:  GOTO   311
.................... #include <main.h> 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
002F:  BCF    0A.0
0030:  BCF    0A.1
0031:  BCF    0A.2
0032:  ADDLW  36
0033:  BTFSC  03.0
0034:  INCF   0A,F
0035:  MOVWF  02
0036:  RETLW  00
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  00
003A:  RETLW  00
003B:  RETLW  00
003C:  RETLW  00
003D:  RETLW  5F
003E:  RETLW  00
003F:  RETLW  00
0040:  RETLW  00
0041:  RETLW  03
0042:  RETLW  00
0043:  RETLW  03
0044:  RETLW  00
0045:  RETLW  14
0046:  RETLW  3E
0047:  RETLW  14
0048:  RETLW  3E
0049:  RETLW  14
004A:  RETLW  24
004B:  RETLW  2A
004C:  RETLW  7F
004D:  RETLW  2A
004E:  RETLW  12
004F:  RETLW  43
0050:  RETLW  33
0051:  RETLW  08
0052:  RETLW  66
0053:  RETLW  61
0054:  RETLW  36
0055:  RETLW  49
0056:  RETLW  55
0057:  RETLW  22
0058:  RETLW  50
0059:  RETLW  00
005A:  RETLW  05
005B:  RETLW  03
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  00
005F:  RETLW  1C
0060:  RETLW  22
0061:  RETLW  41
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  41
0065:  RETLW  22
0066:  RETLW  1C
0067:  RETLW  00
0068:  RETLW  14
0069:  RETLW  08
006A:  RETLW  3E
006B:  RETLW  08
006C:  RETLW  14
006D:  RETLW  08
006E:  RETLW  08
006F:  RETLW  3E
0070:  RETLW  08
0071:  RETLW  08
0072:  RETLW  00
0073:  RETLW  50
0074:  RETLW  30
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  08
0078:  RETLW  08
0079:  RETLW  08
007A:  RETLW  08
007B:  RETLW  08
007C:  RETLW  00
007D:  RETLW  60
007E:  RETLW  60
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  20
0082:  RETLW  10
0083:  RETLW  08
0084:  RETLW  04
0085:  RETLW  02
0086:  RETLW  3E
0087:  RETLW  51
0088:  RETLW  49
0089:  RETLW  45
008A:  RETLW  3E
008B:  RETLW  00
008C:  RETLW  04
008D:  RETLW  02
008E:  RETLW  7F
008F:  RETLW  00
0090:  RETLW  42
0091:  RETLW  61
0092:  RETLW  51
0093:  RETLW  49
0094:  RETLW  46
0095:  RETLW  22
0096:  RETLW  41
0097:  RETLW  49
0098:  RETLW  49
0099:  RETLW  36
009A:  RETLW  18
009B:  RETLW  14
009C:  RETLW  12
009D:  RETLW  7F
009E:  RETLW  10
009F:  RETLW  27
00A0:  RETLW  45
00A1:  RETLW  45
00A2:  RETLW  45
00A3:  RETLW  39
00A4:  RETLW  3E
00A5:  RETLW  49
00A6:  RETLW  49
00A7:  RETLW  49
00A8:  RETLW  32
00A9:  RETLW  01
00AA:  RETLW  01
00AB:  RETLW  71
00AC:  RETLW  09
00AD:  RETLW  07
00AE:  RETLW  36
00AF:  RETLW  49
00B0:  RETLW  49
00B1:  RETLW  49
00B2:  RETLW  36
00B3:  RETLW  26
00B4:  RETLW  49
00B5:  RETLW  49
00B6:  RETLW  49
00B7:  RETLW  3E
00B8:  RETLW  00
00B9:  RETLW  36
00BA:  RETLW  36
00BB:  RETLW  00
00BC:  RETLW  00
00BD:  RETLW  00
00BE:  RETLW  56
00BF:  RETLW  36
00C0:  RETLW  00
00C1:  RETLW  00
00C2:  RETLW  08
00C3:  RETLW  14
00C4:  RETLW  22
00C5:  RETLW  41
00C6:  RETLW  00
00C7:  RETLW  14
00C8:  RETLW  14
00C9:  RETLW  14
00CA:  RETLW  14
00CB:  RETLW  14
00CC:  RETLW  00
00CD:  RETLW  41
00CE:  RETLW  22
00CF:  RETLW  14
00D0:  RETLW  08
00D1:  RETLW  02
00D2:  RETLW  01
00D3:  RETLW  51
00D4:  RETLW  09
00D5:  RETLW  06
00D6:  RETLW  3E
00D7:  RETLW  41
00D8:  RETLW  59
00D9:  RETLW  55
00DA:  RETLW  5E
00DB:  RETLW  7E
00DC:  RETLW  09
00DD:  RETLW  09
00DE:  RETLW  09
00DF:  RETLW  7E
00E0:  RETLW  7F
00E1:  RETLW  49
00E2:  RETLW  49
00E3:  RETLW  49
00E4:  RETLW  36
00E5:  RETLW  3E
00E6:  RETLW  41
00E7:  RETLW  41
00E8:  RETLW  41
00E9:  RETLW  22
00EA:  RETLW  7F
00EB:  RETLW  41
00EC:  RETLW  41
00ED:  RETLW  41
00EE:  RETLW  3E
00EF:  RETLW  7F
00F0:  RETLW  49
00F1:  RETLW  49
00F2:  RETLW  49
00F3:  RETLW  41
00F4:  RETLW  7F
00F5:  RETLW  09
00F6:  RETLW  09
00F7:  RETLW  09
00F8:  RETLW  01
00F9:  RETLW  3E
00FA:  RETLW  41
00FB:  RETLW  41
00FC:  RETLW  49
00FD:  RETLW  3A
00FE:  RETLW  7F
00FF:  RETLW  08
0100:  RETLW  08
0101:  RETLW  08
0102:  RETLW  7F
0103:  RETLW  00
0104:  RETLW  41
0105:  RETLW  7F
0106:  RETLW  41
0107:  RETLW  00
0108:  RETLW  30
0109:  RETLW  40
010A:  RETLW  40
010B:  RETLW  40
010C:  RETLW  3F
010D:  RETLW  7F
010E:  RETLW  08
010F:  RETLW  14
0110:  RETLW  22
0111:  RETLW  41
0112:  RETLW  7F
0113:  RETLW  40
0114:  RETLW  40
0115:  RETLW  40
0116:  RETLW  40
0117:  RETLW  7F
0118:  RETLW  02
0119:  RETLW  0C
011A:  RETLW  02
011B:  RETLW  7F
011C:  RETLW  7F
011D:  RETLW  02
011E:  RETLW  04
011F:  RETLW  08
0120:  RETLW  7F
0121:  RETLW  3E
0122:  RETLW  41
0123:  RETLW  41
0124:  RETLW  41
0125:  RETLW  3E
0126:  RETLW  7F
0127:  RETLW  09
0128:  RETLW  09
0129:  RETLW  09
012A:  RETLW  06
012B:  RETLW  1E
012C:  RETLW  21
012D:  RETLW  21
012E:  RETLW  21
012F:  RETLW  5E
0130:  RETLW  7F
0131:  RETLW  09
0132:  RETLW  09
0133:  RETLW  09
0134:  RETLW  76
0135:  BSF    0A.0
0136:  BCF    0A.1
0137:  BCF    0A.2
0138:  ADDLW  3C
0139:  BTFSC  03.0
013A:  INCF   0A,F
013B:  MOVWF  02
013C:  RETLW  26
013D:  RETLW  49
013E:  RETLW  49
013F:  RETLW  49
0140:  RETLW  32
0141:  RETLW  01
0142:  RETLW  01
0143:  RETLW  7F
0144:  RETLW  01
0145:  RETLW  01
0146:  RETLW  3F
0147:  RETLW  40
0148:  RETLW  40
0149:  RETLW  40
014A:  RETLW  3F
014B:  RETLW  1F
014C:  RETLW  20
014D:  RETLW  40
014E:  RETLW  20
014F:  RETLW  1F
0150:  RETLW  7F
0151:  RETLW  20
0152:  RETLW  10
0153:  RETLW  20
0154:  RETLW  7F
0155:  RETLW  41
0156:  RETLW  22
0157:  RETLW  1C
0158:  RETLW  22
0159:  RETLW  41
015A:  RETLW  07
015B:  RETLW  08
015C:  RETLW  70
015D:  RETLW  08
015E:  RETLW  07
015F:  RETLW  61
0160:  RETLW  51
0161:  RETLW  49
0162:  RETLW  45
0163:  RETLW  43
0164:  RETLW  00
0165:  RETLW  7F
0166:  RETLW  41
0167:  RETLW  00
0168:  RETLW  00
0169:  RETLW  02
016A:  RETLW  04
016B:  RETLW  08
016C:  RETLW  10
016D:  RETLW  20
016E:  RETLW  00
016F:  RETLW  00
0170:  RETLW  41
0171:  RETLW  7F
0172:  RETLW  00
0173:  RETLW  04
0174:  RETLW  02
0175:  RETLW  01
0176:  RETLW  02
0177:  RETLW  04
0178:  RETLW  40
0179:  RETLW  40
017A:  RETLW  40
017B:  RETLW  40
017C:  RETLW  40
017D:  RETLW  00
017E:  RETLW  01
017F:  RETLW  02
0180:  RETLW  04
0181:  RETLW  00
0182:  RETLW  20
0183:  RETLW  54
0184:  RETLW  54
0185:  RETLW  54
0186:  RETLW  78
0187:  RETLW  7F
0188:  RETLW  44
0189:  RETLW  44
018A:  RETLW  44
018B:  RETLW  38
018C:  RETLW  38
018D:  RETLW  44
018E:  RETLW  44
018F:  RETLW  44
0190:  RETLW  44
0191:  RETLW  38
0192:  RETLW  44
0193:  RETLW  44
0194:  RETLW  44
0195:  RETLW  7F
0196:  RETLW  38
0197:  RETLW  54
0198:  RETLW  54
0199:  RETLW  54
019A:  RETLW  18
019B:  RETLW  04
019C:  RETLW  04
019D:  RETLW  7E
019E:  RETLW  05
019F:  RETLW  05
01A0:  RETLW  08
01A1:  RETLW  54
01A2:  RETLW  54
01A3:  RETLW  54
01A4:  RETLW  3C
01A5:  RETLW  7F
01A6:  RETLW  08
01A7:  RETLW  04
01A8:  RETLW  04
01A9:  RETLW  78
01AA:  RETLW  00
01AB:  RETLW  44
01AC:  RETLW  7D
01AD:  RETLW  40
01AE:  RETLW  00
01AF:  RETLW  20
01B0:  RETLW  40
01B1:  RETLW  44
01B2:  RETLW  3D
01B3:  RETLW  00
01B4:  RETLW  7F
01B5:  RETLW  10
01B6:  RETLW  28
01B7:  RETLW  44
01B8:  RETLW  00
01B9:  RETLW  00
01BA:  RETLW  41
01BB:  RETLW  7F
01BC:  RETLW  40
01BD:  RETLW  00
01BE:  RETLW  7C
01BF:  RETLW  04
01C0:  RETLW  78
01C1:  RETLW  04
01C2:  RETLW  78
01C3:  RETLW  7C
01C4:  RETLW  08
01C5:  RETLW  04
01C6:  RETLW  04
01C7:  RETLW  78
01C8:  RETLW  38
01C9:  RETLW  44
01CA:  RETLW  44
01CB:  RETLW  44
01CC:  RETLW  38
01CD:  RETLW  7C
01CE:  RETLW  14
01CF:  RETLW  14
01D0:  RETLW  14
01D1:  RETLW  08
01D2:  RETLW  08
01D3:  RETLW  14
01D4:  RETLW  14
01D5:  RETLW  14
01D6:  RETLW  7C
01D7:  RETLW  00
01D8:  RETLW  7C
01D9:  RETLW  08
01DA:  RETLW  04
01DB:  RETLW  04
01DC:  RETLW  48
01DD:  RETLW  54
01DE:  RETLW  54
01DF:  RETLW  54
01E0:  RETLW  20
01E1:  RETLW  04
01E2:  RETLW  04
01E3:  RETLW  3F
01E4:  RETLW  44
01E5:  RETLW  44
01E6:  RETLW  3C
01E7:  RETLW  40
01E8:  RETLW  40
01E9:  RETLW  20
01EA:  RETLW  7C
01EB:  RETLW  1C
01EC:  RETLW  20
01ED:  RETLW  40
01EE:  RETLW  20
01EF:  RETLW  1C
01F0:  RETLW  3C
01F1:  RETLW  40
01F2:  RETLW  30
01F3:  RETLW  40
01F4:  RETLW  3C
01F5:  RETLW  44
01F6:  RETLW  28
01F7:  RETLW  10
01F8:  RETLW  28
01F9:  RETLW  44
01FA:  RETLW  0C
01FB:  RETLW  50
01FC:  RETLW  50
01FD:  RETLW  50
01FE:  RETLW  3C
01FF:  RETLW  44
0200:  RETLW  64
0201:  RETLW  54
0202:  RETLW  4C
0203:  RETLW  44
0204:  RETLW  00
0205:  RETLW  08
0206:  RETLW  36
0207:  RETLW  41
0208:  RETLW  41
0209:  RETLW  00
020A:  RETLW  00
020B:  RETLW  7F
020C:  RETLW  00
020D:  RETLW  00
020E:  RETLW  41
020F:  RETLW  41
0210:  RETLW  36
0211:  RETLW  08
0212:  RETLW  00
0213:  RETLW  02
0214:  RETLW  01
0215:  RETLW  02
0216:  RETLW  04
0217:  RETLW  02
*
0325:  CLRF   77
0326:  CLRF   78
0327:  BSF    03.5
0328:  MOVF   22,W
0329:  BCF    03.0
032A:  BTFSC  23.0
032B:  ADDWF  77,F
032C:  RRF    77,F
032D:  RRF    78,F
032E:  BTFSC  23.1
032F:  ADDWF  77,F
0330:  RRF    77,F
0331:  RRF    78,F
0332:  BTFSC  23.2
0333:  ADDWF  77,F
0334:  RRF    77,F
0335:  RRF    78,F
0336:  BTFSC  23.3
0337:  ADDWF  77,F
0338:  RRF    77,F
0339:  RRF    78,F
033A:  BTFSC  23.4
033B:  ADDWF  77,F
033C:  RRF    77,F
033D:  RRF    78,F
033E:  BTFSC  23.5
033F:  ADDWF  77,F
0340:  RRF    77,F
0341:  RRF    78,F
0342:  BTFSC  23.6
0343:  ADDWF  77,F
0344:  RRF    77,F
0345:  RRF    78,F
0346:  BTFSC  23.7
0347:  ADDWF  77,F
0348:  RRF    77,F
0349:  RRF    78,F
034A:  BCF    03.5
034B:  RETURN
*
064B:  MOVF   72,W
064C:  BTFSC  03.2
064D:  GOTO   6CA
064E:  BSF    03.5
064F:  MOVWF  20
0650:  MOVF   7B,W
0651:  BTFSS  03.2
0652:  GOTO   655
0653:  BCF    03.5
0654:  GOTO   6CA
0655:  ADDWF  20,F
0656:  BTFSC  03.0
0657:  GOTO   663
0658:  MOVLW  7F
0659:  SUBWF  20,F
065A:  BTFSC  03.0
065B:  GOTO   65E
065C:  BCF    03.5
065D:  GOTO   6CA
065E:  BTFSS  03.2
065F:  GOTO   662
0660:  BCF    03.5
0661:  GOTO   6CA
0662:  GOTO   669
0663:  MOVLW  81
0664:  ADDWF  20,F
0665:  BTFSS  03.0
0666:  GOTO   669
0667:  BCF    03.5
0668:  GOTO   6CA
0669:  MOVF   20,W
066A:  MOVWF  77
066B:  CLRF   78
066C:  CLRF   79
066D:  CLRF   7A
066E:  MOVF   73,W
066F:  MOVWF  24
0670:  BSF    24.7
0671:  MOVF   74,W
0672:  MOVWF  23
0673:  MOVF   75,W
0674:  MOVWF  22
0675:  MOVLW  18
0676:  MOVWF  20
0677:  CLRF   21
0678:  BTFSS  22.0
0679:  GOTO   692
067A:  MOVF   7E,W
067B:  ADDWF  7A,F
067C:  BTFSS  03.0
067D:  GOTO   684
067E:  INCF   79,F
067F:  BTFSS  03.2
0680:  GOTO   684
0681:  INCF   78,F
0682:  BTFSC  03.2
0683:  BSF    21.7
0684:  MOVF   7D,W
0685:  ADDWF  79,F
0686:  BTFSS  03.0
0687:  GOTO   68B
0688:  INCF   78,F
0689:  BTFSC  03.2
068A:  BSF    21.7
068B:  MOVF   7C,W
068C:  MOVWF  74
068D:  BSF    74.7
068E:  MOVF   74,W
068F:  ADDWF  78,F
0690:  BTFSC  03.0
0691:  BSF    21.7
0692:  RLF    21,F
0693:  RRF    78,F
0694:  RRF    79,F
0695:  RRF    7A,F
0696:  RRF    24,F
0697:  RRF    23,F
0698:  RRF    22,F
0699:  BCF    03.0
069A:  DECFSZ 20,F
069B:  GOTO   677
069C:  MOVLW  01
069D:  ADDWF  77,F
069E:  BTFSS  03.0
069F:  GOTO   6A2
06A0:  BCF    03.5
06A1:  GOTO   6CA
06A2:  BTFSC  78.7
06A3:  GOTO   6AC
06A4:  RLF    24,F
06A5:  RLF    7A,F
06A6:  RLF    79,F
06A7:  RLF    78,F
06A8:  DECFSZ 77,F
06A9:  GOTO   6AC
06AA:  BCF    03.5
06AB:  GOTO   6CA
06AC:  BTFSS  24.7
06AD:  GOTO   6BF
06AE:  INCF   7A,F
06AF:  BTFSS  03.2
06B0:  GOTO   6BF
06B1:  INCF   79,F
06B2:  BTFSS  03.2
06B3:  GOTO   6BF
06B4:  INCF   78,F
06B5:  BTFSS  03.2
06B6:  GOTO   6BF
06B7:  RRF    78,F
06B8:  RRF    79,F
06B9:  RRF    7A,F
06BA:  INCF   77,F
06BB:  BTFSS  03.2
06BC:  GOTO   6BF
06BD:  BCF    03.5
06BE:  GOTO   6CA
06BF:  MOVF   73,W
06C0:  MOVWF  21
06C1:  MOVF   7C,W
06C2:  XORWF  21,F
06C3:  BTFSS  21.7
06C4:  GOTO   6C7
06C5:  BSF    78.7
06C6:  GOTO   6CF
06C7:  BCF    78.7
06C8:  GOTO   6CF
06C9:  BCF    03.5
06CA:  CLRF   77
06CB:  CLRF   78
06CC:  CLRF   79
06CD:  CLRF   7A
06CE:  BSF    03.5
06CF:  BCF    03.5
06D0:  RETURN
06D1:  MOVF   72,W
06D2:  SUBLW  B6
06D3:  MOVWF  72
06D4:  CLRF   7A
06D5:  MOVF   73,W
06D6:  MOVWF  76
06D7:  BSF    73.7
06D8:  BCF    03.0
06D9:  RRF    73,F
06DA:  RRF    74,F
06DB:  RRF    75,F
06DC:  RRF    7A,F
06DD:  RRF    79,F
06DE:  RRF    78,F
06DF:  RRF    77,F
06E0:  DECFSZ 72,F
06E1:  GOTO   6D8
06E2:  BTFSS  76.7
06E3:  GOTO   6EF
06E4:  COMF   77,F
06E5:  COMF   78,F
06E6:  COMF   79,F
06E7:  COMF   7A,F
06E8:  INCF   77,F
06E9:  BTFSC  03.2
06EA:  INCF   78,F
06EB:  BTFSC  03.2
06EC:  INCF   79,F
06ED:  BTFSC  03.2
06EE:  INCF   7A,F
06EF:  RETURN
06F0:  BTFSC  03.1
06F1:  GOTO   6F5
06F2:  MOVLW  A0
06F3:  MOVWF  04
06F4:  BCF    03.7
06F5:  CLRF   77
06F6:  CLRF   78
06F7:  CLRF   79
06F8:  CLRF   7A
06F9:  BSF    03.5
06FA:  CLRF   20
06FB:  CLRF   21
06FC:  CLRF   22
06FD:  CLRF   23
06FE:  MOVF   7E,W
06FF:  IORWF  7D,W
0700:  IORWF  7C,W
0701:  IORWF  7B,W
0702:  BTFSC  03.2
0703:  GOTO   734
0704:  MOVLW  20
0705:  MOVWF  24
0706:  BCF    03.0
0707:  RLF    72,F
0708:  RLF    73,F
0709:  RLF    74,F
070A:  RLF    75,F
070B:  RLF    20,F
070C:  RLF    21,F
070D:  RLF    22,F
070E:  RLF    23,F
070F:  MOVF   7E,W
0710:  SUBWF  23,W
0711:  BTFSS  03.2
0712:  GOTO   71D
0713:  MOVF   7D,W
0714:  SUBWF  22,W
0715:  BTFSS  03.2
0716:  GOTO   71D
0717:  MOVF   7C,W
0718:  SUBWF  21,W
0719:  BTFSS  03.2
071A:  GOTO   71D
071B:  MOVF   7B,W
071C:  SUBWF  20,W
071D:  BTFSS  03.0
071E:  GOTO   72E
071F:  MOVF   7B,W
0720:  SUBWF  20,F
0721:  MOVF   7C,W
0722:  BTFSS  03.0
0723:  INCFSZ 7C,W
0724:  SUBWF  21,F
0725:  MOVF   7D,W
0726:  BTFSS  03.0
0727:  INCFSZ 7D,W
0728:  SUBWF  22,F
0729:  MOVF   7E,W
072A:  BTFSS  03.0
072B:  INCFSZ 7E,W
072C:  SUBWF  23,F
072D:  BSF    03.0
072E:  RLF    77,F
072F:  RLF    78,F
0730:  RLF    79,F
0731:  RLF    7A,F
0732:  DECFSZ 24,F
0733:  GOTO   706
0734:  MOVF   20,W
0735:  MOVWF  00
0736:  INCF   04,F
0737:  MOVF   21,W
0738:  MOVWF  00
0739:  INCF   04,F
073A:  MOVF   22,W
073B:  MOVWF  00
073C:  INCF   04,F
073D:  MOVF   23,W
073E:  MOVWF  00
073F:  BCF    03.5
0740:  RETURN
0741:  MOVF   2F,W
0742:  MOVWF  04
0743:  BCF    03.7
0744:  BTFSC  30.0
0745:  BSF    03.7
0746:  MOVF   72,W
0747:  MOVWF  00
0748:  INCF   04,F
0749:  CLRF   00
074A:  INCF   2F,F
074B:  BTFSC  03.2
074C:  INCF   30,F
074D:  RETURN
*
076C:  MOVLW  8E
076D:  MOVWF  77
076E:  MOVF   70,W
076F:  MOVWF  78
0770:  MOVF   6F,W
0771:  MOVWF  79
0772:  CLRF   7A
0773:  MOVF   78,F
0774:  BTFSS  03.2
0775:  GOTO   780
0776:  MOVF   79,W
0777:  MOVWF  78
0778:  CLRF   79
0779:  MOVLW  08
077A:  SUBWF  77,F
077B:  MOVF   78,F
077C:  BTFSS  03.2
077D:  GOTO   780
077E:  CLRF   77
077F:  GOTO   788
0780:  BCF    03.0
0781:  BTFSC  78.7
0782:  GOTO   787
0783:  RLF    79,F
0784:  RLF    78,F
0785:  DECF   77,F
0786:  GOTO   780
0787:  BCF    78.7
0788:  RETURN
0789:  MOVLW  8E
078A:  MOVWF  77
078B:  MOVF   6B,W
078C:  SUBWF  77,F
078D:  MOVF   6C,W
078E:  MOVWF  79
078F:  MOVF   6D,W
0790:  MOVWF  78
0791:  BSF    79.7
0792:  MOVF   77,F
0793:  BTFSC  03.2
0794:  GOTO   7A0
0795:  BCF    03.0
0796:  MOVF   79,F
0797:  BTFSS  03.2
0798:  GOTO   79C
0799:  MOVF   78,F
079A:  BTFSC  03.2
079B:  GOTO   7A0
079C:  RRF    79,F
079D:  RRF    78,F
079E:  DECFSZ 77,F
079F:  GOTO   795
07A0:  BTFSS  6C.7
07A1:  GOTO   7A7
07A2:  COMF   78,F
07A3:  COMF   79,F
07A4:  INCF   78,F
07A5:  BTFSC  03.2
07A6:  INCF   79,F
07A7:  RETURN
*
0800:  MOVF   04,W
0801:  MOVWF  6A
0802:  MOVF   69,W
0803:  MOVWF  6C
0804:  BTFSC  03.2
0805:  GOTO   021
0806:  MOVF   68,W
0807:  MOVWF  75
0808:  MOVF   67,W
0809:  MOVWF  74
080A:  MOVF   66,W
080B:  MOVWF  73
080C:  MOVF   65,W
080D:  MOVWF  72
080E:  CLRF   7E
080F:  CLRF   7D
0810:  MOVLW  20
0811:  MOVWF  7C
0812:  MOVLW  82
0813:  MOVWF  7B
0814:  BCF    0A.3
0815:  CALL   64B
0816:  BSF    0A.3
0817:  MOVF   7A,W
0818:  MOVWF  68
0819:  MOVF   79,W
081A:  MOVWF  67
081B:  MOVF   78,W
081C:  MOVWF  66
081D:  MOVF   77,W
081E:  MOVWF  65
081F:  DECFSZ 6C,F
0820:  GOTO   006
0821:  MOVF   68,W
0822:  MOVWF  75
0823:  MOVF   67,W
0824:  MOVWF  74
0825:  MOVF   66,W
0826:  MOVWF  73
0827:  MOVF   65,W
0828:  MOVWF  72
0829:  BCF    0A.3
082A:  CALL   6D1
082B:  BSF    0A.3
082C:  MOVF   7A,W
082D:  MOVWF  68
082E:  MOVF   79,W
082F:  MOVWF  67
0830:  MOVF   78,W
0831:  MOVWF  66
0832:  MOVF   77,W
0833:  MOVWF  65
0834:  BTFSS  68.7
0835:  GOTO   043
0836:  DECF   6A,F
0837:  BSF    6A.5
0838:  COMF   65,F
0839:  COMF   66,F
083A:  COMF   67,F
083B:  COMF   68,F
083C:  INCF   65,F
083D:  BTFSC  03.2
083E:  INCF   66,F
083F:  BTFSC  03.2
0840:  INCF   67,F
0841:  BTFSC  03.2
0842:  INCF   68,F
0843:  MOVLW  3B
0844:  MOVWF  71
0845:  MOVLW  9A
0846:  MOVWF  70
0847:  MOVLW  CA
0848:  MOVWF  6F
0849:  CLRF   6E
084A:  MOVLW  0A
084B:  MOVWF  6C
084C:  MOVF   69,W
084D:  BTFSC  03.2
084E:  INCF   6A,F
084F:  BSF    03.1
0850:  MOVLW  65
0851:  MOVWF  04
0852:  BCF    03.7
0853:  MOVF   68,W
0854:  MOVWF  75
0855:  MOVF   67,W
0856:  MOVWF  74
0857:  MOVF   66,W
0858:  MOVWF  73
0859:  MOVF   65,W
085A:  MOVWF  72
085B:  MOVF   71,W
085C:  MOVWF  7E
085D:  MOVF   70,W
085E:  MOVWF  7D
085F:  MOVF   6F,W
0860:  MOVWF  7C
0861:  MOVF   6E,W
0862:  MOVWF  7B
0863:  BCF    0A.3
0864:  CALL   6F0
0865:  BSF    0A.3
0866:  MOVF   78,W
0867:  MOVF   77,F
0868:  BTFSS  03.2
0869:  GOTO   07D
086A:  INCF   69,W
086B:  SUBWF  6C,W
086C:  BTFSC  03.2
086D:  GOTO   07D
086E:  MOVF   6A,W
086F:  BTFSC  03.2
0870:  GOTO   07F
0871:  ANDLW  0F
0872:  SUBWF  6C,W
0873:  BTFSC  03.2
0874:  GOTO   077
0875:  BTFSC  03.0
0876:  GOTO   0B7
0877:  BTFSC  6A.7
0878:  GOTO   0B7
0879:  BTFSC  6A.6
087A:  GOTO   07F
087B:  MOVLW  20
087C:  GOTO   0B1
087D:  MOVLW  20
087E:  ANDWF  6A,F
087F:  BTFSS  6A.5
0880:  GOTO   08F
0881:  BCF    6A.5
0882:  MOVF   69,W
0883:  BTFSS  03.2
0884:  DECF   6A,F
0885:  MOVF   77,W
0886:  MOVWF  6A
0887:  MOVLW  2D
0888:  MOVWF  72
0889:  BCF    0A.3
088A:  CALL   741
088B:  BSF    0A.3
088C:  MOVF   6A,W
088D:  MOVWF  77
088E:  CLRF   6A
088F:  MOVF   69,W
0890:  SUBWF  6C,W
0891:  BTFSS  03.2
0892:  GOTO   09F
0893:  MOVF   77,W
0894:  MOVWF  6A
0895:  MOVLW  2E
0896:  MOVWF  72
0897:  BCF    0A.3
0898:  CALL   741
0899:  BSF    0A.3
089A:  MOVF   6A,W
089B:  MOVWF  77
089C:  MOVLW  20
089D:  ANDWF  6A,F
089E:  MOVLW  00
089F:  MOVLW  30
08A0:  BTFSS  6A.5
08A1:  GOTO   0B1
08A2:  BCF    6A.5
08A3:  MOVF   69,W
08A4:  BTFSS  03.2
08A5:  DECF   6A,F
08A6:  MOVF   77,W
08A7:  MOVWF  6A
08A8:  MOVLW  2D
08A9:  MOVWF  72
08AA:  BCF    0A.3
08AB:  CALL   741
08AC:  BSF    0A.3
08AD:  MOVF   6A,W
08AE:  MOVWF  77
08AF:  CLRF   6A
08B0:  MOVLW  30
08B1:  ADDWF  77,F
08B2:  MOVF   77,W
08B3:  MOVWF  72
08B4:  BCF    0A.3
08B5:  CALL   741
08B6:  BSF    0A.3
08B7:  BCF    03.1
08B8:  MOVF   71,W
08B9:  MOVWF  75
08BA:  MOVF   70,W
08BB:  MOVWF  74
08BC:  MOVF   6F,W
08BD:  MOVWF  73
08BE:  MOVF   6E,W
08BF:  MOVWF  72
08C0:  CLRF   7E
08C1:  CLRF   7D
08C2:  CLRF   7C
08C3:  MOVLW  0A
08C4:  MOVWF  7B
08C5:  BCF    0A.3
08C6:  CALL   6F0
08C7:  BSF    0A.3
08C8:  MOVF   7A,W
08C9:  MOVWF  71
08CA:  MOVF   79,W
08CB:  MOVWF  70
08CC:  MOVF   78,W
08CD:  MOVWF  6F
08CE:  MOVF   77,W
08CF:  MOVWF  6E
08D0:  DECFSZ 6C,F
08D1:  GOTO   04F
08D2:  BSF    0A.3
08D3:  BCF    0A.4
08D4:  GOTO   483 (RETURN)
08D5:  MOVLW  80
08D6:  BTFSC  03.1
08D7:  XORWF  74,F
08D8:  BSF    03.5
08D9:  CLRF   22
08DA:  CLRF   23
08DB:  MOVF   70,W
08DC:  MOVWF  21
08DD:  MOVF   74,W
08DE:  XORWF  21,F
08DF:  BCF    03.5
08E0:  MOVF   6F,W
08E1:  BTFSC  03.2
08E2:  GOTO   1CB
08E3:  BSF    03.5
08E4:  MOVWF  20
08E5:  MOVWF  77
08E6:  MOVF   73,W
08E7:  BTFSC  03.2
08E8:  GOTO   1D5
08E9:  SUBWF  20,F
08EA:  BTFSC  03.2
08EB:  GOTO   16F
08EC:  BTFSS  03.0
08ED:  GOTO   12B
08EE:  MOVF   74,W
08EF:  MOVWF  26
08F0:  BSF    26.7
08F1:  MOVF   75,W
08F2:  MOVWF  25
08F3:  MOVF   76,W
08F4:  MOVWF  24
08F5:  CLRF   23
08F6:  BCF    03.0
08F7:  RRF    26,F
08F8:  RRF    25,F
08F9:  RRF    24,F
08FA:  RRF    23,F
08FB:  DECFSZ 20,F
08FC:  GOTO   0F5
08FD:  BTFSS  21.7
08FE:  GOTO   102
08FF:  BSF    22.0
0900:  GOTO   1EB
0901:  BCF    22.0
0902:  BCF    20.0
0903:  BSF    22.4
0904:  MOVLW  72
0905:  MOVWF  04
0906:  BCF    03.7
0907:  GOTO   200
0908:  BCF    22.4
0909:  BTFSC  21.7
090A:  GOTO   115
090B:  BTFSS  20.0
090C:  GOTO   120
090D:  RRF    26,F
090E:  RRF    25,F
090F:  RRF    24,F
0910:  RRF    23,F
0911:  INCF   77,F
0912:  BTFSC  03.2
0913:  GOTO   1E6
0914:  GOTO   120
0915:  BTFSC  26.7
0916:  GOTO   123
0917:  BCF    03.0
0918:  RLF    23,F
0919:  RLF    24,F
091A:  RLF    25,F
091B:  RLF    26,F
091C:  DECF   77,F
091D:  BTFSC  03.2
091E:  GOTO   1E6
091F:  GOTO   115
0920:  BSF    22.6
0921:  GOTO   18F
0922:  BCF    22.6
0923:  MOVF   70,W
0924:  MOVWF  21
0925:  BTFSS  21.7
0926:  GOTO   129
0927:  BSF    26.7
0928:  GOTO   1DF
0929:  BCF    26.7
092A:  GOTO   1DF
092B:  MOVF   73,W
092C:  MOVWF  20
092D:  MOVWF  77
092E:  BCF    03.5
092F:  MOVF   6F,W
0930:  BSF    03.5
0931:  SUBWF  20,F
0932:  MOVF   70,W
0933:  MOVWF  26
0934:  BSF    26.7
0935:  MOVF   71,W
0936:  MOVWF  25
0937:  MOVF   72,W
0938:  MOVWF  24
0939:  CLRF   23
093A:  BCF    03.0
093B:  RRF    26,F
093C:  RRF    25,F
093D:  RRF    24,F
093E:  RRF    23,F
093F:  DECFSZ 20,F
0940:  GOTO   139
0941:  BTFSS  21.7
0942:  GOTO   146
0943:  BSF    22.1
0944:  GOTO   1EB
0945:  BCF    22.1
0946:  BCF    20.0
0947:  BSF    22.5
0948:  MOVLW  76
0949:  MOVWF  04
094A:  BCF    03.7
094B:  GOTO   200
094C:  BCF    22.5
094D:  BTFSC  21.7
094E:  GOTO   159
094F:  BTFSS  20.0
0950:  GOTO   164
0951:  RRF    26,F
0952:  RRF    25,F
0953:  RRF    24,F
0954:  RRF    23,F
0955:  INCF   77,F
0956:  BTFSC  03.2
0957:  GOTO   1E6
0958:  GOTO   164
0959:  BTFSC  26.7
095A:  GOTO   167
095B:  BCF    03.0
095C:  RLF    23,F
095D:  RLF    24,F
095E:  RLF    25,F
095F:  RLF    26,F
0960:  DECF   77,F
0961:  BTFSC  03.2
0962:  GOTO   1E6
0963:  GOTO   159
0964:  BSF    22.7
0965:  GOTO   18F
0966:  BCF    22.7
0967:  MOVF   74,W
0968:  MOVWF  21
0969:  BTFSS  21.7
096A:  GOTO   16D
096B:  BSF    26.7
096C:  GOTO   1DF
096D:  BCF    26.7
096E:  GOTO   1DF
096F:  MOVF   74,W
0970:  MOVWF  26
0971:  BSF    26.7
0972:  MOVF   75,W
0973:  MOVWF  25
0974:  MOVF   76,W
0975:  MOVWF  24
0976:  BTFSS  21.7
0977:  GOTO   17C
0978:  BCF    26.7
0979:  BSF    22.2
097A:  GOTO   1EB
097B:  BCF    22.2
097C:  CLRF   23
097D:  BCF    20.0
097E:  MOVLW  72
097F:  MOVWF  04
0980:  BCF    03.7
0981:  GOTO   200
0982:  BTFSC  21.7
0983:  GOTO   1A5
0984:  MOVF   70,W
0985:  MOVWF  21
0986:  BTFSS  20.0
0987:  GOTO   18F
0988:  RRF    26,F
0989:  RRF    25,F
098A:  RRF    24,F
098B:  RRF    23,F
098C:  INCF   77,F
098D:  BTFSC  03.2
098E:  GOTO   1E6
098F:  BTFSS  23.7
0990:  GOTO   1A0
0991:  INCF   24,F
0992:  BTFSS  03.2
0993:  GOTO   1A0
0994:  INCF   25,F
0995:  BTFSS  03.2
0996:  GOTO   1A0
0997:  INCF   26,F
0998:  BTFSS  03.2
0999:  GOTO   1A0
099A:  RRF    26,F
099B:  RRF    25,F
099C:  RRF    24,F
099D:  INCF   77,F
099E:  BTFSC  03.2
099F:  GOTO   1E6
09A0:  BTFSC  22.6
09A1:  GOTO   122
09A2:  BTFSC  22.7
09A3:  GOTO   166
09A4:  GOTO   1C4
09A5:  MOVLW  80
09A6:  XORWF  26,F
09A7:  BTFSS  26.7
09A8:  GOTO   1AD
09A9:  GOTO   1EB
09AA:  MOVF   74,W
09AB:  MOVWF  21
09AC:  GOTO   1BA
09AD:  MOVF   70,W
09AE:  MOVWF  21
09AF:  MOVF   26,F
09B0:  BTFSS  03.2
09B1:  GOTO   1BA
09B2:  MOVF   25,F
09B3:  BTFSS  03.2
09B4:  GOTO   1BA
09B5:  MOVF   24,F
09B6:  BTFSS  03.2
09B7:  GOTO   1BA
09B8:  CLRF   77
09B9:  GOTO   1DF
09BA:  BTFSC  26.7
09BB:  GOTO   1C4
09BC:  BCF    03.0
09BD:  RLF    23,F
09BE:  RLF    24,F
09BF:  RLF    25,F
09C0:  RLF    26,F
09C1:  DECFSZ 77,F
09C2:  GOTO   1BA
09C3:  GOTO   1E6
09C4:  BTFSS  21.7
09C5:  GOTO   1C8
09C6:  BSF    26.7
09C7:  GOTO   1DF
09C8:  BCF    26.7
09C9:  GOTO   1DF
09CA:  BCF    03.5
09CB:  MOVF   73,W
09CC:  MOVWF  77
09CD:  MOVF   74,W
09CE:  BSF    03.5
09CF:  MOVWF  26
09D0:  MOVF   75,W
09D1:  MOVWF  25
09D2:  MOVF   76,W
09D3:  MOVWF  24
09D4:  GOTO   1DF
09D5:  BCF    03.5
09D6:  MOVF   6F,W
09D7:  MOVWF  77
09D8:  MOVF   70,W
09D9:  BSF    03.5
09DA:  MOVWF  26
09DB:  MOVF   71,W
09DC:  MOVWF  25
09DD:  MOVF   72,W
09DE:  MOVWF  24
09DF:  MOVF   26,W
09E0:  MOVWF  78
09E1:  MOVF   25,W
09E2:  MOVWF  79
09E3:  MOVF   24,W
09E4:  MOVWF  7A
09E5:  GOTO   21E
09E6:  CLRF   77
09E7:  CLRF   78
09E8:  CLRF   79
09E9:  CLRF   7A
09EA:  GOTO   21E
09EB:  CLRF   23
09EC:  COMF   24,F
09ED:  COMF   25,F
09EE:  COMF   26,F
09EF:  COMF   23,F
09F0:  INCF   23,F
09F1:  BTFSS  03.2
09F2:  GOTO   1F9
09F3:  INCF   24,F
09F4:  BTFSS  03.2
09F5:  GOTO   1F9
09F6:  INCF   25,F
09F7:  BTFSC  03.2
09F8:  INCF   26,F
09F9:  BTFSC  22.0
09FA:  GOTO   101
09FB:  BTFSC  22.1
09FC:  GOTO   145
09FD:  BTFSC  22.2
09FE:  GOTO   17B
09FF:  GOTO   1AA
0A00:  MOVF   00,W
0A01:  ADDWF  24,F
0A02:  BTFSS  03.0
0A03:  GOTO   20A
0A04:  INCF   25,F
0A05:  BTFSS  03.2
0A06:  GOTO   20A
0A07:  INCF   26,F
0A08:  BTFSC  03.2
0A09:  BSF    20.0
0A0A:  DECF   04,F
0A0B:  MOVF   00,W
0A0C:  ADDWF  25,F
0A0D:  BTFSS  03.0
0A0E:  GOTO   212
0A0F:  INCF   26,F
0A10:  BTFSC  03.2
0A11:  BSF    20.0
0A12:  DECF   04,F
0A13:  MOVF   00,W
0A14:  BTFSS  00.7
0A15:  XORLW  80
0A16:  ADDWF  26,F
0A17:  BTFSC  03.0
0A18:  BSF    20.0
0A19:  BTFSC  22.4
0A1A:  GOTO   108
0A1B:  BTFSC  22.5
0A1C:  GOTO   14C
0A1D:  GOTO   182
0A1E:  BCF    03.5
0A1F:  RETURN
*
0A40:  MOVLW  8E
0A41:  MOVWF  77
0A42:  MOVF   6B,W
0A43:  MOVWF  78
0A44:  MOVF   6A,W
0A45:  MOVWF  79
0A46:  CLRF   7A
0A47:  BTFSS  6B.7
0A48:  GOTO   24E
0A49:  COMF   78,F
0A4A:  COMF   79,F
0A4B:  INCF   79,F
0A4C:  BTFSC  03.2
0A4D:  INCF   78,F
0A4E:  MOVF   78,F
0A4F:  BTFSS  03.2
0A50:  GOTO   25B
0A51:  MOVF   79,W
0A52:  MOVWF  78
0A53:  CLRF   79
0A54:  MOVLW  08
0A55:  SUBWF  77,F
0A56:  MOVF   78,F
0A57:  BTFSS  03.2
0A58:  GOTO   25B
0A59:  CLRF   77
0A5A:  GOTO   264
0A5B:  BCF    03.0
0A5C:  BTFSC  78.7
0A5D:  GOTO   262
0A5E:  RLF    79,F
0A5F:  RLF    78,F
0A60:  DECF   77,F
0A61:  GOTO   25B
0A62:  BTFSS  6B.7
0A63:  BCF    78.7
*
0B03:  MOVF   04,W
0B04:  MOVWF  6A
0B05:  MOVF   69,W
0B06:  MOVWF  6C
0B07:  BTFSC  03.2
0B08:  GOTO   324
0B09:  MOVF   68,W
0B0A:  MOVWF  75
0B0B:  MOVF   67,W
0B0C:  MOVWF  74
0B0D:  MOVF   66,W
0B0E:  MOVWF  73
0B0F:  MOVF   65,W
0B10:  MOVWF  72
0B11:  CLRF   7E
0B12:  CLRF   7D
0B13:  MOVLW  20
0B14:  MOVWF  7C
0B15:  MOVLW  82
0B16:  MOVWF  7B
0B17:  BCF    0A.3
0B18:  CALL   64B
0B19:  BSF    0A.3
0B1A:  MOVF   7A,W
0B1B:  MOVWF  68
0B1C:  MOVF   79,W
0B1D:  MOVWF  67
0B1E:  MOVF   78,W
0B1F:  MOVWF  66
0B20:  MOVF   77,W
0B21:  MOVWF  65
0B22:  DECFSZ 6C,F
0B23:  GOTO   309
0B24:  MOVF   68,W
0B25:  MOVWF  75
0B26:  MOVF   67,W
0B27:  MOVWF  74
0B28:  MOVF   66,W
0B29:  MOVWF  73
0B2A:  MOVF   65,W
0B2B:  MOVWF  72
0B2C:  BCF    0A.3
0B2D:  CALL   6D1
0B2E:  BSF    0A.3
0B2F:  MOVF   7A,W
0B30:  MOVWF  68
0B31:  MOVF   79,W
0B32:  MOVWF  67
0B33:  MOVF   78,W
0B34:  MOVWF  66
0B35:  MOVF   77,W
0B36:  MOVWF  65
0B37:  BTFSS  68.7
0B38:  GOTO   346
0B39:  DECF   6A,F
0B3A:  BSF    6A.5
0B3B:  COMF   65,F
0B3C:  COMF   66,F
0B3D:  COMF   67,F
0B3E:  COMF   68,F
0B3F:  INCF   65,F
0B40:  BTFSC  03.2
0B41:  INCF   66,F
0B42:  BTFSC  03.2
0B43:  INCF   67,F
0B44:  BTFSC  03.2
0B45:  INCF   68,F
0B46:  MOVLW  3B
0B47:  MOVWF  71
0B48:  MOVLW  9A
0B49:  MOVWF  70
0B4A:  MOVLW  CA
0B4B:  MOVWF  6F
0B4C:  CLRF   6E
0B4D:  MOVLW  0A
0B4E:  MOVWF  6C
0B4F:  MOVF   69,W
0B50:  BTFSC  03.2
0B51:  INCF   6A,F
0B52:  BSF    03.1
0B53:  MOVLW  65
0B54:  MOVWF  04
0B55:  BCF    03.7
0B56:  MOVF   68,W
0B57:  MOVWF  75
0B58:  MOVF   67,W
0B59:  MOVWF  74
0B5A:  MOVF   66,W
0B5B:  MOVWF  73
0B5C:  MOVF   65,W
0B5D:  MOVWF  72
0B5E:  MOVF   71,W
0B5F:  MOVWF  7E
0B60:  MOVF   70,W
0B61:  MOVWF  7D
0B62:  MOVF   6F,W
0B63:  MOVWF  7C
0B64:  MOVF   6E,W
0B65:  MOVWF  7B
0B66:  BCF    0A.3
0B67:  CALL   6F0
0B68:  BSF    0A.3
0B69:  MOVF   78,W
0B6A:  MOVF   77,F
0B6B:  BTFSS  03.2
0B6C:  GOTO   380
0B6D:  INCF   69,W
0B6E:  SUBWF  6C,W
0B6F:  BTFSC  03.2
0B70:  GOTO   380
0B71:  MOVF   6A,W
0B72:  BTFSC  03.2
0B73:  GOTO   382
0B74:  ANDLW  0F
0B75:  SUBWF  6C,W
0B76:  BTFSC  03.2
0B77:  GOTO   37A
0B78:  BTFSC  03.0
0B79:  GOTO   3B6
0B7A:  BTFSC  6A.7
0B7B:  GOTO   3B6
0B7C:  BTFSC  6A.6
0B7D:  GOTO   382
0B7E:  MOVLW  20
0B7F:  GOTO   3B1
0B80:  MOVLW  20
0B81:  ANDWF  6A,F
0B82:  BTFSS  6A.5
0B83:  GOTO   391
0B84:  BCF    6A.5
0B85:  MOVF   69,W
0B86:  BTFSS  03.2
0B87:  DECF   6A,F
0B88:  MOVF   77,W
0B89:  MOVWF  6A
0B8A:  MOVLW  2D
0B8B:  BTFSS  0C.4
0B8C:  GOTO   38B
0B8D:  MOVWF  19
0B8E:  MOVF   6A,W
0B8F:  MOVWF  77
0B90:  CLRF   6A
0B91:  MOVF   69,W
0B92:  SUBWF  6C,W
0B93:  BTFSS  03.2
0B94:  GOTO   3A0
0B95:  MOVF   77,W
0B96:  MOVWF  6A
0B97:  MOVLW  2E
0B98:  BTFSS  0C.4
0B99:  GOTO   398
0B9A:  MOVWF  19
0B9B:  MOVF   6A,W
0B9C:  MOVWF  77
0B9D:  MOVLW  20
0B9E:  ANDWF  6A,F
0B9F:  MOVLW  00
0BA0:  MOVLW  30
0BA1:  BTFSS  6A.5
0BA2:  GOTO   3B1
0BA3:  BCF    6A.5
0BA4:  MOVF   69,W
0BA5:  BTFSS  03.2
0BA6:  DECF   6A,F
0BA7:  MOVF   77,W
0BA8:  MOVWF  6A
0BA9:  MOVLW  2D
0BAA:  BTFSS  0C.4
0BAB:  GOTO   3AA
0BAC:  MOVWF  19
0BAD:  MOVF   6A,W
0BAE:  MOVWF  77
0BAF:  CLRF   6A
0BB0:  MOVLW  30
0BB1:  ADDWF  77,F
0BB2:  MOVF   77,W
0BB3:  BTFSS  0C.4
0BB4:  GOTO   3B3
0BB5:  MOVWF  19
0BB6:  BCF    03.1
0BB7:  MOVF   71,W
0BB8:  MOVWF  75
0BB9:  MOVF   70,W
0BBA:  MOVWF  74
0BBB:  MOVF   6F,W
0BBC:  MOVWF  73
0BBD:  MOVF   6E,W
0BBE:  MOVWF  72
0BBF:  CLRF   7E
0BC0:  CLRF   7D
0BC1:  CLRF   7C
0BC2:  MOVLW  0A
0BC3:  MOVWF  7B
0BC4:  BCF    0A.3
0BC5:  CALL   6F0
0BC6:  BSF    0A.3
0BC7:  MOVF   7A,W
0BC8:  MOVWF  71
0BC9:  MOVF   79,W
0BCA:  MOVWF  70
0BCB:  MOVF   78,W
0BCC:  MOVWF  6F
0BCD:  MOVF   77,W
0BCE:  MOVWF  6E
0BCF:  DECFSZ 6C,F
0BD0:  GOTO   352
0BD1:  BSF    0A.3
0BD2:  BCF    0A.4
0BD3:  GOTO   50B (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=8000000) 
*
07A8:  MOVLW  63
07A9:  MOVWF  04
07AA:  BCF    03.7
07AB:  MOVF   00,W
07AC:  BTFSC  03.2
07AD:  GOTO   7BB
07AE:  MOVLW  02
07AF:  MOVWF  78
07B0:  CLRF   77
07B1:  DECFSZ 77,F
07B2:  GOTO   7B1
07B3:  DECFSZ 78,F
07B4:  GOTO   7B0
07B5:  MOVLW  97
07B6:  MOVWF  77
07B7:  DECFSZ 77,F
07B8:  GOTO   7B7
07B9:  DECFSZ 00,F
07BA:  GOTO   7AE
07BB:  RETURN
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, bits=8, parity=N) 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
074E:  MOVF   62,W
074F:  MOVWF  64
0750:  MOVF   61,W
0751:  MOVWF  63
0752:  MOVF   64,W
0753:  MOVWF  7A
0754:  MOVF   63,W
0755:  MOVWF  04
0756:  BCF    03.7
0757:  BTFSC  7A.0
0758:  BSF    03.7
0759:  MOVF   00,F
075A:  BTFSC  03.2
075B:  GOTO   760
075C:  INCF   63,F
075D:  BTFSC  03.2
075E:  INCF   64,F
075F:  GOTO   752
....................    return(sc - s); 
0760:  MOVF   61,W
0761:  SUBWF  63,W
0762:  MOVWF  77
0763:  MOVF   64,W
0764:  MOVWF  7A
0765:  MOVF   62,W
0766:  BTFSS  03.0
0767:  INCFSZ 62,W
0768:  SUBWF  7A,F
0769:  MOVF   77,W
076A:  MOVWF  78
076B:  RETURN
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0BEE:  BCF    03.5
0BEF:  CLRF   28
0BF0:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses XT, NOWDT,NOPROTECT,NOLVP 
.................... #include <HDM64GS12.c> //Manejo del display gráfico 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
034C:  BCF    2A.0
034D:  MOVF   2A,W
034E:  BSF    03.5
034F:  MOVWF  07
0350:  BCF    03.5
0351:  BSF    07.0
....................    output_low(GLCD_E); 
0352:  BSF    03.5
0353:  BCF    06.5
0354:  BCF    03.5
0355:  BCF    06.5
....................    output_low(GLCD_CS1); 
0356:  BSF    03.5
0357:  BCF    06.0
0358:  BCF    03.5
0359:  BCF    06.0
....................    output_low(GLCD_CS2); 
035A:  BSF    03.5
035B:  BCF    06.1
035C:  BCF    03.5
035D:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
035E:  BSF    03.5
035F:  BCF    06.2
0360:  BCF    03.5
0361:  BCF    06.2
0362:  CLRF   27
0363:  BTFSC  0B.7
0364:  BSF    27.7
0365:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
0366:  BSF    03.5
0367:  CLRF   3D
0368:  MOVLW  C0
0369:  MOVWF  3E
036A:  BCF    03.5
036B:  CALL   218
036C:  BTFSC  27.7
036D:  BSF    0B.7
036E:  CLRF   27
036F:  BTFSC  0B.7
0370:  BSF    27.7
0371:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
0372:  MOVLW  01
0373:  BSF    03.5
0374:  MOVWF  3D
0375:  MOVLW  C0
0376:  MOVWF  3E
0377:  BCF    03.5
0378:  CALL   218
0379:  BTFSC  27.7
037A:  BSF    0B.7
037B:  CLRF   27
037C:  BTFSC  0B.7
037D:  BSF    27.7
037E:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
037F:  BSF    03.5
0380:  CLRF   3D
0381:  MOVLW  40
0382:  MOVWF  3E
0383:  BCF    03.5
0384:  CALL   218
0385:  BTFSC  27.7
0386:  BSF    0B.7
0387:  CLRF   27
0388:  BTFSC  0B.7
0389:  BSF    27.7
038A:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
038B:  MOVLW  01
038C:  BSF    03.5
038D:  MOVWF  3D
038E:  MOVLW  40
038F:  MOVWF  3E
0390:  BCF    03.5
0391:  CALL   218
0392:  BTFSC  27.7
0393:  BSF    0B.7
0394:  CLRF   27
0395:  BTFSC  0B.7
0396:  BSF    27.7
0397:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
0398:  BSF    03.5
0399:  CLRF   3D
039A:  MOVLW  B8
039B:  MOVWF  3E
039C:  BCF    03.5
039D:  CALL   218
039E:  BTFSC  27.7
039F:  BSF    0B.7
03A0:  CLRF   27
03A1:  BTFSC  0B.7
03A2:  BSF    27.7
03A3:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
03A4:  MOVLW  01
03A5:  BSF    03.5
03A6:  MOVWF  3D
03A7:  MOVLW  B8
03A8:  MOVWF  3E
03A9:  BCF    03.5
03AA:  CALL   218
03AB:  BTFSC  27.7
03AC:  BSF    0B.7
....................  
....................    if(mode == ON) 
03AD:  DECFSZ 61,W
03AE:  GOTO   3C9
03AF:  CLRF   27
03B0:  BTFSC  0B.7
03B1:  BSF    27.7
03B2:  BCF    0B.7
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
03B3:  BSF    03.5
03B4:  CLRF   3D
03B5:  MOVLW  3F
03B6:  MOVWF  3E
03B7:  BCF    03.5
03B8:  CALL   218
03B9:  BTFSC  27.7
03BA:  BSF    0B.7
03BB:  CLRF   27
03BC:  BTFSC  0B.7
03BD:  BSF    27.7
03BE:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
03BF:  MOVLW  01
03C0:  BSF    03.5
03C1:  MOVWF  3D
03C2:  MOVLW  3F
03C3:  MOVWF  3E
03C4:  BCF    03.5
03C5:  CALL   218
03C6:  BTFSC  27.7
03C7:  BSF    0B.7
....................    } 
03C8:  GOTO   3E2
03C9:  CLRF   27
03CA:  BTFSC  0B.7
03CB:  BSF    27.7
03CC:  BCF    0B.7
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
03CD:  BSF    03.5
03CE:  CLRF   3D
03CF:  MOVLW  3E
03D0:  MOVWF  3E
03D1:  BCF    03.5
03D2:  CALL   218
03D3:  BTFSC  27.7
03D4:  BSF    0B.7
03D5:  CLRF   27
03D6:  BTFSC  0B.7
03D7:  BSF    27.7
03D8:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
03D9:  MOVLW  01
03DA:  BSF    03.5
03DB:  MOVWF  3D
03DC:  MOVLW  3E
03DD:  MOVWF  3E
03DE:  BCF    03.5
03DF:  CALL   218
03E0:  BTFSC  27.7
03E1:  BSF    0B.7
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
03E2:  CLRF   62
....................  
....................    #ifdef FAST_GLCD 
*
0468:  BSF    0A.3
0469:  BCF    0A.4
046A:  GOTO   432 (RETURN)
....................    glcd_update(); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
*
0272:  BSF    03.5
0273:  BCF    3A.0
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
0274:  MOVF   36,W
0275:  SUBLW  3F
0276:  BTFSC  03.0
0277:  GOTO   27B
....................    { 
....................       x -= 64; 
0278:  MOVLW  40
0279:  SUBWF  36,F
....................       side = GLCD_RIGHT; 
027A:  BSF    3A.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
027B:  BCF    06.2
027C:  BCF    03.5
027D:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
027E:  BSF    03.5
027F:  BCF    36.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0280:  BSF    36.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
0281:  MOVLW  00
0282:  BTFSC  3A.0
0283:  MOVLW  01
0284:  MOVWF  3B
0285:  MOVWF  3D
0286:  MOVF   36,W
0287:  MOVWF  3E
0288:  BCF    03.5
0289:  CALL   218
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
028A:  MOVLW  00
028B:  BSF    03.5
028C:  BTFSC  3A.0
028D:  MOVLW  01
028E:  MOVWF  3B
028F:  RRF    37,W
0290:  MOVWF  77
0291:  RRF    77,F
0292:  RRF    77,F
0293:  MOVLW  1F
0294:  ANDWF  77,F
0295:  MOVF   77,W
0296:  ANDLW  BF
0297:  IORLW  B8
0298:  MOVWF  3C
0299:  MOVF   3B,W
029A:  MOVWF  3D
029B:  MOVF   3C,W
029C:  MOVWF  3E
029D:  BCF    03.5
029E:  CALL   218
....................    output_high(GLCD_DI);                        // Set for data 
029F:  BSF    03.5
02A0:  BCF    06.2
02A1:  BCF    03.5
02A2:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
02A3:  MOVLW  00
02A4:  BSF    03.5
02A5:  BTFSC  3A.0
02A6:  MOVLW  01
02A7:  MOVWF  3B
02A8:  MOVWF  3C
02A9:  BCF    03.5
02AA:  CALL   243
....................    data = glcd_readByte(side);                  //  at new address 
02AB:  MOVLW  00
02AC:  BSF    03.5
02AD:  BTFSC  3A.0
02AE:  MOVLW  01
02AF:  MOVWF  3B
02B0:  MOVWF  3C
02B1:  BCF    03.5
02B2:  CALL   243
02B3:  MOVF   78,W
02B4:  BSF    03.5
02B5:  MOVWF  39
....................  
....................    if(color == ON) 
02B6:  DECFSZ 38,W
02B7:  GOTO   2C8
....................       bit_set(data, y%8);        // Turn the pixel on 
02B8:  MOVF   37,W
02B9:  ANDLW  07
02BA:  MOVWF  3B
02BB:  MOVLW  01
02BC:  MOVWF  77
02BD:  MOVF   3B,W
02BE:  MOVWF  78
02BF:  BTFSC  03.2
02C0:  GOTO   2C5
02C1:  BCF    03.0
02C2:  RLF    77,F
02C3:  DECFSZ 78,F
02C4:  GOTO   2C1
02C5:  MOVF   77,W
02C6:  IORWF  39,F
02C7:  GOTO   2D8
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
02C8:  MOVF   37,W
02C9:  ANDLW  07
02CA:  MOVWF  3B
02CB:  MOVLW  01
02CC:  MOVWF  77
02CD:  MOVF   3B,W
02CE:  MOVWF  78
02CF:  BTFSC  03.2
02D0:  GOTO   2D5
02D1:  BCF    03.0
02D2:  RLF    77,F
02D3:  DECFSZ 78,F
02D4:  GOTO   2D1
02D5:  MOVF   77,W
02D6:  XORLW  FF
02D7:  ANDWF  39,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
02D8:  BCF    06.2
02D9:  BCF    03.5
02DA:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
02DB:  MOVLW  00
02DC:  BSF    03.5
02DD:  BTFSC  3A.0
02DE:  MOVLW  01
02DF:  MOVWF  3B
02E0:  MOVWF  3D
02E1:  MOVF   36,W
02E2:  MOVWF  3E
02E3:  BCF    03.5
02E4:  CALL   218
....................    output_high(GLCD_DI);         // Set for data 
02E5:  BSF    03.5
02E6:  BCF    06.2
02E7:  BCF    03.5
02E8:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
02E9:  MOVLW  00
02EA:  BSF    03.5
02EB:  BTFSC  3A.0
02EC:  MOVLW  01
02ED:  MOVWF  3B
02EE:  MOVWF  3D
02EF:  MOVF   39,W
02F0:  MOVWF  3E
02F1:  BCF    03.5
02F2:  CALL   218
02F3:  RETURN
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
03E3:  CLRF   63
03E4:  MOVF   63,W
03E5:  SUBLW  07
03E6:  BTFSS  03.0
03E7:  GOTO   468
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
03E8:  BSF    03.5
03E9:  BCF    06.2
03EA:  BCF    03.5
03EB:  BCF    06.2
03EC:  CLRF   27
03ED:  BTFSC  0B.7
03EE:  BSF    27.7
03EF:  BCF    0B.7
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
03F0:  BSF    03.5
03F1:  CLRF   3D
03F2:  MOVLW  40
03F3:  MOVWF  3E
03F4:  BCF    03.5
03F5:  CALL   218
03F6:  BTFSC  27.7
03F7:  BSF    0B.7
03F8:  CLRF   27
03F9:  BTFSC  0B.7
03FA:  BSF    27.7
03FB:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
03FC:  MOVLW  01
03FD:  BSF    03.5
03FE:  MOVWF  3D
03FF:  MOVLW  40
0400:  MOVWF  3E
0401:  BCF    03.5
0402:  CALL   218
0403:  BTFSC  27.7
0404:  BSF    0B.7
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
0405:  MOVF   63,W
0406:  IORLW  B8
0407:  MOVWF  65
0408:  CLRF   27
0409:  BTFSC  0B.7
040A:  BSF    27.7
040B:  BCF    0B.7
040C:  BSF    03.5
040D:  CLRF   3D
040E:  BCF    03.5
040F:  MOVF   65,W
0410:  BSF    03.5
0411:  MOVWF  3E
0412:  BCF    03.5
0413:  CALL   218
0414:  BTFSC  27.7
0415:  BSF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
0416:  MOVF   63,W
0417:  IORLW  B8
0418:  MOVWF  65
0419:  CLRF   27
041A:  BTFSC  0B.7
041B:  BSF    27.7
041C:  BCF    0B.7
041D:  MOVLW  01
041E:  BSF    03.5
041F:  MOVWF  3D
0420:  BCF    03.5
0421:  MOVF   65,W
0422:  BSF    03.5
0423:  MOVWF  3E
0424:  BCF    03.5
0425:  CALL   218
0426:  BTFSC  27.7
0427:  BSF    0B.7
....................       output_high(GLCD_DI);                     // Set for data 
0428:  BSF    03.5
0429:  BCF    06.2
042A:  BCF    03.5
042B:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
042C:  CLRF   64
042D:  MOVF   64,W
042E:  SUBLW  3F
042F:  BTFSS  03.0
0430:  GOTO   466
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
0431:  MOVLW  FF
0432:  BSF    03.5
0433:  MOVWF  22
0434:  BCF    03.5
0435:  MOVF   62,W
0436:  BSF    03.5
0437:  MOVWF  23
0438:  BCF    03.5
0439:  CALL   325
043A:  MOVF   78,W
043B:  MOVWF  65
043C:  CLRF   27
043D:  BTFSC  0B.7
043E:  BSF    27.7
043F:  BCF    0B.7
0440:  BSF    03.5
0441:  CLRF   3D
0442:  BCF    03.5
0443:  MOVF   78,W
0444:  BSF    03.5
0445:  MOVWF  3E
0446:  BCF    03.5
0447:  CALL   218
0448:  BTFSC  27.7
0449:  BSF    0B.7
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
044A:  MOVLW  FF
044B:  BSF    03.5
044C:  MOVWF  22
044D:  BCF    03.5
044E:  MOVF   62,W
044F:  BSF    03.5
0450:  MOVWF  23
0451:  BCF    03.5
0452:  CALL   325
0453:  MOVF   78,W
0454:  MOVWF  65
0455:  CLRF   27
0456:  BTFSC  0B.7
0457:  BSF    27.7
0458:  BCF    0B.7
0459:  MOVLW  01
045A:  BSF    03.5
045B:  MOVWF  3D
045C:  BCF    03.5
045D:  MOVF   78,W
045E:  BSF    03.5
045F:  MOVWF  3E
0460:  BCF    03.5
0461:  CALL   218
0462:  BTFSC  27.7
0463:  BSF    0B.7
0464:  INCF   64,F
0465:  GOTO   42D
....................       } 
0466:  INCF   63,F
0467:  GOTO   3E4
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    set_tris_d(0x00); 
*
0218:  MOVLW  00
0219:  BSF    03.5
021A:  MOVWF  08
....................     
....................    output_low(GLCD_RW);       // Set for writing 
021B:  BCF    06.4
021C:  BCF    03.5
021D:  BCF    06.4
....................  
.................... 	 if(side)                   // Choose which side to write to 
021E:  BSF    03.5
021F:  MOVF   3D,F
0220:  BTFSC  03.2
0221:  GOTO   227
....................       output_high(GLCD_CS2); 
0222:  BCF    06.1
0223:  BCF    03.5
0224:  BSF    06.1
0225:  GOTO   22A
0226:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS1); 
0227:  BCF    06.0
0228:  BCF    03.5
0229:  BSF    06.0
....................  
.................... 	 delay_us(1); 
022A:  GOTO   22B
....................  
....................    output_d(data);            // Put the data on the port 
022B:  BSF    03.5
022C:  CLRF   08
022D:  MOVF   3E,W
022E:  BCF    03.5
022F:  MOVWF  08
....................    delay_us(1); 
0230:  GOTO   231
....................    output_high(GLCD_E);       // Pulse the enable pin 
0231:  BSF    03.5
0232:  BCF    06.5
0233:  BCF    03.5
0234:  BSF    06.5
....................    delay_us(1); 
0235:  GOTO   236
....................    output_low(GLCD_E); 
0236:  BSF    03.5
0237:  BCF    06.5
0238:  BCF    03.5
0239:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
023A:  BSF    03.5
023B:  BCF    06.0
023C:  BCF    03.5
023D:  BCF    06.0
....................    output_low(GLCD_CS2); 
023E:  BSF    03.5
023F:  BCF    06.1
0240:  BCF    03.5
0241:  BCF    06.1
0242:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
0243:  MOVLW  FF
0244:  BSF    03.5
0245:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
0246:  BCF    06.4
0247:  BCF    03.5
0248:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
0249:  BSF    03.5
024A:  MOVF   3C,F
024B:  BTFSC  03.2
024C:  GOTO   252
....................       output_high(GLCD_CS2); 
024D:  BCF    06.1
024E:  BCF    03.5
024F:  BSF    06.1
0250:  GOTO   255
0251:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS1); 
0252:  BCF    06.0
0253:  BCF    03.5
0254:  BSF    06.0
....................  
....................    delay_us(1); 
0255:  GOTO   256
....................    output_high(GLCD_E);       // Pulse the enable pin 
0256:  BSF    03.5
0257:  BCF    06.5
0258:  BCF    03.5
0259:  BSF    06.5
....................    delay_us(1); 
025A:  GOTO   25B
....................    data = input_d();          // Get the data from the display's output register 
025B:  MOVLW  FF
025C:  BSF    03.5
025D:  MOVWF  08
025E:  BCF    03.5
025F:  MOVF   08,W
0260:  BSF    03.5
0261:  MOVWF  3D
....................    output_low(GLCD_E); 
0262:  BCF    06.5
0263:  BCF    03.5
0264:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0265:  BSF    03.5
0266:  BCF    06.0
0267:  BCF    03.5
0268:  BCF    06.0
....................    output_low(GLCD_CS2); 
0269:  BSF    03.5
026A:  BCF    06.1
026B:  BCF    03.5
026C:  BCF    06.1
....................    return data;               // Return the read data 
026D:  BSF    03.5
026E:  MOVF   3D,W
026F:  MOVWF  78
0270:  BCF    03.5
0271:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <graphics.c> //Funciones para dibujar y escribir en el display 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
*
056F:  MOVLW  01
0570:  MOVWF  75
0571:  MOVWF  76
0572:  BSF    03.5
0573:  CLRF   20
.................... { 
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
0574:  BCF    03.5
0575:  MOVF   6C,W
0576:  SUBWF  6E,W
0577:  BSF    03.5
0578:  MOVWF  21
0579:  MOVF   21,W
057A:  BTFSS  21.7
057B:  GOTO   57E
057C:  MOVF   21,W
057D:  SUBLW  00
057E:  CLRF   7A
057F:  MOVWF  73
0580:  MOVF   7A,W
0581:  MOVWF  74
....................    dy = abs((signed int8)(y2 - y1)); 
0582:  BCF    03.5
0583:  MOVF   6D,W
0584:  SUBWF  6F,W
0585:  BSF    03.5
0586:  MOVWF  21
0587:  MOVF   21,W
0588:  BTFSS  21.7
0589:  GOTO   58C
058A:  MOVF   21,W
058B:  SUBLW  00
058C:  CLRF   7A
058D:  MOVWF  71
058E:  MOVF   7A,W
058F:  MOVWF  72
....................    #endif 
....................  
....................    if(x1 > x2) 
0590:  BCF    03.5
0591:  MOVF   6C,W
0592:  SUBWF  6E,W
0593:  BTFSC  03.0
0594:  GOTO   597
....................       addx = -1; 
0595:  MOVLW  FF
0596:  MOVWF  75
....................    if(y1 > y2) 
0597:  MOVF   6D,W
0598:  SUBWF  6F,W
0599:  BTFSC  03.0
059A:  GOTO   59D
....................       addy = -1; 
059B:  MOVLW  FF
059C:  MOVWF  76
....................  
....................    if(dx >= dy) 
059D:  MOVF   72,W
059E:  SUBWF  74,W
059F:  BTFSS  03.0
05A0:  GOTO   5F9
05A1:  BTFSS  03.2
05A2:  GOTO   5A7
05A3:  MOVF   71,W
05A4:  SUBWF  73,W
05A5:  BTFSS  03.0
05A6:  GOTO   5F9
....................    { 
....................       dy *= 2; 
05A7:  BCF    03.0
05A8:  RLF    71,F
05A9:  RLF    72,F
....................       P = dy - dx; 
05AA:  MOVF   73,W
05AB:  SUBWF  71,W
05AC:  MOVWF  77
05AD:  MOVF   72,W
05AE:  MOVWF  7A
05AF:  MOVF   74,W
05B0:  BTFSS  03.0
05B1:  INCFSZ 74,W
05B2:  SUBWF  7A,F
05B3:  MOVF   77,W
05B4:  MOVWF  7B
05B5:  MOVF   7A,W
05B6:  MOVWF  7C
....................       diff = P - dx; 
05B7:  MOVF   73,W
05B8:  SUBWF  7B,W
05B9:  MOVWF  7D
05BA:  MOVF   7C,W
05BB:  MOVWF  7E
05BC:  MOVF   74,W
05BD:  BTFSS  03.0
05BE:  INCFSZ 74,W
05BF:  SUBWF  7E,F
....................  
....................       for(; i<=dx; ++i) 
05C0:  MOVF   74,F
05C1:  BTFSS  03.2
05C2:  GOTO   5C9
05C3:  BSF    03.5
05C4:  MOVF   20,W
05C5:  SUBWF  73,W
05C6:  BTFSS  03.0
05C7:  GOTO   5F7
05C8:  BCF    03.5
05C9:  CLRF   27
05CA:  BTFSC  0B.7
05CB:  BSF    27.7
05CC:  BCF    0B.7
....................       { 
....................          glcd_pixel(x1, y1, color); 
05CD:  MOVF   6C,W
05CE:  BSF    03.5
05CF:  MOVWF  36
05D0:  BCF    03.5
05D1:  MOVF   6D,W
05D2:  BSF    03.5
05D3:  MOVWF  37
05D4:  MOVF   70,W
05D5:  MOVWF  38
05D6:  BCF    03.5
05D7:  CALL   272
05D8:  BTFSC  27.7
05D9:  BSF    0B.7
....................  
....................          if(P < 0) 
05DA:  BTFSS  7C.7
05DB:  GOTO   5E6
....................          { 
....................             P  += dy; 
05DC:  MOVF   71,W
05DD:  ADDWF  7B,F
05DE:  MOVF   72,W
05DF:  BTFSC  03.0
05E0:  INCFSZ 72,W
05E1:  ADDWF  7C,F
....................             x1 += addx; 
05E2:  MOVF   75,W
05E3:  ADDWF  6C,W
05E4:  MOVWF  6C
....................          } 
05E5:  GOTO   5F2
....................          else 
....................          { 
....................             P  += diff; 
05E6:  MOVF   7D,W
05E7:  ADDWF  7B,F
05E8:  MOVF   7E,W
05E9:  BTFSC  03.0
05EA:  INCFSZ 7E,W
05EB:  ADDWF  7C,F
....................             x1 += addx; 
05EC:  MOVF   75,W
05ED:  ADDWF  6C,W
05EE:  MOVWF  6C
....................             y1 += addy; 
05EF:  MOVF   76,W
05F0:  ADDWF  6D,W
05F1:  MOVWF  6D
....................          } 
05F2:  BSF    03.5
05F3:  INCF   20,F
05F4:  BCF    03.5
05F5:  GOTO   5C0
05F6:  BSF    03.5
....................       } 
....................    } 
05F7:  GOTO   649
05F8:  BCF    03.5
....................    else 
....................    { 
....................       dx *= 2; 
05F9:  BCF    03.0
05FA:  RLF    73,F
05FB:  RLF    74,F
....................       P = dx - dy; 
05FC:  MOVF   71,W
05FD:  SUBWF  73,W
05FE:  MOVWF  77
05FF:  MOVF   74,W
0600:  MOVWF  7A
0601:  MOVF   72,W
0602:  BTFSS  03.0
0603:  INCFSZ 72,W
0604:  SUBWF  7A,F
0605:  MOVF   77,W
0606:  MOVWF  7B
0607:  MOVF   7A,W
0608:  MOVWF  7C
....................       diff = P - dy; 
0609:  MOVF   71,W
060A:  SUBWF  7B,W
060B:  MOVWF  7D
060C:  MOVF   7C,W
060D:  MOVWF  7E
060E:  MOVF   72,W
060F:  BTFSS  03.0
0610:  INCFSZ 72,W
0611:  SUBWF  7E,F
....................  
....................       for(; i<=dy; ++i) 
0612:  MOVF   72,F
0613:  BTFSS  03.2
0614:  GOTO   61B
0615:  BSF    03.5
0616:  MOVF   20,W
0617:  SUBWF  71,W
0618:  BTFSS  03.0
0619:  GOTO   649
061A:  BCF    03.5
061B:  CLRF   27
061C:  BTFSC  0B.7
061D:  BSF    27.7
061E:  BCF    0B.7
....................       { 
....................          glcd_pixel(x1, y1, color); 
061F:  MOVF   6C,W
0620:  BSF    03.5
0621:  MOVWF  36
0622:  BCF    03.5
0623:  MOVF   6D,W
0624:  BSF    03.5
0625:  MOVWF  37
0626:  MOVF   70,W
0627:  MOVWF  38
0628:  BCF    03.5
0629:  CALL   272
062A:  BTFSC  27.7
062B:  BSF    0B.7
....................  
....................          if(P < 0) 
062C:  BTFSS  7C.7
062D:  GOTO   638
....................          { 
....................             P  += dx; 
062E:  MOVF   73,W
062F:  ADDWF  7B,F
0630:  MOVF   74,W
0631:  BTFSC  03.0
0632:  INCFSZ 74,W
0633:  ADDWF  7C,F
....................             y1 += addy; 
0634:  MOVF   76,W
0635:  ADDWF  6D,W
0636:  MOVWF  6D
....................          } 
0637:  GOTO   644
....................          else 
....................          { 
....................             P  += diff; 
0638:  MOVF   7D,W
0639:  ADDWF  7B,F
063A:  MOVF   7E,W
063B:  BTFSC  03.0
063C:  INCFSZ 7E,W
063D:  ADDWF  7C,F
....................             x1 += addx; 
063E:  MOVF   75,W
063F:  ADDWF  6C,W
0640:  MOVWF  6C
....................             y1 += addy; 
0641:  MOVF   76,W
0642:  ADDWF  6D,W
0643:  MOVWF  6D
....................          } 
0644:  BSF    03.5
0645:  INCF   20,F
0646:  BCF    03.5
0647:  GOTO   612
0648:  BSF    03.5
....................       } 
....................    } 
0649:  BCF    03.5
064A:  RETURN
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
....................       { 
....................          xmin = x1; 
....................          xmax = x2; 
....................       } 
....................       else 
....................       { 
....................          xmin = x2; 
....................          xmax = x1; 
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
....................       { 
....................          ymin = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          ymin = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
....................          { 
....................             glcd_pixel(xmin, i, color); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
046B:  MOVF   69,W
046C:  MOVWF  7A
046D:  MOVF   68,W
046E:  MOVWF  04
046F:  BCF    03.7
0470:  BTFSC  7A.0
0471:  BSF    03.7
0472:  MOVF   00,F
0473:  BTFSC  03.2
0474:  GOTO   56E
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0475:  MOVF   69,W
0476:  MOVWF  7A
0477:  MOVF   68,W
0478:  MOVWF  04
0479:  BCF    03.7
047A:  BTFSC  7A.0
047B:  BSF    03.7
047C:  MOVF   00,W
047D:  SUBLW  52
047E:  BTFSS  03.0
047F:  GOTO   4A5
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0480:  MOVF   69,W
0481:  MOVWF  7A
0482:  MOVF   68,W
0483:  MOVWF  04
0484:  BCF    03.7
0485:  BTFSC  7A.0
0486:  BSF    03.7
0487:  MOVLW  20
0488:  SUBWF  00,W
0489:  BSF    03.5
048A:  MOVWF  21
048B:  MOVWF  22
048C:  MOVLW  05
048D:  MOVWF  23
048E:  BCF    03.5
048F:  CALL   325
0490:  MOVF   78,W
0491:  BSF    03.5
0492:  MOVWF  20
0493:  MOVWF  78
0494:  MOVLW  05
0495:  MOVWF  77
0496:  MOVLW  70
0497:  MOVWF  04
0498:  BCF    03.7
0499:  MOVF   78,W
049A:  BCF    03.5
049B:  CALL   02F
049C:  MOVWF  00
049D:  INCF   78,F
049E:  INCF   04,F
049F:  DECFSZ 77,F
04A0:  GOTO   4A2
04A1:  GOTO   4A4
04A2:  BSF    03.5
04A3:  GOTO   499
04A4:  GOTO   4DA
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
04A5:  MOVF   69,W
04A6:  MOVWF  7A
04A7:  MOVF   68,W
04A8:  MOVWF  04
04A9:  BCF    03.7
04AA:  BTFSC  7A.0
04AB:  BSF    03.7
04AC:  MOVF   00,W
04AD:  SUBLW  7E
04AE:  BTFSS  03.0
04AF:  GOTO   4D5
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
04B0:  MOVF   69,W
04B1:  MOVWF  7A
04B2:  MOVF   68,W
04B3:  MOVWF  04
04B4:  BCF    03.7
04B5:  BTFSC  7A.0
04B6:  BSF    03.7
04B7:  MOVLW  53
04B8:  SUBWF  00,W
04B9:  BSF    03.5
04BA:  MOVWF  21
04BB:  MOVWF  22
04BC:  MOVLW  05
04BD:  MOVWF  23
04BE:  BCF    03.5
04BF:  CALL   325
04C0:  MOVF   78,W
04C1:  BSF    03.5
04C2:  MOVWF  20
04C3:  MOVWF  78
04C4:  MOVLW  05
04C5:  MOVWF  77
04C6:  MOVLW  70
04C7:  MOVWF  04
04C8:  BCF    03.7
04C9:  MOVF   78,W
04CA:  BCF    03.5
04CB:  CALL   135
04CC:  MOVWF  00
04CD:  INCF   78,F
04CE:  INCF   04,F
04CF:  DECFSZ 77,F
04D0:  GOTO   4D2
04D1:  GOTO   4D4
04D2:  BSF    03.5
04D3:  GOTO   4C9
04D4:  GOTO   4DA
....................       else 
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
04D5:  CLRF   70
04D6:  CLRF   71
04D7:  CLRF   72
04D8:  CLRF   73
04D9:  CLRF   74
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
04DA:  MOVF   69,W
04DB:  MOVWF  7A
04DC:  MOVF   68,W
04DD:  MOVWF  04
04DE:  BCF    03.7
04DF:  BTFSC  7A.0
04E0:  BSF    03.7
04E1:  MOVF   00,W
04E2:  XORLW  0A
04E3:  BTFSC  03.2
04E4:  GOTO   4E9
04E5:  XORLW  07
04E6:  BTFSC  03.2
04E7:  GOTO   4F6
04E8:  GOTO   4F8
....................       { 
....................          case '\n': 
....................             y += 7*size + 1; 
04E9:  MOVLW  07
04EA:  BSF    03.5
04EB:  MOVWF  22
04EC:  BCF    03.5
04ED:  MOVF   6A,W
04EE:  BSF    03.5
04EF:  MOVWF  23
04F0:  BCF    03.5
04F1:  CALL   325
04F2:  MOVLW  01
04F3:  ADDWF  78,W
04F4:  ADDWF  67,F
....................             continue; 
04F5:  GOTO   569
....................          case '\r': 
....................             x = 0; 
04F6:  CLRF   66
....................             continue; 
04F7:  GOTO   569
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
04F8:  MOVLW  05
04F9:  BSF    03.5
04FA:  MOVWF  22
04FB:  BCF    03.5
04FC:  MOVF   6A,W
04FD:  BSF    03.5
04FE:  MOVWF  23
04FF:  BCF    03.5
0500:  CALL   325
0501:  MOVF   78,W
0502:  ADDWF  66,W
0503:  SUBLW  7F
0504:  BTFSC  03.0
0505:  GOTO   513
....................       { 
....................          x = 0;                           // Set x at far left position 
0506:  CLRF   66
....................          y += 7*size + 1;                 // Set y at next position down 
0507:  MOVLW  07
0508:  BSF    03.5
0509:  MOVWF  22
050A:  BCF    03.5
050B:  MOVF   6A,W
050C:  BSF    03.5
050D:  MOVWF  23
050E:  BCF    03.5
050F:  CALL   325
0510:  MOVLW  01
0511:  ADDWF  78,W
0512:  ADDWF  67,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0513:  CLRF   6C
0514:  MOVF   6C,W
0515:  SUBLW  04
0516:  BTFSS  03.0
0517:  GOTO   569
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
0518:  CLRF   6D
0519:  MOVF   6D,W
051A:  SUBLW  06
051B:  BTFSS  03.0
051C:  GOTO   565
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
051D:  MOVLW  70
051E:  ADDWF  6C,W
051F:  MOVWF  04
0520:  BCF    03.7
0521:  MOVF   00,W
0522:  BSF    03.5
0523:  MOVWF  20
0524:  MOVWF  77
0525:  BCF    03.5
0526:  MOVF   6D,W
0527:  MOVWF  78
0528:  BTFSC  03.2
0529:  GOTO   52E
052A:  BCF    03.0
052B:  RRF    77,F
052C:  DECFSZ 78,F
052D:  GOTO   52A
052E:  BTFSS  77.0
052F:  GOTO   563
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
0530:  CLRF   6E
0531:  MOVF   6A,W
0532:  SUBWF  6E,W
0533:  BTFSC  03.0
0534:  GOTO   563
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
0535:  CLRF   6F
0536:  MOVF   6A,W
0537:  SUBWF  6F,W
0538:  BTFSC  03.0
0539:  GOTO   561
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
053A:  MOVF   6F,W
053B:  ADDWF  66,W
053C:  BSF    03.5
053D:  MOVWF  20
053E:  BCF    03.5
053F:  MOVF   6D,W
0540:  BSF    03.5
0541:  MOVWF  22
0542:  BCF    03.5
0543:  MOVF   6A,W
0544:  BSF    03.5
0545:  MOVWF  23
0546:  BCF    03.5
0547:  CALL   325
0548:  MOVF   78,W
0549:  ADDWF  67,W
054A:  ADDWF  6E,W
054B:  BSF    03.5
054C:  MOVWF  21
054D:  BCF    03.5
054E:  CLRF   27
054F:  BTFSC  0B.7
0550:  BSF    27.7
0551:  BCF    0B.7
0552:  BSF    03.5
0553:  MOVF   20,W
0554:  MOVWF  36
0555:  MOVF   21,W
0556:  MOVWF  37
0557:  BCF    03.5
0558:  MOVF   6B,W
0559:  BSF    03.5
055A:  MOVWF  38
055B:  BCF    03.5
055C:  CALL   272
055D:  BTFSC  27.7
055E:  BSF    0B.7
055F:  INCF   6F,F
0560:  GOTO   536
....................                   } 
0561:  INCF   6E,F
0562:  GOTO   531
....................                } 
....................             } 
0563:  INCF   6D,F
0564:  GOTO   519
....................          } 
0565:  INCF   6C,F
0566:  MOVF   6A,W
0567:  ADDWF  66,F
0568:  GOTO   514
....................       } 
0569:  INCF   68,F
056A:  BTFSC  03.2
056B:  INCF   69,F
056C:  INCF   66,F
056D:  GOTO   46B
....................    } 
056E:  RETURN
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #byte trisb=0x86 
....................  
.................... ///Defines 
....................  
.................... #define escala -0.20 //Escala negativa para que crezca hacia arriba. 
.................... #define limpiarGrafico limpiarPorcion(0,20,128,44) //Limpia el area del grafico 
....................  
.................... ///Fin Defines 
....................  
.................... ///Variables Globales 
....................  
.................... int x=0; //Posicion inicial de x para graficar la temperatura 
.................... signed int16 y=0; //Posicion inicial de y (Vamos a tener que cambiarla a la primer temperatura leida) para graficar la temperatura 
.................... int offset=52; //es el offset para la altura de la grafica 
....................  
.................... ///Fin Variables Globales 
....................  
.................... ///Funciones 
....................  
.................... void mostrarBT(int1 estado){ //Mostramos BT si el bluetooth esta prendido 
....................    char bt[]="BT"; 
*
07BC:  MOVLW  42
07BD:  MOVWF  63
07BE:  MOVLW  54
07BF:  MOVWF  64
07C0:  CLRF   65
....................    glcd_text57(110,0,bt,1,estado); 
07C1:  MOVLW  6E
07C2:  MOVWF  66
07C3:  CLRF   67
07C4:  CLRF   69
07C5:  MOVLW  63
07C6:  MOVWF  68
07C7:  MOVLW  01
07C8:  MOVWF  6A
07C9:  MOVF   62,W
07CA:  MOVWF  6B
07CB:  CALL   46B
07CC:  RETURN
.................... } 
....................  
.................... void limpiarPorcion(int x1, int y1, int x2, int y2){ //(x1, y1) = posición del primer pixel. (x2, y2) = cantididad de pixeles hacia la derecha y hacia abajo 
....................    for(int i=x1;i<x1+x2;i++){ 
*
02F4:  BSF    03.5
02F5:  MOVF   30,W
02F6:  MOVWF  34
02F7:  MOVF   32,W
02F8:  ADDWF  30,W
02F9:  SUBWF  34,W
02FA:  BTFSC  03.0
02FB:  GOTO   30F
....................       for(int j=y1;j<y1+y2;j++){ 
02FC:  MOVF   31,W
02FD:  MOVWF  35
02FE:  MOVF   33,W
02FF:  ADDWF  31,W
0300:  SUBWF  35,W
0301:  BTFSC  03.0
0302:  GOTO   30D
....................          glcd_pixel(i, j, OFF); //Apagamos el pixel. 
0303:  MOVF   34,W
0304:  MOVWF  36
0305:  MOVF   35,W
0306:  MOVWF  37
0307:  CLRF   38
0308:  BCF    03.5
0309:  CALL   272
030A:  BSF    03.5
030B:  INCF   35,F
030C:  GOTO   2FE
....................       } 
030D:  INCF   34,F
030E:  GOTO   2F7
....................    } 
030F:  BCF    03.5
0310:  RETURN
.................... } 
....................  
.................... void nuevaLinea(float temp){ //Funcion para graficar las nuevas lineas de temperatura 
*
0A20:  MOVLW  02
0A21:  ADDWF  2B,W
0A22:  MOVWF  69
....................    int x1=x+2; 
....................    if(x1>128){ //Revisamos si sobrepasamos el tamaño de la pantalla 
0A23:  MOVF   69,W
0A24:  SUBLW  80
0A25:  BTFSC  03.0
0A26:  GOTO   23C
0A27:  CLRF   27
0A28:  BTFSC  0B.7
0A29:  BSF    27.7
0A2A:  BCF    0B.7
.................... 		limpiarGrafico; //Limpiamos el area del grafico 
0A2B:  BSF    03.5
0A2C:  CLRF   30
0A2D:  MOVLW  14
0A2E:  MOVWF  31
0A2F:  MOVLW  80
0A30:  MOVWF  32
0A31:  MOVLW  2C
0A32:  MOVWF  33
0A33:  BCF    0A.3
0A34:  BCF    03.5
0A35:  CALL   2F4
0A36:  BSF    0A.3
0A37:  BTFSC  27.7
0A38:  BSF    0B.7
....................       x=0; 
0A39:  CLRF   2B
....................       x1=2; 
0A3A:  MOVLW  02
0A3B:  MOVWF  69
....................    } 
....................    glcd_line(x, (y*escala)+offset, x1, (temp*escala)+offset, ON); //multiplicamos por la escala para que la grafica entre en el area del grafico. El offset esta explicado arriba 
0A3C:  MOVF   2D,W
0A3D:  MOVWF  6B
0A3E:  MOVF   2C,W
0A3F:  MOVWF  6A
*
0A64:  MOVF   7A,W
0A65:  MOVWF  75
0A66:  MOVF   79,W
0A67:  MOVWF  74
0A68:  MOVF   78,W
0A69:  MOVWF  73
0A6A:  MOVF   77,W
0A6B:  MOVWF  72
0A6C:  MOVLW  CD
0A6D:  MOVWF  7E
0A6E:  MOVLW  CC
0A6F:  MOVWF  7D
0A70:  MOVWF  7C
0A71:  MOVLW  7C
0A72:  MOVWF  7B
0A73:  BCF    0A.3
0A74:  CALL   64B
0A75:  BSF    0A.3
0A76:  MOVF   7A,W
0A77:  MOVWF  6D
0A78:  MOVF   79,W
0A79:  MOVWF  6C
0A7A:  MOVF   78,W
0A7B:  MOVWF  6B
0A7C:  MOVF   77,W
0A7D:  MOVWF  6A
0A7E:  CLRF   70
0A7F:  MOVF   2E,W
0A80:  MOVWF  6F
0A81:  BCF    0A.3
0A82:  CALL   76C
0A83:  BSF    0A.3
0A84:  BCF    03.1
0A85:  MOVF   6D,W
0A86:  MOVWF  72
0A87:  MOVF   6C,W
0A88:  MOVWF  71
0A89:  MOVF   6B,W
0A8A:  MOVWF  70
0A8B:  MOVF   6A,W
0A8C:  MOVWF  6F
0A8D:  MOVF   7A,W
0A8E:  MOVWF  76
0A8F:  MOVF   79,W
0A90:  MOVWF  75
0A91:  MOVF   78,W
0A92:  MOVWF  74
0A93:  MOVF   77,W
0A94:  MOVWF  73
0A95:  CALL   0D5
0A96:  MOVF   7A,W
0A97:  MOVWF  6E
0A98:  MOVF   79,W
0A99:  MOVWF  6D
0A9A:  MOVF   78,W
0A9B:  MOVWF  6C
0A9C:  MOVF   77,W
0A9D:  MOVWF  6B
0A9E:  BCF    0A.3
0A9F:  CALL   789
0AA0:  BSF    0A.3
0AA1:  MOVF   78,W
0AA2:  MOVWF  6A
0AA3:  MOVF   68,W
0AA4:  MOVWF  75
0AA5:  MOVF   67,W
0AA6:  MOVWF  74
0AA7:  MOVF   66,W
0AA8:  MOVWF  73
0AA9:  MOVF   65,W
0AAA:  MOVWF  72
0AAB:  MOVLW  CD
0AAC:  MOVWF  7E
0AAD:  MOVLW  CC
0AAE:  MOVWF  7D
0AAF:  MOVWF  7C
0AB0:  MOVLW  7C
0AB1:  MOVWF  7B
0AB2:  BCF    0A.3
0AB3:  CALL   64B
0AB4:  BSF    0A.3
0AB5:  MOVF   7A,W
0AB6:  MOVWF  6E
0AB7:  MOVF   79,W
0AB8:  MOVWF  6D
0AB9:  MOVF   78,W
0ABA:  MOVWF  6C
0ABB:  MOVF   77,W
0ABC:  MOVWF  6B
0ABD:  CLRF   70
0ABE:  MOVF   2E,W
0ABF:  MOVWF  6F
0AC0:  BCF    0A.3
0AC1:  CALL   76C
0AC2:  BSF    0A.3
0AC3:  BCF    03.1
0AC4:  MOVF   6E,W
0AC5:  MOVWF  72
0AC6:  MOVF   6D,W
0AC7:  MOVWF  71
0AC8:  MOVF   6C,W
0AC9:  MOVWF  70
0ACA:  MOVF   6B,W
0ACB:  MOVWF  6F
0ACC:  MOVF   7A,W
0ACD:  MOVWF  76
0ACE:  MOVF   79,W
0ACF:  MOVWF  75
0AD0:  MOVF   78,W
0AD1:  MOVWF  74
0AD2:  MOVF   77,W
0AD3:  MOVWF  73
0AD4:  CALL   0D5
0AD5:  MOVF   7A,W
0AD6:  MOVWF  6E
0AD7:  MOVF   79,W
0AD8:  MOVWF  6D
0AD9:  MOVF   78,W
0ADA:  MOVWF  6C
0ADB:  MOVF   77,W
0ADC:  MOVWF  6B
0ADD:  BCF    0A.3
0ADE:  CALL   789
0ADF:  BSF    0A.3
0AE0:  MOVF   78,W
0AE1:  MOVWF  6B
0AE2:  MOVF   2B,W
0AE3:  MOVWF  6C
0AE4:  MOVF   6A,W
0AE5:  MOVWF  6D
0AE6:  MOVF   69,W
0AE7:  MOVWF  6E
0AE8:  MOVF   6B,W
0AE9:  MOVWF  6F
0AEA:  MOVLW  01
0AEB:  MOVWF  70
0AEC:  BCF    0A.3
0AED:  CALL   56F
0AEE:  BSF    0A.3
....................    y=temp; 
0AEF:  MOVF   68,W
0AF0:  MOVWF  6E
0AF1:  MOVF   67,W
0AF2:  MOVWF  6D
0AF3:  MOVF   66,W
0AF4:  MOVWF  6C
0AF5:  MOVF   65,W
0AF6:  MOVWF  6B
0AF7:  BCF    0A.3
0AF8:  CALL   789
0AF9:  BSF    0A.3
0AFA:  MOVF   79,W
0AFB:  MOVWF  2D
0AFC:  MOVF   78,W
0AFD:  MOVWF  2C
....................    x=x1; 
0AFE:  MOVF   69,W
0AFF:  MOVWF  2B
0B00:  BSF    0A.3
0B01:  BCF    0A.4
0B02:  GOTO   4EA (RETURN)
.................... } 
....................  
.................... void turn_on_bt() { 
....................    char value; 
....................    value = getc(); //Obtenemos el dato 
*
0D1B:  BTFSS  0C.5
0D1C:  GOTO   51B
0D1D:  MOVF   1A,W
0D1E:  MOVWF  61
....................    if(value == 'a') { //Si el valor es a 
0D1F:  MOVF   61,W
0D20:  SUBLW  61
0D21:  BTFSS  03.2
0D22:  GOTO   532
....................       //output_high(LED1);   // LED ON 
....................       mostrarBT(ON); //Mostramos BT 
0D23:  MOVLW  01
0D24:  MOVWF  62
0D25:  BCF    0A.3
0D26:  CALL   7BC
0D27:  BSF    0A.3
....................       delay_ms(500); //Delay 500 ms 
0D28:  MOVLW  02
0D29:  MOVWF  62
0D2A:  MOVLW  FA
0D2B:  MOVWF  63
0D2C:  BCF    0A.3
0D2D:  CALL   7A8
0D2E:  BSF    0A.3
0D2F:  DECFSZ 62,F
0D30:  GOTO   52A
....................    } else if(value == 'b') { //Si el valor es b 
0D31:  GOTO   543
0D32:  MOVF   61,W
0D33:  SUBLW  62
0D34:  BTFSS  03.2
0D35:  GOTO   543
....................       //output_low(LED1);    // LED OFF 
....................       mostrarBT(OFF); //No mostramos BT 
0D36:  CLRF   62
0D37:  BCF    0A.3
0D38:  CALL   7BC
0D39:  BSF    0A.3
....................       delay_ms(500); //Delay 500 ms 
0D3A:  MOVLW  02
0D3B:  MOVWF  62
0D3C:  MOVLW  FA
0D3D:  MOVWF  63
0D3E:  BCF    0A.3
0D3F:  CALL   7A8
0D40:  BSF    0A.3
0D41:  DECFSZ 62,F
0D42:  GOTO   53C
....................    }  
.................... } 
....................  
.................... ///Fin Funciones 
....................  
.................... ///Interrupciones 
....................  
.................... #INT_RB 
.................... void RB_isr(){ //Prueba de interrupciones 
.................... 	if(input(pin_b6)){ 
*
0311:  BSF    03.5
0312:  BSF    06.6
0313:  BCF    03.5
0314:  BTFSS  06.6
0315:  GOTO   321
.................... 		limpiarGrafico; 
0316:  BSF    03.5
0317:  CLRF   30
0318:  MOVLW  14
0319:  MOVWF  31
031A:  MOVLW  80
031B:  MOVWF  32
031C:  MOVLW  2C
031D:  MOVWF  33
031E:  BCF    03.5
031F:  CALL   2F4
.................... 		x=0; 
0320:  CLRF   2B
.................... 	} 
0321:  BCF    0B.0
0322:  BCF    0A.3
0323:  BCF    0A.4
0324:  GOTO   01B
.................... } 
....................  
.................... ///Fin Interrupciones 
....................  
.................... void main() 
*
0BD4:  MOVF   03,W
0BD5:  ANDLW  1F
0BD6:  MOVWF  03
0BD7:  MOVLW  0C
0BD8:  BSF    03.5
0BD9:  MOVWF  19
0BDA:  MOVLW  A2
0BDB:  MOVWF  18
0BDC:  MOVLW  90
0BDD:  BCF    03.5
0BDE:  MOVWF  18
0BDF:  MOVLW  FF
0BE0:  MOVWF  2A
0BE1:  CLRF   2B
0BE2:  CLRF   2D
0BE3:  CLRF   2C
0BE4:  MOVLW  34
0BE5:  MOVWF  2E
0BE6:  CLRF   30
0BE7:  CLRF   2F
0BE8:  BSF    03.5
0BE9:  BSF    1F.0
0BEA:  BSF    1F.1
0BEB:  BSF    1F.2
0BEC:  BCF    1F.3
0BED:  BCF    03.7
.................... { 
....................    char str[10]; 
....................    char temp[]="Temperatura:"; 
*
0BF1:  MOVLW  54
0BF2:  MOVWF  3B
0BF3:  MOVLW  65
0BF4:  MOVWF  3C
0BF5:  MOVLW  6D
0BF6:  MOVWF  3D
0BF7:  MOVLW  70
0BF8:  MOVWF  3E
0BF9:  MOVLW  65
0BFA:  MOVWF  3F
0BFB:  MOVLW  72
0BFC:  MOVWF  40
0BFD:  MOVLW  61
0BFE:  MOVWF  41
0BFF:  MOVLW  74
0C00:  MOVWF  42
0C01:  MOVLW  75
0C02:  MOVWF  43
0C03:  MOVLW  72
0C04:  MOVWF  44
0C05:  MOVLW  61
0C06:  MOVWF  45
0C07:  MOVLW  3A
0C08:  MOVWF  46
0C09:  CLRF   47
....................    float t[]={37, 36.5, 38, -55, 150, 30}; //ESTO HAY QUE FLETARLO CUANDO YA ESTÉ LA CAPTURA REAL 
0C0A:  MOVLW  84
0C0B:  MOVWF  48
0C0C:  MOVLW  14
0C0D:  MOVWF  49
0C0E:  CLRF   4A
0C0F:  CLRF   4B
0C10:  MOVLW  84
0C11:  MOVWF  4C
0C12:  MOVLW  12
0C13:  MOVWF  4D
0C14:  CLRF   4E
0C15:  CLRF   4F
0C16:  MOVLW  84
0C17:  MOVWF  50
0C18:  MOVLW  18
0C19:  MOVWF  51
0C1A:  CLRF   52
0C1B:  CLRF   53
0C1C:  MOVLW  84
0C1D:  MOVWF  54
0C1E:  MOVLW  DC
0C1F:  MOVWF  55
0C20:  CLRF   56
0C21:  CLRF   57
0C22:  MOVLW  86
0C23:  MOVWF  58
0C24:  MOVLW  16
0C25:  MOVWF  59
0C26:  CLRF   5A
0C27:  CLRF   5B
0C28:  MOVLW  83
0C29:  MOVWF  5C
0C2A:  MOVLW  70
0C2B:  MOVWF  5D
0C2C:  CLRF   5E
0C2D:  CLRF   5F
....................     
....................    glcd_init(on); //Inicializamos el lcd 
0C2E:  MOVLW  01
0C2F:  MOVWF  61
0C30:  BCF    0A.3
0C31:  GOTO   34C
0C32:  BSF    0A.3
.................... 	enable_interrupts(INT_RB); //Habilitamos las interrupciones del RB4-7 
0C33:  BSF    0B.3
.................... 	enable_interrupts(GLOBAL); //Habilitamos las interrupciones globales 
0C34:  MOVLW  C0
0C35:  IORWF  0B,F
....................  
....................    glcd_text57(0,10,temp,1,ON); //Escribimos el texto "Tempreatura:" en la posicion 0,10 
0C36:  CLRF   66
0C37:  MOVLW  0A
0C38:  MOVWF  67
0C39:  CLRF   69
0C3A:  MOVLW  3B
0C3B:  MOVWF  68
0C3C:  MOVLW  01
0C3D:  MOVWF  6A
0C3E:  MOVWF  6B
0C3F:  BCF    0A.3
0C40:  CALL   46B
0C41:  BSF    0A.3
....................    glcd_line(0, 8, 128, 8, ON); //Pintamos una linea por debajo del barra de notificaciones 
0C42:  CLRF   6C
0C43:  MOVLW  08
0C44:  MOVWF  6D
0C45:  MOVLW  80
0C46:  MOVWF  6E
0C47:  MOVLW  08
0C48:  MOVWF  6F
0C49:  MOVLW  01
0C4A:  MOVWF  70
0C4B:  BCF    0A.3
0C4C:  CALL   56F
0C4D:  BSF    0A.3
....................    glcd_line(0, 19, 128, 19, ON); //Pintamos una linea por debajo de la temperatura 
0C4E:  CLRF   6C
0C4F:  MOVLW  13
0C50:  MOVWF  6D
0C51:  MOVLW  80
0C52:  MOVWF  6E
0C53:  MOVLW  13
0C54:  MOVWF  6F
0C55:  MOVLW  01
0C56:  MOVWF  70
0C57:  BCF    0A.3
0C58:  CALL   56F
0C59:  BSF    0A.3
....................       
....................    for(int i=0; i<10; i++){ //ESTO HAY QUE FLETARLO CUANDO YA ESTÉ LA CAPTURA REAL || LO QUE ESTA ACA DESPUES VA AL WHILE(TRUE) 
0C5A:  CLRF   60
0C5B:  MOVF   60,W
0C5C:  SUBLW  09
0C5D:  BTFSS  03.0
0C5E:  GOTO   516
....................       sprintf(str, "%4.2f°C", t[i]); //Convertimos la temperatura float en un char* 
0C5F:  RLF    60,W
0C60:  MOVWF  77
0C61:  RLF    77,F
0C62:  MOVLW  FC
0C63:  ANDWF  77,F
0C64:  MOVF   77,W
0C65:  ADDLW  48
0C66:  MOVWF  04
0C67:  BCF    03.7
0C68:  MOVF   00,W
0C69:  MOVWF  61
0C6A:  INCF   04,F
0C6B:  MOVF   00,W
0C6C:  MOVWF  62
0C6D:  INCF   04,F
0C6E:  MOVF   00,W
0C6F:  MOVWF  63
0C70:  INCF   04,F
0C71:  MOVF   00,W
0C72:  MOVWF  64
0C73:  CLRF   30
0C74:  MOVLW  31
0C75:  MOVWF  2F
0C76:  MOVLW  03
0C77:  MOVWF  04
0C78:  MOVF   64,W
0C79:  MOVWF  68
0C7A:  MOVF   63,W
0C7B:  MOVWF  67
0C7C:  MOVF   62,W
0C7D:  MOVWF  66
0C7E:  MOVF   61,W
0C7F:  MOVWF  65
0C80:  MOVLW  02
0C81:  MOVWF  69
0C82:  GOTO   000
0C83:  MOVLW  B0
0C84:  MOVWF  72
0C85:  BCF    0A.3
0C86:  CALL   741
0C87:  BSF    0A.3
0C88:  MOVLW  43
0C89:  MOVWF  72
0C8A:  BCF    0A.3
0C8B:  CALL   741
0C8C:  BSF    0A.3
....................       limpiarPorcion(strlen(temp)*6, 10, 9*6, 7); //Limpiamos la porcion de pantalla que tiene el valor de la temperatura. 
0C8D:  CLRF   62
0C8E:  MOVLW  3B
0C8F:  MOVWF  61
0C90:  BCF    0A.3
0C91:  CALL   74E
0C92:  BSF    0A.3
0C93:  MOVF   78,W
0C94:  BSF    03.5
0C95:  MOVWF  22
0C96:  MOVLW  06
0C97:  MOVWF  23
0C98:  BCF    0A.3
0C99:  BCF    03.5
0C9A:  CALL   325
0C9B:  BSF    0A.3
0C9C:  MOVF   78,W
0C9D:  MOVWF  61
0C9E:  CLRF   27
0C9F:  BTFSC  0B.7
0CA0:  BSF    27.7
0CA1:  BCF    0B.7
0CA2:  MOVF   61,W
0CA3:  BSF    03.5
0CA4:  MOVWF  30
0CA5:  MOVLW  0A
0CA6:  MOVWF  31
0CA7:  MOVLW  36
0CA8:  MOVWF  32
0CA9:  MOVLW  07
0CAA:  MOVWF  33
0CAB:  BCF    0A.3
0CAC:  BCF    03.5
0CAD:  CALL   2F4
0CAE:  BSF    0A.3
0CAF:  BTFSC  27.7
0CB0:  BSF    0B.7
....................       glcd_text57(strlen(temp)*6, 10, str, 1, ON); //Escribimos la temperatura. 
0CB1:  CLRF   62
0CB2:  MOVLW  3B
0CB3:  MOVWF  61
0CB4:  BCF    0A.3
0CB5:  CALL   74E
0CB6:  BSF    0A.3
0CB7:  MOVF   78,W
0CB8:  BSF    03.5
0CB9:  MOVWF  22
0CBA:  MOVLW  06
0CBB:  MOVWF  23
0CBC:  BCF    0A.3
0CBD:  BCF    03.5
0CBE:  CALL   325
0CBF:  BSF    0A.3
0CC0:  MOVF   78,W
0CC1:  MOVWF  61
0CC2:  MOVWF  66
0CC3:  MOVLW  0A
0CC4:  MOVWF  67
0CC5:  CLRF   69
0CC6:  MOVLW  31
0CC7:  MOVWF  68
0CC8:  MOVLW  01
0CC9:  MOVWF  6A
0CCA:  MOVWF  6B
0CCB:  BCF    0A.3
0CCC:  CALL   46B
0CCD:  BSF    0A.3
....................       nuevaLinea(t[i]); //Dibujamos la nueva linea en el grafico. 
0CCE:  RLF    60,W
0CCF:  MOVWF  77
0CD0:  RLF    77,F
0CD1:  MOVLW  FC
0CD2:  ANDWF  77,F
0CD3:  MOVF   77,W
0CD4:  ADDLW  48
0CD5:  MOVWF  04
0CD6:  BCF    03.7
0CD7:  MOVF   00,W
0CD8:  MOVWF  61
0CD9:  INCF   04,F
0CDA:  MOVF   00,W
0CDB:  MOVWF  62
0CDC:  INCF   04,F
0CDD:  MOVF   00,W
0CDE:  MOVWF  63
0CDF:  INCF   04,F
0CE0:  MOVF   00,W
0CE1:  MOVWF  64
0CE2:  MOVWF  68
0CE3:  MOVF   63,W
0CE4:  MOVWF  67
0CE5:  MOVF   62,W
0CE6:  MOVWF  66
0CE7:  MOVF   61,W
0CE8:  MOVWF  65
0CE9:  GOTO   220
....................       printf("%f\r", t[i]); 
0CEA:  RLF    60,W
0CEB:  MOVWF  77
0CEC:  RLF    77,F
0CED:  MOVLW  FC
0CEE:  ANDWF  77,F
0CEF:  MOVF   77,W
0CF0:  ADDLW  48
0CF1:  MOVWF  04
0CF2:  BCF    03.7
0CF3:  MOVF   00,W
0CF4:  MOVWF  61
0CF5:  INCF   04,F
0CF6:  MOVF   00,W
0CF7:  MOVWF  62
0CF8:  INCF   04,F
0CF9:  MOVF   00,W
0CFA:  MOVWF  63
0CFB:  INCF   04,F
0CFC:  MOVF   00,W
0CFD:  MOVWF  64
0CFE:  MOVLW  89
0CFF:  MOVWF  04
0D00:  MOVF   64,W
0D01:  MOVWF  68
0D02:  MOVF   63,W
0D03:  MOVWF  67
0D04:  MOVF   62,W
0D05:  MOVWF  66
0D06:  MOVF   61,W
0D07:  MOVWF  65
0D08:  MOVLW  02
0D09:  MOVWF  69
0D0A:  GOTO   303
0D0B:  MOVLW  0D
0D0C:  BTFSS  0C.4
0D0D:  GOTO   50C
0D0E:  MOVWF  19
....................       //puts(str); 
....................       delay_ms(200); 
0D0F:  MOVLW  C8
0D10:  MOVWF  63
0D11:  BCF    0A.3
0D12:  CALL   7A8
0D13:  BSF    0A.3
0D14:  INCF   60,F
0D15:  GOTO   45B
....................    } 
....................       
....................    while(TRUE){ 
....................       trisb|=0b01000000; 
0D16:  BSF    03.5
0D17:  BSF    06.6
....................       if(kbhit()) { // if data received  
0D18:  BCF    03.5
0D19:  BTFSS  0C.5
0D1A:  GOTO   543
....................          turn_on_bt(); 
....................       } 
*
0D43:  GOTO   516
....................    } 
.................... } 
0D44:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
