CCS PCM C Compiler, Version 5.076, 56587               28-Oct-20 20:21

               Filename:   D:\Ezequiel\My eBooks\Favaloro\ED\II\GIT_TP_FINAL\tp_final_edi2\Codigo\main.lst

               ROM used:   2222 words (27%)
                           Largest free fragment is 2048
               RAM used:   66 (18%) at main() level
                           93 (25%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <main.h> 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  00
0061:  RETLW  04
0062:  RETLW  02
0063:  RETLW  7F
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
0215:  CLRF   77
0216:  CLRF   78
0217:  MOVF   6F,W
0218:  BCF    03.0
0219:  BTFSC  70.0
021A:  ADDWF  77,F
021B:  RRF    77,F
021C:  RRF    78,F
021D:  BTFSC  70.1
021E:  ADDWF  77,F
021F:  RRF    77,F
0220:  RRF    78,F
0221:  BTFSC  70.2
0222:  ADDWF  77,F
0223:  RRF    77,F
0224:  RRF    78,F
0225:  BTFSC  70.3
0226:  ADDWF  77,F
0227:  RRF    77,F
0228:  RRF    78,F
0229:  BTFSC  70.4
022A:  ADDWF  77,F
022B:  RRF    77,F
022C:  RRF    78,F
022D:  BTFSC  70.5
022E:  ADDWF  77,F
022F:  RRF    77,F
0230:  RRF    78,F
0231:  BTFSC  70.6
0232:  ADDWF  77,F
0233:  RRF    77,F
0234:  RRF    78,F
0235:  BTFSC  70.7
0236:  ADDWF  77,F
0237:  RRF    77,F
0238:  RRF    78,F
0239:  RETURN
*
04F8:  MOVF   6A,W
04F9:  BTFSC  03.2
04FA:  GOTO   568
04FB:  MOVWF  72
04FC:  MOVF   6E,W
04FD:  BTFSC  03.2
04FE:  GOTO   568
04FF:  ADDWF  72,F
0500:  BTFSC  03.0
0501:  GOTO   509
0502:  MOVLW  7F
0503:  SUBWF  72,F
0504:  BTFSS  03.0
0505:  GOTO   568
0506:  BTFSC  03.2
0507:  GOTO   568
0508:  GOTO   50D
0509:  MOVLW  81
050A:  ADDWF  72,F
050B:  BTFSC  03.0
050C:  GOTO   568
050D:  MOVF   72,W
050E:  MOVWF  77
050F:  CLRF   78
0510:  CLRF   79
0511:  CLRF   7A
0512:  MOVF   6B,W
0513:  MOVWF  76
0514:  BSF    76.7
0515:  MOVF   6C,W
0516:  MOVWF  75
0517:  MOVF   6D,W
0518:  MOVWF  74
0519:  MOVLW  18
051A:  MOVWF  72
051B:  CLRF   73
051C:  BTFSS  74.0
051D:  GOTO   536
051E:  MOVF   71,W
051F:  ADDWF  7A,F
0520:  BTFSS  03.0
0521:  GOTO   528
0522:  INCF   79,F
0523:  BTFSS  03.2
0524:  GOTO   528
0525:  INCF   78,F
0526:  BTFSC  03.2
0527:  BSF    73.7
0528:  MOVF   70,W
0529:  ADDWF  79,F
052A:  BTFSS  03.0
052B:  GOTO   52F
052C:  INCF   78,F
052D:  BTFSC  03.2
052E:  BSF    73.7
052F:  MOVF   6F,W
0530:  MOVWF  6C
0531:  BSF    6C.7
0532:  MOVF   6C,W
0533:  ADDWF  78,F
0534:  BTFSC  03.0
0535:  BSF    73.7
0536:  RLF    73,F
0537:  RRF    78,F
0538:  RRF    79,F
0539:  RRF    7A,F
053A:  RRF    76,F
053B:  RRF    75,F
053C:  RRF    74,F
053D:  BCF    03.0
053E:  DECFSZ 72,F
053F:  GOTO   51B
0540:  MOVLW  01
0541:  ADDWF  77,F
0542:  BTFSC  03.0
0543:  GOTO   568
0544:  BTFSC  78.7
0545:  GOTO   54D
0546:  RLF    76,F
0547:  RLF    7A,F
0548:  RLF    79,F
0549:  RLF    78,F
054A:  DECF   77,F
054B:  BTFSC  03.2
054C:  GOTO   568
054D:  BTFSS  76.7
054E:  GOTO   55E
054F:  INCF   7A,F
0550:  BTFSS  03.2
0551:  GOTO   55E
0552:  INCF   79,F
0553:  BTFSS  03.2
0554:  GOTO   55E
0555:  INCF   78,F
0556:  BTFSS  03.2
0557:  GOTO   55E
0558:  RRF    78,F
0559:  RRF    79,F
055A:  RRF    7A,F
055B:  INCF   77,F
055C:  BTFSC  03.2
055D:  GOTO   568
055E:  MOVF   6B,W
055F:  MOVWF  73
0560:  MOVF   6F,W
0561:  XORWF  73,F
0562:  BTFSS  73.7
0563:  GOTO   566
0564:  BSF    78.7
0565:  GOTO   56C
0566:  BCF    78.7
0567:  GOTO   56C
0568:  CLRF   77
0569:  CLRF   78
056A:  CLRF   79
056B:  CLRF   7A
056C:  RETURN
056D:  MOVF   6A,W
056E:  SUBLW  B6
056F:  MOVWF  6A
0570:  CLRF   7A
0571:  MOVF   6B,W
0572:  MOVWF  6E
0573:  BSF    6B.7
0574:  BCF    03.0
0575:  RRF    6B,F
0576:  RRF    6C,F
0577:  RRF    6D,F
0578:  RRF    7A,F
0579:  RRF    79,F
057A:  RRF    78,F
057B:  RRF    77,F
057C:  DECFSZ 6A,F
057D:  GOTO   574
057E:  BTFSS  6E.7
057F:  GOTO   58B
0580:  COMF   77,F
0581:  COMF   78,F
0582:  COMF   79,F
0583:  COMF   7A,F
0584:  INCF   77,F
0585:  BTFSC  03.2
0586:  INCF   78,F
0587:  BTFSC  03.2
0588:  INCF   79,F
0589:  BTFSC  03.2
058A:  INCF   7A,F
058B:  RETURN
058C:  BTFSC  03.1
058D:  GOTO   591
058E:  MOVLW  72
058F:  MOVWF  04
0590:  BCF    03.7
0591:  CLRF   77
0592:  CLRF   78
0593:  CLRF   79
0594:  CLRF   7A
0595:  CLRF   72
0596:  CLRF   73
0597:  CLRF   74
0598:  CLRF   75
0599:  MOVF   71,W
059A:  IORWF  70,W
059B:  IORWF  6F,W
059C:  IORWF  6E,W
059D:  BTFSC  03.2
059E:  GOTO   5CF
059F:  MOVLW  20
05A0:  MOVWF  76
05A1:  BCF    03.0
05A2:  RLF    6A,F
05A3:  RLF    6B,F
05A4:  RLF    6C,F
05A5:  RLF    6D,F
05A6:  RLF    72,F
05A7:  RLF    73,F
05A8:  RLF    74,F
05A9:  RLF    75,F
05AA:  MOVF   71,W
05AB:  SUBWF  75,W
05AC:  BTFSS  03.2
05AD:  GOTO   5B8
05AE:  MOVF   70,W
05AF:  SUBWF  74,W
05B0:  BTFSS  03.2
05B1:  GOTO   5B8
05B2:  MOVF   6F,W
05B3:  SUBWF  73,W
05B4:  BTFSS  03.2
05B5:  GOTO   5B8
05B6:  MOVF   6E,W
05B7:  SUBWF  72,W
05B8:  BTFSS  03.0
05B9:  GOTO   5C9
05BA:  MOVF   6E,W
05BB:  SUBWF  72,F
05BC:  MOVF   6F,W
05BD:  BTFSS  03.0
05BE:  INCFSZ 6F,W
05BF:  SUBWF  73,F
05C0:  MOVF   70,W
05C1:  BTFSS  03.0
05C2:  INCFSZ 70,W
05C3:  SUBWF  74,F
05C4:  MOVF   71,W
05C5:  BTFSS  03.0
05C6:  INCFSZ 71,W
05C7:  SUBWF  75,F
05C8:  BSF    03.0
05C9:  RLF    77,F
05CA:  RLF    78,F
05CB:  RLF    79,F
05CC:  RLF    7A,F
05CD:  DECFSZ 76,F
05CE:  GOTO   5A1
05CF:  MOVF   72,W
05D0:  MOVWF  00
05D1:  INCF   04,F
05D2:  MOVF   73,W
05D3:  MOVWF  00
05D4:  INCF   04,F
05D5:  MOVF   74,W
05D6:  MOVWF  00
05D7:  INCF   04,F
05D8:  MOVF   75,W
05D9:  MOVWF  00
05DA:  RETURN
05DB:  MOVF   27,W
05DC:  MOVWF  04
05DD:  BCF    03.7
05DE:  BTFSC  28.0
05DF:  BSF    03.7
05E0:  MOVF   6A,W
05E1:  MOVWF  00
05E2:  INCF   04,F
05E3:  CLRF   00
05E4:  INCF   27,F
05E5:  BTFSC  03.2
05E6:  INCF   28,F
05E7:  RETURN
05E8:  MOVF   04,W
05E9:  MOVWF  62
05EA:  MOVF   61,W
05EB:  MOVWF  64
05EC:  BTFSC  03.2
05ED:  GOTO   607
05EE:  MOVF   60,W
05EF:  MOVWF  6D
05F0:  MOVF   5F,W
05F1:  MOVWF  6C
05F2:  MOVF   5E,W
05F3:  MOVWF  6B
05F4:  MOVF   5D,W
05F5:  MOVWF  6A
05F6:  CLRF   71
05F7:  CLRF   70
05F8:  MOVLW  20
05F9:  MOVWF  6F
05FA:  MOVLW  82
05FB:  MOVWF  6E
05FC:  CALL   4F8
05FD:  MOVF   7A,W
05FE:  MOVWF  60
05FF:  MOVF   79,W
0600:  MOVWF  5F
0601:  MOVF   78,W
0602:  MOVWF  5E
0603:  MOVF   77,W
0604:  MOVWF  5D
0605:  DECFSZ 64,F
0606:  GOTO   5EE
0607:  MOVF   60,W
0608:  MOVWF  6D
0609:  MOVF   5F,W
060A:  MOVWF  6C
060B:  MOVF   5E,W
060C:  MOVWF  6B
060D:  MOVF   5D,W
060E:  MOVWF  6A
060F:  CALL   56D
0610:  MOVF   7A,W
0611:  MOVWF  60
0612:  MOVF   79,W
0613:  MOVWF  5F
0614:  MOVF   78,W
0615:  MOVWF  5E
0616:  MOVF   77,W
0617:  MOVWF  5D
0618:  BTFSS  60.7
0619:  GOTO   627
061A:  DECF   62,F
061B:  BSF    62.5
061C:  COMF   5D,F
061D:  COMF   5E,F
061E:  COMF   5F,F
061F:  COMF   60,F
0620:  INCF   5D,F
0621:  BTFSC  03.2
0622:  INCF   5E,F
0623:  BTFSC  03.2
0624:  INCF   5F,F
0625:  BTFSC  03.2
0626:  INCF   60,F
0627:  MOVLW  3B
0628:  MOVWF  69
0629:  MOVLW  9A
062A:  MOVWF  68
062B:  MOVLW  CA
062C:  MOVWF  67
062D:  CLRF   66
062E:  MOVLW  0A
062F:  MOVWF  64
0630:  MOVF   61,W
0631:  BTFSC  03.2
0632:  INCF   62,F
0633:  BSF    03.1
0634:  MOVLW  5D
0635:  MOVWF  04
0636:  BCF    03.7
0637:  MOVF   60,W
0638:  MOVWF  6D
0639:  MOVF   5F,W
063A:  MOVWF  6C
063B:  MOVF   5E,W
063C:  MOVWF  6B
063D:  MOVF   5D,W
063E:  MOVWF  6A
063F:  MOVF   69,W
0640:  MOVWF  71
0641:  MOVF   68,W
0642:  MOVWF  70
0643:  MOVF   67,W
0644:  MOVWF  6F
0645:  MOVF   66,W
0646:  MOVWF  6E
0647:  CALL   58C
0648:  MOVF   78,W
0649:  MOVF   77,F
064A:  BTFSS  03.2
064B:  GOTO   65F
064C:  INCF   61,W
064D:  SUBWF  64,W
064E:  BTFSC  03.2
064F:  GOTO   65F
0650:  MOVF   62,W
0651:  BTFSC  03.2
0652:  GOTO   661
0653:  ANDLW  0F
0654:  SUBWF  64,W
0655:  BTFSC  03.2
0656:  GOTO   659
0657:  BTFSC  03.0
0658:  GOTO   691
0659:  BTFSC  62.7
065A:  GOTO   691
065B:  BTFSC  62.6
065C:  GOTO   661
065D:  MOVLW  20
065E:  GOTO   68D
065F:  MOVLW  20
0660:  ANDWF  62,F
0661:  BTFSS  62.5
0662:  GOTO   66F
0663:  BCF    62.5
0664:  MOVF   61,W
0665:  BTFSS  03.2
0666:  DECF   62,F
0667:  MOVF   77,W
0668:  MOVWF  62
0669:  MOVLW  2D
066A:  MOVWF  6A
066B:  CALL   5DB
066C:  MOVF   62,W
066D:  MOVWF  77
066E:  CLRF   62
066F:  MOVF   61,W
0670:  SUBWF  64,W
0671:  BTFSS  03.2
0672:  GOTO   67D
0673:  MOVF   77,W
0674:  MOVWF  62
0675:  MOVLW  2E
0676:  MOVWF  6A
0677:  CALL   5DB
0678:  MOVF   62,W
0679:  MOVWF  77
067A:  MOVLW  20
067B:  ANDWF  62,F
067C:  MOVLW  00
067D:  MOVLW  30
067E:  BTFSS  62.5
067F:  GOTO   68D
0680:  BCF    62.5
0681:  MOVF   61,W
0682:  BTFSS  03.2
0683:  DECF   62,F
0684:  MOVF   77,W
0685:  MOVWF  62
0686:  MOVLW  2D
0687:  MOVWF  6A
0688:  CALL   5DB
0689:  MOVF   62,W
068A:  MOVWF  77
068B:  CLRF   62
068C:  MOVLW  30
068D:  ADDWF  77,F
068E:  MOVF   77,W
068F:  MOVWF  6A
0690:  CALL   5DB
0691:  BCF    03.1
0692:  MOVF   69,W
0693:  MOVWF  6D
0694:  MOVF   68,W
0695:  MOVWF  6C
0696:  MOVF   67,W
0697:  MOVWF  6B
0698:  MOVF   66,W
0699:  MOVWF  6A
069A:  CLRF   71
069B:  CLRF   70
069C:  CLRF   6F
069D:  MOVLW  0A
069E:  MOVWF  6E
069F:  CALL   58C
06A0:  MOVF   7A,W
06A1:  MOVWF  69
06A2:  MOVF   79,W
06A3:  MOVWF  68
06A4:  MOVF   78,W
06A5:  MOVWF  67
06A6:  MOVF   77,W
06A7:  MOVWF  66
06A8:  DECFSZ 64,F
06A9:  GOTO   633
06AA:  BSF    0A.3
06AB:  BCF    0A.4
06AC:  GOTO   0AD (RETURN)
06AD:  MOVF   04,W
06AE:  MOVWF  62
06AF:  MOVF   61,W
06B0:  MOVWF  64
06B1:  BTFSC  03.2
06B2:  GOTO   6CC
06B3:  MOVF   60,W
06B4:  MOVWF  6D
06B5:  MOVF   5F,W
06B6:  MOVWF  6C
06B7:  MOVF   5E,W
06B8:  MOVWF  6B
06B9:  MOVF   5D,W
06BA:  MOVWF  6A
06BB:  CLRF   71
06BC:  CLRF   70
06BD:  MOVLW  20
06BE:  MOVWF  6F
06BF:  MOVLW  82
06C0:  MOVWF  6E
06C1:  CALL   4F8
06C2:  MOVF   7A,W
06C3:  MOVWF  60
06C4:  MOVF   79,W
06C5:  MOVWF  5F
06C6:  MOVF   78,W
06C7:  MOVWF  5E
06C8:  MOVF   77,W
06C9:  MOVWF  5D
06CA:  DECFSZ 64,F
06CB:  GOTO   6B3
06CC:  MOVF   60,W
06CD:  MOVWF  6D
06CE:  MOVF   5F,W
06CF:  MOVWF  6C
06D0:  MOVF   5E,W
06D1:  MOVWF  6B
06D2:  MOVF   5D,W
06D3:  MOVWF  6A
06D4:  CALL   56D
06D5:  MOVF   7A,W
06D6:  MOVWF  60
06D7:  MOVF   79,W
06D8:  MOVWF  5F
06D9:  MOVF   78,W
06DA:  MOVWF  5E
06DB:  MOVF   77,W
06DC:  MOVWF  5D
06DD:  BTFSS  60.7
06DE:  GOTO   6EC
06DF:  DECF   62,F
06E0:  BSF    62.5
06E1:  COMF   5D,F
06E2:  COMF   5E,F
06E3:  COMF   5F,F
06E4:  COMF   60,F
06E5:  INCF   5D,F
06E6:  BTFSC  03.2
06E7:  INCF   5E,F
06E8:  BTFSC  03.2
06E9:  INCF   5F,F
06EA:  BTFSC  03.2
06EB:  INCF   60,F
06EC:  MOVLW  3B
06ED:  MOVWF  69
06EE:  MOVLW  9A
06EF:  MOVWF  68
06F0:  MOVLW  CA
06F1:  MOVWF  67
06F2:  CLRF   66
06F3:  MOVLW  0A
06F4:  MOVWF  64
06F5:  MOVF   61,W
06F6:  BTFSC  03.2
06F7:  INCF   62,F
06F8:  BSF    03.1
06F9:  MOVLW  5D
06FA:  MOVWF  04
06FB:  BCF    03.7
06FC:  MOVF   60,W
06FD:  MOVWF  6D
06FE:  MOVF   5F,W
06FF:  MOVWF  6C
0700:  MOVF   5E,W
0701:  MOVWF  6B
0702:  MOVF   5D,W
0703:  MOVWF  6A
0704:  MOVF   69,W
0705:  MOVWF  71
0706:  MOVF   68,W
0707:  MOVWF  70
0708:  MOVF   67,W
0709:  MOVWF  6F
070A:  MOVF   66,W
070B:  MOVWF  6E
070C:  CALL   58C
070D:  MOVF   78,W
070E:  MOVF   77,F
070F:  BTFSS  03.2
0710:  GOTO   724
0711:  INCF   61,W
0712:  SUBWF  64,W
0713:  BTFSC  03.2
0714:  GOTO   724
0715:  MOVF   62,W
0716:  BTFSC  03.2
0717:  GOTO   726
0718:  ANDLW  0F
0719:  SUBWF  64,W
071A:  BTFSC  03.2
071B:  GOTO   71E
071C:  BTFSC  03.0
071D:  GOTO   75A
071E:  BTFSC  62.7
071F:  GOTO   75A
0720:  BTFSC  62.6
0721:  GOTO   726
0722:  MOVLW  20
0723:  GOTO   755
0724:  MOVLW  20
0725:  ANDWF  62,F
0726:  BTFSS  62.5
0727:  GOTO   735
0728:  BCF    62.5
0729:  MOVF   61,W
072A:  BTFSS  03.2
072B:  DECF   62,F
072C:  MOVF   77,W
072D:  MOVWF  62
072E:  MOVLW  2D
072F:  BTFSS  0C.4
0730:  GOTO   72F
0731:  MOVWF  19
0732:  MOVF   62,W
0733:  MOVWF  77
0734:  CLRF   62
0735:  MOVF   61,W
0736:  SUBWF  64,W
0737:  BTFSS  03.2
0738:  GOTO   744
0739:  MOVF   77,W
073A:  MOVWF  62
073B:  MOVLW  2E
073C:  BTFSS  0C.4
073D:  GOTO   73C
073E:  MOVWF  19
073F:  MOVF   62,W
0740:  MOVWF  77
0741:  MOVLW  20
0742:  ANDWF  62,F
0743:  MOVLW  00
0744:  MOVLW  30
0745:  BTFSS  62.5
0746:  GOTO   755
0747:  BCF    62.5
0748:  MOVF   61,W
0749:  BTFSS  03.2
074A:  DECF   62,F
074B:  MOVF   77,W
074C:  MOVWF  62
074D:  MOVLW  2D
074E:  BTFSS  0C.4
074F:  GOTO   74E
0750:  MOVWF  19
0751:  MOVF   62,W
0752:  MOVWF  77
0753:  CLRF   62
0754:  MOVLW  30
0755:  ADDWF  77,F
0756:  MOVF   77,W
0757:  BTFSS  0C.4
0758:  GOTO   757
0759:  MOVWF  19
075A:  BCF    03.1
075B:  MOVF   69,W
075C:  MOVWF  6D
075D:  MOVF   68,W
075E:  MOVWF  6C
075F:  MOVF   67,W
0760:  MOVWF  6B
0761:  MOVF   66,W
0762:  MOVWF  6A
0763:  CLRF   71
0764:  CLRF   70
0765:  CLRF   6F
0766:  MOVLW  0A
0767:  MOVWF  6E
0768:  CALL   58C
0769:  MOVF   7A,W
076A:  MOVWF  69
076B:  MOVF   79,W
076C:  MOVWF  68
076D:  MOVF   78,W
076E:  MOVWF  67
076F:  MOVF   77,W
0770:  MOVWF  66
0771:  DECFSZ 64,F
0772:  GOTO   6F8
0773:  BSF    0A.3
0774:  BCF    0A.4
0775:  GOTO   0DA (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=8000000) 
0776:  MOVLW  5B
0777:  MOVWF  04
0778:  BCF    03.7
0779:  MOVF   00,W
077A:  BTFSC  03.2
077B:  GOTO   789
077C:  MOVLW  02
077D:  MOVWF  78
077E:  CLRF   77
077F:  DECFSZ 77,F
0780:  GOTO   77F
0781:  DECFSZ 78,F
0782:  GOTO   77E
0783:  MOVLW  97
0784:  MOVWF  77
0785:  DECFSZ 77,F
0786:  GOTO   785
0787:  DECFSZ 00,F
0788:  GOTO   77C
0789:  RETURN
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7, bits=8, parity=N) // change pins compatible for your controller 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
081A:  BCF    03.5
081B:  CLRF   20
081C:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses XT, NOWDT,NOPROTECT,NOLVP 
.................... #include <HDM64GS12.c> //Manejo del display gráfico 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
023A:  BCF    22.0
023B:  MOVF   22,W
023C:  BSF    03.5
023D:  MOVWF  07
023E:  BCF    03.5
023F:  BSF    07.0
....................    output_low(GLCD_E); 
0240:  BSF    03.5
0241:  BCF    06.5
0242:  BCF    03.5
0243:  BCF    06.5
....................    output_low(GLCD_CS1); 
0244:  BSF    03.5
0245:  BCF    06.0
0246:  BCF    03.5
0247:  BCF    06.0
....................    output_low(GLCD_CS2); 
0248:  BSF    03.5
0249:  BCF    06.1
024A:  BCF    03.5
024B:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
024C:  BSF    03.5
024D:  BCF    06.2
024E:  BCF    03.5
024F:  BCF    06.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
0250:  CLRF   76
0251:  MOVLW  C0
0252:  MOVWF  7B
0253:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
0254:  MOVLW  01
0255:  MOVWF  76
0256:  MOVLW  C0
0257:  MOVWF  7B
0258:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
0259:  CLRF   76
025A:  MOVLW  40
025B:  MOVWF  7B
025C:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
025D:  MOVLW  01
025E:  MOVWF  76
025F:  MOVLW  40
0260:  MOVWF  7B
0261:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
0262:  CLRF   76
0263:  MOVLW  B8
0264:  MOVWF  7B
0265:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
0266:  MOVLW  01
0267:  MOVWF  76
0268:  MOVLW  B8
0269:  MOVWF  7B
026A:  CALL   1EA
....................  
....................    if(mode == ON) 
026B:  DECFSZ 59,W
026C:  GOTO   277
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
026D:  CLRF   76
026E:  MOVLW  3F
026F:  MOVWF  7B
0270:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0271:  MOVLW  01
0272:  MOVWF  76
0273:  MOVLW  3F
0274:  MOVWF  7B
0275:  CALL   1EA
....................    } 
0276:  GOTO   280
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
0277:  CLRF   76
0278:  MOVLW  3E
0279:  MOVWF  7B
027A:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
027B:  MOVLW  01
027C:  MOVWF  76
027D:  MOVLW  3E
027E:  MOVWF  7B
027F:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
0280:  CLRF   5A
....................  
....................    #ifdef FAST_GLCD 
*
02C6:  BSF    0A.3
02C7:  BCF    0A.4
02C8:  GOTO   05E (RETURN)
....................    glcd_update(); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
*
02F6:  BCF    73.0
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
02F7:  MOVF   6F,W
02F8:  SUBLW  3F
02F9:  BTFSC  03.0
02FA:  GOTO   2FE
....................    { 
....................       x -= 64; 
02FB:  MOVLW  40
02FC:  SUBWF  6F,F
....................       side = GLCD_RIGHT; 
02FD:  BSF    73.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
02FE:  BSF    03.5
02FF:  BCF    06.2
0300:  BCF    03.5
0301:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0302:  BCF    6F.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0303:  BSF    6F.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
0304:  MOVLW  00
0305:  BTFSC  73.0
0306:  MOVLW  01
0307:  MOVWF  74
0308:  MOVWF  76
0309:  MOVF   6F,W
030A:  MOVWF  7B
030B:  CALL   1EA
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
030C:  MOVLW  00
030D:  BTFSC  73.0
030E:  MOVLW  01
030F:  MOVWF  74
0310:  RRF    70,W
0311:  MOVWF  77
0312:  RRF    77,F
0313:  RRF    77,F
0314:  MOVLW  1F
0315:  ANDWF  77,F
0316:  MOVF   77,W
0317:  ANDLW  BF
0318:  IORLW  B8
0319:  MOVWF  75
031A:  MOVF   74,W
031B:  MOVWF  76
031C:  MOVF   75,W
031D:  MOVWF  7B
031E:  CALL   1EA
....................    output_high(GLCD_DI);                        // Set for data 
031F:  BSF    03.5
0320:  BCF    06.2
0321:  BCF    03.5
0322:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
0323:  MOVLW  00
0324:  BTFSC  73.0
0325:  MOVLW  01
0326:  MOVWF  74
0327:  MOVWF  75
0328:  CALL   2C9
....................    data = glcd_readByte(side);                  //  at new address 
0329:  MOVLW  00
032A:  BTFSC  73.0
032B:  MOVLW  01
032C:  MOVWF  74
032D:  MOVWF  75
032E:  CALL   2C9
032F:  MOVF   78,W
0330:  MOVWF  72
....................  
....................    if(color == ON) 
0331:  DECFSZ 71,W
0332:  GOTO   343
....................       bit_set(data, y%8);        // Turn the pixel on 
0333:  MOVF   70,W
0334:  ANDLW  07
0335:  MOVWF  74
0336:  MOVLW  01
0337:  MOVWF  77
0338:  MOVF   74,W
0339:  MOVWF  78
033A:  BTFSC  03.2
033B:  GOTO   340
033C:  BCF    03.0
033D:  RLF    77,F
033E:  DECFSZ 78,F
033F:  GOTO   33C
0340:  MOVF   77,W
0341:  IORWF  72,F
0342:  GOTO   353
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
0343:  MOVF   70,W
0344:  ANDLW  07
0345:  MOVWF  74
0346:  MOVLW  01
0347:  MOVWF  77
0348:  MOVF   74,W
0349:  MOVWF  78
034A:  BTFSC  03.2
034B:  GOTO   350
034C:  BCF    03.0
034D:  RLF    77,F
034E:  DECFSZ 78,F
034F:  GOTO   34C
0350:  MOVF   77,W
0351:  XORLW  FF
0352:  ANDWF  72,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
0353:  BSF    03.5
0354:  BCF    06.2
0355:  BCF    03.5
0356:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
0357:  MOVLW  00
0358:  BTFSC  73.0
0359:  MOVLW  01
035A:  MOVWF  74
035B:  MOVWF  76
035C:  MOVF   6F,W
035D:  MOVWF  7B
035E:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
035F:  BSF    03.5
0360:  BCF    06.2
0361:  BCF    03.5
0362:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
0363:  MOVLW  00
0364:  BTFSC  73.0
0365:  MOVLW  01
0366:  MOVWF  74
0367:  MOVWF  76
0368:  MOVF   72,W
0369:  MOVWF  7B
036A:  CALL   1EA
036B:  RETURN
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0281:  CLRF   5B
0282:  MOVF   5B,W
0283:  SUBLW  07
0284:  BTFSS  03.0
0285:  GOTO   2C6
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0286:  BSF    03.5
0287:  BCF    06.2
0288:  BCF    03.5
0289:  BCF    06.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
028A:  CLRF   76
028B:  MOVLW  40
028C:  MOVWF  7B
028D:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
028E:  MOVLW  01
028F:  MOVWF  76
0290:  MOVLW  40
0291:  MOVWF  7B
0292:  CALL   1EA
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
0293:  MOVF   5B,W
0294:  IORLW  B8
0295:  MOVWF  5D
0296:  CLRF   76
0297:  MOVF   5D,W
0298:  MOVWF  7B
0299:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
029A:  MOVF   5B,W
029B:  IORLW  B8
029C:  MOVWF  5D
029D:  MOVLW  01
029E:  MOVWF  76
029F:  MOVF   5D,W
02A0:  MOVWF  7B
02A1:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
02A2:  BSF    03.5
02A3:  BCF    06.2
02A4:  BCF    03.5
02A5:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02A6:  CLRF   5C
02A7:  MOVF   5C,W
02A8:  SUBLW  3F
02A9:  BTFSS  03.0
02AA:  GOTO   2C4
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
02AB:  MOVLW  FF
02AC:  MOVWF  6F
02AD:  MOVF   5A,W
02AE:  MOVWF  70
02AF:  CALL   215
02B0:  MOVF   78,W
02B1:  MOVWF  5D
02B2:  CLRF   76
02B3:  MOVF   78,W
02B4:  MOVWF  7B
02B5:  CALL   1EA
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
02B6:  MOVLW  FF
02B7:  MOVWF  6F
02B8:  MOVF   5A,W
02B9:  MOVWF  70
02BA:  CALL   215
02BB:  MOVF   78,W
02BC:  MOVWF  5D
02BD:  MOVLW  01
02BE:  MOVWF  76
02BF:  MOVF   78,W
02C0:  MOVWF  7B
02C1:  CALL   1EA
02C2:  INCF   5C,F
02C3:  GOTO   2A7
....................       } 
02C4:  INCF   5B,F
02C5:  GOTO   282
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    set_tris_d(0x00); 
*
01EA:  MOVLW  00
01EB:  BSF    03.5
01EC:  MOVWF  08
....................     
....................    output_low(GLCD_RW);       // Set for writing 
01ED:  BCF    06.4
01EE:  BCF    03.5
01EF:  BCF    06.4
....................  
.................... 	 if(side)                   // Choose which side to write to 
01F0:  MOVF   76,F
01F1:  BTFSC  03.2
01F2:  GOTO   1F8
....................       output_high(GLCD_CS2); 
01F3:  BSF    03.5
01F4:  BCF    06.1
01F5:  BCF    03.5
01F6:  BSF    06.1
01F7:  GOTO   1FC
....................    else 
....................       output_high(GLCD_CS1); 
01F8:  BSF    03.5
01F9:  BCF    06.0
01FA:  BCF    03.5
01FB:  BSF    06.0
....................  
.................... 	 delay_us(1); 
01FC:  GOTO   1FD
....................  
....................    output_d(data);            // Put the data on the port 
01FD:  BSF    03.5
01FE:  CLRF   08
01FF:  MOVF   7B,W
0200:  BCF    03.5
0201:  MOVWF  08
....................    delay_us(1); 
0202:  GOTO   203
....................    output_high(GLCD_E);       // Pulse the enable pin 
0203:  BSF    03.5
0204:  BCF    06.5
0205:  BCF    03.5
0206:  BSF    06.5
....................    delay_us(1); 
0207:  GOTO   208
....................    output_low(GLCD_E); 
0208:  BSF    03.5
0209:  BCF    06.5
020A:  BCF    03.5
020B:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020C:  BSF    03.5
020D:  BCF    06.0
020E:  BCF    03.5
020F:  BCF    06.0
....................    output_low(GLCD_CS2); 
0210:  BSF    03.5
0211:  BCF    06.1
0212:  BCF    03.5
0213:  BCF    06.1
0214:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
02C9:  MOVLW  FF
02CA:  BSF    03.5
02CB:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
02CC:  BCF    06.4
02CD:  BCF    03.5
02CE:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
02CF:  MOVF   75,F
02D0:  BTFSC  03.2
02D1:  GOTO   2D7
....................       output_high(GLCD_CS2); 
02D2:  BSF    03.5
02D3:  BCF    06.1
02D4:  BCF    03.5
02D5:  BSF    06.1
02D6:  GOTO   2DB
....................    else 
....................       output_high(GLCD_CS1); 
02D7:  BSF    03.5
02D8:  BCF    06.0
02D9:  BCF    03.5
02DA:  BSF    06.0
....................  
....................    delay_us(1); 
02DB:  GOTO   2DC
....................    output_high(GLCD_E);       // Pulse the enable pin 
02DC:  BSF    03.5
02DD:  BCF    06.5
02DE:  BCF    03.5
02DF:  BSF    06.5
....................    delay_us(1); 
02E0:  GOTO   2E1
....................    data = input_d();          // Get the data from the display's output register 
02E1:  MOVLW  FF
02E2:  BSF    03.5
02E3:  MOVWF  08
02E4:  BCF    03.5
02E5:  MOVF   08,W
02E6:  MOVWF  76
....................    output_low(GLCD_E); 
02E7:  BSF    03.5
02E8:  BCF    06.5
02E9:  BCF    03.5
02EA:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
02EB:  BSF    03.5
02EC:  BCF    06.0
02ED:  BCF    03.5
02EE:  BCF    06.0
....................    output_low(GLCD_CS2); 
02EF:  BSF    03.5
02F0:  BCF    06.1
02F1:  BCF    03.5
02F2:  BCF    06.1
....................    return data;               // Return the read data 
02F3:  MOVF   76,W
02F4:  MOVWF  78
02F5:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <graphics.c> //Funciones para dibujar y escribir en el display 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
*
0442:  MOVLW  01
0443:  MOVWF  62
0444:  MOVWF  63
0445:  CLRF   68
.................... { 
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
0446:  MOVF   59,W
0447:  SUBWF  5B,W
0448:  MOVWF  69
0449:  MOVF   69,W
044A:  BTFSS  69.7
044B:  GOTO   44E
044C:  MOVF   69,W
044D:  SUBLW  00
044E:  CLRF   7A
044F:  MOVWF  60
0450:  MOVF   7A,W
0451:  MOVWF  61
....................    dy = abs((signed int8)(y2 - y1)); 
0452:  MOVF   5A,W
0453:  SUBWF  5C,W
0454:  MOVWF  69
0455:  MOVF   69,W
0456:  BTFSS  69.7
0457:  GOTO   45A
0458:  MOVF   69,W
0459:  SUBLW  00
045A:  CLRF   7A
045B:  MOVWF  5E
045C:  MOVF   7A,W
045D:  MOVWF  5F
....................    #endif 
....................  
....................    if(x1 > x2) 
045E:  MOVF   59,W
045F:  SUBWF  5B,W
0460:  BTFSC  03.0
0461:  GOTO   464
....................       addx = -1; 
0462:  MOVLW  FF
0463:  MOVWF  62
....................    if(y1 > y2) 
0464:  MOVF   5A,W
0465:  SUBWF  5C,W
0466:  BTFSC  03.0
0467:  GOTO   46A
....................       addy = -1; 
0468:  MOVLW  FF
0469:  MOVWF  63
....................  
....................    if(dx >= dy) 
046A:  MOVF   5F,W
046B:  SUBWF  61,W
046C:  BTFSS  03.0
046D:  GOTO   4B6
046E:  BTFSS  03.2
046F:  GOTO   474
0470:  MOVF   5E,W
0471:  SUBWF  60,W
0472:  BTFSS  03.0
0473:  GOTO   4B6
....................    { 
....................       dy *= 2; 
0474:  BCF    03.0
0475:  RLF    5E,F
0476:  RLF    5F,F
....................       P = dy - dx; 
0477:  MOVF   60,W
0478:  SUBWF  5E,W
0479:  MOVWF  77
047A:  MOVF   5F,W
047B:  MOVWF  7A
047C:  MOVF   61,W
047D:  BTFSS  03.0
047E:  INCFSZ 61,W
047F:  SUBWF  7A,F
0480:  MOVF   77,W
0481:  MOVWF  64
0482:  MOVF   7A,W
0483:  MOVWF  65
....................       diff = P - dx; 
0484:  MOVF   60,W
0485:  SUBWF  64,W
0486:  MOVWF  66
0487:  MOVF   65,W
0488:  MOVWF  67
0489:  MOVF   61,W
048A:  BTFSS  03.0
048B:  INCFSZ 61,W
048C:  SUBWF  67,F
....................  
....................       for(; i<=dx; ++i) 
048D:  MOVF   61,F
048E:  BTFSS  03.2
048F:  GOTO   494
0490:  MOVF   68,W
0491:  SUBWF  60,W
0492:  BTFSS  03.0
0493:  GOTO   4B5
....................       { 
....................          glcd_pixel(x1, y1, color); 
0494:  MOVF   59,W
0495:  MOVWF  6F
0496:  MOVF   5A,W
0497:  MOVWF  70
0498:  MOVF   5D,W
0499:  MOVWF  71
049A:  CALL   2F6
....................  
....................          if(P < 0) 
049B:  BTFSS  65.7
049C:  GOTO   4A7
....................          { 
....................             P  += dy; 
049D:  MOVF   5E,W
049E:  ADDWF  64,F
049F:  MOVF   5F,W
04A0:  BTFSC  03.0
04A1:  INCFSZ 5F,W
04A2:  ADDWF  65,F
....................             x1 += addx; 
04A3:  MOVF   62,W
04A4:  ADDWF  59,W
04A5:  MOVWF  59
....................          } 
04A6:  GOTO   4B3
....................          else 
....................          { 
....................             P  += diff; 
04A7:  MOVF   66,W
04A8:  ADDWF  64,F
04A9:  MOVF   67,W
04AA:  BTFSC  03.0
04AB:  INCFSZ 67,W
04AC:  ADDWF  65,F
....................             x1 += addx; 
04AD:  MOVF   62,W
04AE:  ADDWF  59,W
04AF:  MOVWF  59
....................             y1 += addy; 
04B0:  MOVF   63,W
04B1:  ADDWF  5A,W
04B2:  MOVWF  5A
....................          } 
04B3:  INCF   68,F
04B4:  GOTO   48D
....................       } 
....................    } 
04B5:  GOTO   4F7
....................    else 
....................    { 
....................       dx *= 2; 
04B6:  BCF    03.0
04B7:  RLF    60,F
04B8:  RLF    61,F
....................       P = dx - dy; 
04B9:  MOVF   5E,W
04BA:  SUBWF  60,W
04BB:  MOVWF  77
04BC:  MOVF   61,W
04BD:  MOVWF  7A
04BE:  MOVF   5F,W
04BF:  BTFSS  03.0
04C0:  INCFSZ 5F,W
04C1:  SUBWF  7A,F
04C2:  MOVF   77,W
04C3:  MOVWF  64
04C4:  MOVF   7A,W
04C5:  MOVWF  65
....................       diff = P - dy; 
04C6:  MOVF   5E,W
04C7:  SUBWF  64,W
04C8:  MOVWF  66
04C9:  MOVF   65,W
04CA:  MOVWF  67
04CB:  MOVF   5F,W
04CC:  BTFSS  03.0
04CD:  INCFSZ 5F,W
04CE:  SUBWF  67,F
....................  
....................       for(; i<=dy; ++i) 
04CF:  MOVF   5F,F
04D0:  BTFSS  03.2
04D1:  GOTO   4D6
04D2:  MOVF   68,W
04D3:  SUBWF  5E,W
04D4:  BTFSS  03.0
04D5:  GOTO   4F7
....................       { 
....................          glcd_pixel(x1, y1, color); 
04D6:  MOVF   59,W
04D7:  MOVWF  6F
04D8:  MOVF   5A,W
04D9:  MOVWF  70
04DA:  MOVF   5D,W
04DB:  MOVWF  71
04DC:  CALL   2F6
....................  
....................          if(P < 0) 
04DD:  BTFSS  65.7
04DE:  GOTO   4E9
....................          { 
....................             P  += dx; 
04DF:  MOVF   60,W
04E0:  ADDWF  64,F
04E1:  MOVF   61,W
04E2:  BTFSC  03.0
04E3:  INCFSZ 61,W
04E4:  ADDWF  65,F
....................             y1 += addy; 
04E5:  MOVF   63,W
04E6:  ADDWF  5A,W
04E7:  MOVWF  5A
....................          } 
04E8:  GOTO   4F5
....................          else 
....................          { 
....................             P  += diff; 
04E9:  MOVF   66,W
04EA:  ADDWF  64,F
04EB:  MOVF   67,W
04EC:  BTFSC  03.0
04ED:  INCFSZ 67,W
04EE:  ADDWF  65,F
....................             x1 += addx; 
04EF:  MOVF   62,W
04F0:  ADDWF  59,W
04F1:  MOVWF  59
....................             y1 += addy; 
04F2:  MOVF   63,W
04F3:  ADDWF  5A,W
04F4:  MOVWF  5A
....................          } 
04F5:  INCF   68,F
04F6:  GOTO   4CF
....................       } 
....................    } 
04F7:  RETURN
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
....................       { 
....................          xmin = x1; 
....................          xmax = x2; 
....................       } 
....................       else 
....................       { 
....................          xmin = x2; 
....................          xmax = x1; 
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
....................       { 
....................          ymin = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          ymin = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
....................          { 
....................             glcd_pixel(xmin, i, color); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
036C:  MOVF   61,W
036D:  MOVWF  7A
036E:  MOVF   60,W
036F:  MOVWF  04
0370:  BCF    03.7
0371:  BTFSC  7A.0
0372:  BSF    03.7
0373:  MOVF   00,F
0374:  BTFSC  03.2
0375:  GOTO   441
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0376:  MOVF   61,W
0377:  MOVWF  7A
0378:  MOVF   60,W
0379:  MOVWF  04
037A:  BCF    03.7
037B:  BTFSC  7A.0
037C:  BSF    03.7
037D:  MOVF   00,W
037E:  SUBLW  52
037F:  BTFSS  03.0
0380:  GOTO   39F
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0381:  MOVF   61,W
0382:  MOVWF  7A
0383:  MOVF   60,W
0384:  MOVWF  04
0385:  BCF    03.7
0386:  BTFSC  7A.0
0387:  BSF    03.7
0388:  MOVLW  20
0389:  SUBWF  00,W
038A:  MOVWF  6E
038B:  MOVWF  6F
038C:  MOVLW  05
038D:  MOVWF  70
038E:  CALL   215
038F:  MOVF   78,W
0390:  MOVWF  6D
0391:  MOVWF  78
0392:  MOVLW  05
0393:  MOVWF  77
0394:  MOVLW  68
0395:  MOVWF  04
0396:  BCF    03.7
0397:  MOVF   78,W
0398:  CALL   004
0399:  MOVWF  00
039A:  INCF   78,F
039B:  INCF   04,F
039C:  DECFSZ 77,F
039D:  GOTO   397
039E:  GOTO   3CD
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
039F:  MOVF   61,W
03A0:  MOVWF  7A
03A1:  MOVF   60,W
03A2:  MOVWF  04
03A3:  BCF    03.7
03A4:  BTFSC  7A.0
03A5:  BSF    03.7
03A6:  MOVF   00,W
03A7:  SUBLW  7E
03A8:  BTFSS  03.0
03A9:  GOTO   3C8
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
03AA:  MOVF   61,W
03AB:  MOVWF  7A
03AC:  MOVF   60,W
03AD:  MOVWF  04
03AE:  BCF    03.7
03AF:  BTFSC  7A.0
03B0:  BSF    03.7
03B1:  MOVLW  53
03B2:  SUBWF  00,W
03B3:  MOVWF  6E
03B4:  MOVWF  6F
03B5:  MOVLW  05
03B6:  MOVWF  70
03B7:  CALL   215
03B8:  MOVF   78,W
03B9:  MOVWF  6D
03BA:  MOVWF  78
03BB:  MOVLW  05
03BC:  MOVWF  77
03BD:  MOVLW  68
03BE:  MOVWF  04
03BF:  BCF    03.7
03C0:  MOVF   78,W
03C1:  CALL   10A
03C2:  MOVWF  00
03C3:  INCF   78,F
03C4:  INCF   04,F
03C5:  DECFSZ 77,F
03C6:  GOTO   3C0
03C7:  GOTO   3CD
....................       else 
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
03C8:  CLRF   68
03C9:  CLRF   69
03CA:  CLRF   6A
03CB:  CLRF   6B
03CC:  CLRF   6C
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
03CD:  MOVF   61,W
03CE:  MOVWF  7A
03CF:  MOVF   60,W
03D0:  MOVWF  04
03D1:  BCF    03.7
03D2:  BTFSC  7A.0
03D3:  BSF    03.7
03D4:  MOVF   00,W
03D5:  XORLW  0A
03D6:  BTFSC  03.2
03D7:  GOTO   3DC
03D8:  XORLW  07
03D9:  BTFSC  03.2
03DA:  GOTO   3E5
03DB:  GOTO   3E7
....................       { 
....................          case '\n': 
....................             y += 7*size + 1; 
03DC:  MOVLW  07
03DD:  MOVWF  6F
03DE:  MOVF   62,W
03DF:  MOVWF  70
03E0:  CALL   215
03E1:  MOVLW  01
03E2:  ADDWF  78,W
03E3:  ADDWF  5F,F
....................             continue; 
03E4:  GOTO   43C
....................          case '\r': 
....................             x = 0; 
03E5:  CLRF   5E
....................             continue; 
03E6:  GOTO   43C
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
03E7:  MOVLW  05
03E8:  MOVWF  6F
03E9:  MOVF   62,W
03EA:  MOVWF  70
03EB:  CALL   215
03EC:  MOVF   78,W
03ED:  ADDWF  5E,W
03EE:  SUBLW  7F
03EF:  BTFSC  03.0
03F0:  GOTO   3FA
....................       { 
....................          x = 0;                           // Set x at far left position 
03F1:  CLRF   5E
....................          y += 7*size + 1;                 // Set y at next position down 
03F2:  MOVLW  07
03F3:  MOVWF  6F
03F4:  MOVF   62,W
03F5:  MOVWF  70
03F6:  CALL   215
03F7:  MOVLW  01
03F8:  ADDWF  78,W
03F9:  ADDWF  5F,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
03FA:  CLRF   64
03FB:  MOVF   64,W
03FC:  SUBLW  04
03FD:  BTFSS  03.0
03FE:  GOTO   43C
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
03FF:  CLRF   65
0400:  MOVF   65,W
0401:  SUBLW  06
0402:  BTFSS  03.0
0403:  GOTO   438
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0404:  MOVLW  68
0405:  ADDWF  64,W
0406:  MOVWF  04
0407:  BCF    03.7
0408:  MOVF   00,W
0409:  MOVWF  6D
040A:  MOVWF  77
040B:  MOVF   65,W
040C:  MOVWF  78
040D:  BTFSC  03.2
040E:  GOTO   413
040F:  BCF    03.0
0410:  RRF    77,F
0411:  DECFSZ 78,F
0412:  GOTO   40F
0413:  BTFSS  77.0
0414:  GOTO   436
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
0415:  CLRF   66
0416:  MOVF   62,W
0417:  SUBWF  66,W
0418:  BTFSC  03.0
0419:  GOTO   436
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
041A:  CLRF   67
041B:  MOVF   62,W
041C:  SUBWF  67,W
041D:  BTFSC  03.0
041E:  GOTO   434
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
041F:  MOVF   67,W
0420:  ADDWF  5E,W
0421:  MOVWF  6D
0422:  MOVF   65,W
0423:  MOVWF  6F
0424:  MOVF   62,W
0425:  MOVWF  70
0426:  CALL   215
0427:  MOVF   78,W
0428:  ADDWF  5F,W
0429:  ADDWF  66,W
042A:  MOVWF  6E
042B:  MOVF   6D,W
042C:  MOVWF  6F
042D:  MOVF   6E,W
042E:  MOVWF  70
042F:  MOVF   63,W
0430:  MOVWF  71
0431:  CALL   2F6
0432:  INCF   67,F
0433:  GOTO   41B
....................                   } 
0434:  INCF   66,F
0435:  GOTO   416
....................                } 
....................             } 
0436:  INCF   65,F
0437:  GOTO   400
....................          } 
0438:  INCF   64,F
0439:  MOVF   62,W
043A:  ADDWF  5E,F
043B:  GOTO   3FB
....................       } 
043C:  INCF   60,F
043D:  BTFSC  03.2
043E:  INCF   61,F
043F:  INCF   5E,F
0440:  GOTO   36C
....................    } 
0441:  RETURN
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #byte trisb=0x86 
....................  
.................... #define escala -0.20 //Escala negativa para que crezca hacia arriba. 
....................  
.................... int x=0; //Posicion inicial de x para graficar la temperatura 
.................... signed int16 y=0; //Posicion inicial de y (Vamos a tener que cambiarla a la primer temperatura leida) para graficar la temperatura 
.................... int offset=52; //es el offset para la altura de la grafica 
....................  
.................... void mostrarBT(int1 estado){ //Mostramos BT si el bluetooth esta prendido 
....................    char bt[]="BT"; 
*
078A:  MOVLW  42
078B:  MOVWF  5B
078C:  MOVLW  54
078D:  MOVWF  5C
078E:  CLRF   5D
....................    glcd_text57(110,0,bt,1,estado); 
078F:  MOVLW  6E
0790:  MOVWF  5E
0791:  CLRF   5F
0792:  CLRF   61
0793:  MOVLW  5B
0794:  MOVWF  60
0795:  MOVLW  01
0796:  MOVWF  62
0797:  MOVF   5A,W
0798:  MOVWF  63
0799:  CALL   36C
079A:  RETURN
.................... } 
....................  
.................... void limpiarPorcion(int x1, int y1, int x2, int y2){ //(x1, y1) = posición del primer pixel. (x2, y2) = cantididad de pixeles hacia la derecha y hacia abajo 
....................    for(int i=x1;i<x1+x2;i++){ 
....................       for(int j=y1;j<y1+y2;j++){ 
....................          glcd_pixel(i, j, OFF); //Apagamos el pixel. 
....................       } 
....................    } 
.................... } 
....................  
.................... void nuevaLinea(float temp){ //Funcion para graficar las nuevas lineas de temperatura 
....................    int x1=x+2; 
....................    if(x1>128){ //Revisamos si sobrepasamos el tamaño de la pantalla 
....................       limpiarPorcion(0, 20, 128, 44); //Limpiamos la porcion del grafico de la pantalla 
....................       x=0; 
....................       x1=2; 
....................    } 
....................    glcd_line(x, (y*escala)+offset, x1, (temp*escala)+offset, ON); //multiplicamos por la escala para que la grafica entre en el area del grafico. El offset esta explicado arriba 
....................    y=temp; 
....................    x=x1; 
.................... } 
.................... void turn_on_bt() { 
....................    char value; 
....................    value = getc();   // get the data 
079B:  BTFSS  0C.5
079C:  GOTO   79B
079D:  MOVF   1A,W
079E:  MOVWF  59
....................    if(value == 'a') {  // if value is a 
079F:  MOVF   59,W
07A0:  SUBLW  61
07A1:  BTFSS  03.2
07A2:  GOTO   7AE
....................       //output_high(LED1);   // LED ON 
....................       mostrarBT(ON); 
07A3:  MOVLW  01
07A4:  MOVWF  5A
07A5:  CALL   78A
....................       delay_ms(500);       // delay 500 ms 
07A6:  MOVLW  02
07A7:  MOVWF  5A
07A8:  MOVLW  FA
07A9:  MOVWF  5B
07AA:  CALL   776
07AB:  DECFSZ 5A,F
07AC:  GOTO   7A8
....................    } else if(value == 'b') {  // if value is a 
07AD:  GOTO   7BB
07AE:  MOVF   59,W
07AF:  SUBLW  62
07B0:  BTFSS  03.2
07B1:  GOTO   7BB
....................       //output_low(LED1);    // LED OFF 
....................       mostrarBT(OFF); 
07B2:  CLRF   5A
07B3:  CALL   78A
....................       delay_ms(500);       // delay 500 ms 
07B4:  MOVLW  02
07B5:  MOVWF  5A
07B6:  MOVLW  FA
07B7:  MOVWF  5B
07B8:  CALL   776
07B9:  DECFSZ 5A,F
07BA:  GOTO   7B6
....................    }  
07BB:  BSF    0A.3
07BC:  BCF    0A.4
07BD:  GOTO   0ED (RETURN)
.................... } 
....................  
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  19
0804:  BSF    03.5
0805:  MOVWF  19
0806:  MOVLW  A2
0807:  MOVWF  18
0808:  MOVLW  90
0809:  BCF    03.5
080A:  MOVWF  18
080B:  MOVLW  FF
080C:  MOVWF  22
080D:  CLRF   23
080E:  CLRF   25
080F:  CLRF   24
0810:  MOVLW  34
0811:  MOVWF  26
0812:  CLRF   28
0813:  CLRF   27
0814:  BSF    03.5
0815:  BSF    1F.0
0816:  BSF    1F.1
0817:  BSF    1F.2
0818:  BCF    1F.3
0819:  BCF    03.7
.................... { 
....................    char str[10]; 
....................    char temp[]="Temperatura:"; 
*
081D:  MOVLW  54
081E:  MOVWF  33
081F:  MOVLW  65
0820:  MOVWF  34
0821:  MOVLW  6D
0822:  MOVWF  35
0823:  MOVLW  70
0824:  MOVWF  36
0825:  MOVLW  65
0826:  MOVWF  37
0827:  MOVLW  72
0828:  MOVWF  38
0829:  MOVLW  61
082A:  MOVWF  39
082B:  MOVLW  74
082C:  MOVWF  3A
082D:  MOVLW  75
082E:  MOVWF  3B
082F:  MOVLW  72
0830:  MOVWF  3C
0831:  MOVLW  61
0832:  MOVWF  3D
0833:  MOVLW  3A
0834:  MOVWF  3E
0835:  CLRF   3F
....................    float t[]={37, 36.5, 38, -55, 150, 30}; //ESTO HAY QUE FLETARLO CUANDO YA ESTÉ LA CAPTURA REAL 
0836:  MOVLW  84
0837:  MOVWF  40
0838:  MOVLW  14
0839:  MOVWF  41
083A:  CLRF   42
083B:  CLRF   43
083C:  MOVLW  84
083D:  MOVWF  44
083E:  MOVLW  12
083F:  MOVWF  45
0840:  CLRF   46
0841:  CLRF   47
0842:  MOVLW  84
0843:  MOVWF  48
0844:  MOVLW  18
0845:  MOVWF  49
0846:  CLRF   4A
0847:  CLRF   4B
0848:  MOVLW  84
0849:  MOVWF  4C
084A:  MOVLW  DC
084B:  MOVWF  4D
084C:  CLRF   4E
084D:  CLRF   4F
084E:  MOVLW  86
084F:  MOVWF  50
0850:  MOVLW  16
0851:  MOVWF  51
0852:  CLRF   52
0853:  CLRF   53
0854:  MOVLW  83
0855:  MOVWF  54
0856:  MOVLW  70
0857:  MOVWF  55
0858:  CLRF   56
0859:  CLRF   57
....................    glcd_init(on); //Inicializamos el lcd 
085A:  MOVLW  01
085B:  MOVWF  59
085C:  BCF    0A.3
085D:  GOTO   23A
085E:  BSF    0A.3
....................  
....................    //texto 
....................    glcd_text57(0,10,temp,1,ON); //Escribimos el texto "Tempreatura:" en la posicion 0,10 
085F:  CLRF   5E
0860:  MOVLW  0A
0861:  MOVWF  5F
0862:  CLRF   61
0863:  MOVLW  33
0864:  MOVWF  60
0865:  MOVLW  01
0866:  MOVWF  62
0867:  MOVWF  63
0868:  BCF    0A.3
0869:  CALL   36C
086A:  BSF    0A.3
....................    //dibujar una linea 
....................    glcd_line(0, 8, 128, 8, ON); //Pintamos una linea por debajo del barra de notificaciones 
086B:  CLRF   59
086C:  MOVLW  08
086D:  MOVWF  5A
086E:  MOVLW  80
086F:  MOVWF  5B
0870:  MOVLW  08
0871:  MOVWF  5C
0872:  MOVLW  01
0873:  MOVWF  5D
0874:  BCF    0A.3
0875:  CALL   442
0876:  BSF    0A.3
....................    glcd_line(0, 19, 128, 19, ON); //Pintamos una linea por debajo de la temperatura 
0877:  CLRF   59
0878:  MOVLW  13
0879:  MOVWF  5A
087A:  MOVLW  80
087B:  MOVWF  5B
087C:  MOVLW  13
087D:  MOVWF  5C
087E:  MOVLW  01
087F:  MOVWF  5D
0880:  BCF    0A.3
0881:  CALL   442
0882:  BSF    0A.3
....................       
....................    for(int i=0; i<10; i++){ //ESTO HAY QUE FLETARLO CUANDO YA ESTÉ LA CAPTURA REAL || LO QUE ESTA ACA DESPUES VA AL WHILE(TRUE) 
0883:  CLRF   58
0884:  MOVF   58,W
0885:  SUBLW  09
0886:  BTFSS  03.0
0887:  GOTO   0E6
....................       sprintf(str, "%4.2f°C", t[i]); //Convertimos la temperatura float en un char* 
0888:  RLF    58,W
0889:  MOVWF  77
088A:  RLF    77,F
088B:  MOVLW  FC
088C:  ANDWF  77,F
088D:  MOVF   77,W
088E:  ADDLW  40
088F:  MOVWF  04
0890:  BCF    03.7
0891:  MOVF   00,W
0892:  MOVWF  59
0893:  INCF   04,F
0894:  MOVF   00,W
0895:  MOVWF  5A
0896:  INCF   04,F
0897:  MOVF   00,W
0898:  MOVWF  5B
0899:  INCF   04,F
089A:  MOVF   00,W
089B:  MOVWF  5C
089C:  CLRF   28
089D:  MOVLW  29
089E:  MOVWF  27
089F:  MOVLW  03
08A0:  MOVWF  04
08A1:  MOVF   5C,W
08A2:  MOVWF  60
08A3:  MOVF   5B,W
08A4:  MOVWF  5F
08A5:  MOVF   5A,W
08A6:  MOVWF  5E
08A7:  MOVF   59,W
08A8:  MOVWF  5D
08A9:  MOVLW  02
08AA:  MOVWF  61
08AB:  BCF    0A.3
08AC:  GOTO   5E8
08AD:  BSF    0A.3
08AE:  MOVLW  B0
08AF:  MOVWF  6A
08B0:  BCF    0A.3
08B1:  CALL   5DB
08B2:  BSF    0A.3
08B3:  MOVLW  43
08B4:  MOVWF  6A
08B5:  BCF    0A.3
08B6:  CALL   5DB
08B7:  BSF    0A.3
....................       //limpiarPorcion(strlen(temp)*6, 10, 9*6, 7); //Limpiamos la porcion de pantalla que tiene el valor de la temperatura. 
....................       //glcd_text57(strlen(temp)*6, 10, str, 1, ON); //Escribimos la temperatura. 
....................       //nuevaLinea(t[i]); //Dibujamos la nueva linea en el grafico. 
....................       printf("%f\r", t[i]); 
08B8:  RLF    58,W
08B9:  MOVWF  77
08BA:  RLF    77,F
08BB:  MOVLW  FC
08BC:  ANDWF  77,F
08BD:  MOVF   77,W
08BE:  ADDLW  40
08BF:  MOVWF  04
08C0:  BCF    03.7
08C1:  MOVF   00,W
08C2:  MOVWF  59
08C3:  INCF   04,F
08C4:  MOVF   00,W
08C5:  MOVWF  5A
08C6:  INCF   04,F
08C7:  MOVF   00,W
08C8:  MOVWF  5B
08C9:  INCF   04,F
08CA:  MOVF   00,W
08CB:  MOVWF  5C
08CC:  MOVLW  89
08CD:  MOVWF  04
08CE:  MOVF   5C,W
08CF:  MOVWF  60
08D0:  MOVF   5B,W
08D1:  MOVWF  5F
08D2:  MOVF   5A,W
08D3:  MOVWF  5E
08D4:  MOVF   59,W
08D5:  MOVWF  5D
08D6:  MOVLW  02
08D7:  MOVWF  61
08D8:  BCF    0A.3
08D9:  GOTO   6AD
08DA:  BSF    0A.3
08DB:  MOVLW  0D
08DC:  BTFSS  0C.4
08DD:  GOTO   0DC
08DE:  MOVWF  19
....................       //puts(str); 
....................       delay_ms(200); 
08DF:  MOVLW  C8
08E0:  MOVWF  5B
08E1:  BCF    0A.3
08E2:  CALL   776
08E3:  BSF    0A.3
08E4:  INCF   58,F
08E5:  GOTO   084
....................    } 
....................       
....................    while(TRUE){ 
....................       trisb|=0b00000100; 
08E6:  BSF    03.5
08E7:  BSF    06.2
....................       if(kbhit()) { // if data received  
08E8:  BCF    03.5
08E9:  BTFSS  0C.5
08EA:  GOTO   0EE
....................          turn_on_bt(); 
08EB:  BCF    0A.3
08EC:  GOTO   79B
08ED:  BSF    0A.3
....................       } 
08EE:  GOTO   0E6
....................    } 
.................... } 
08EF:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
