CCS PCM C Compiler, Version 5.076, 56587               28-oct.-20 17:38

               Filename:   C:\Users\Francisco\Documents\!Facultad - UF\Electrónica Digital II\Proyecto Final\tp_final_edi2\Codigo\main.lst

               ROM used:   2847 words (35%)
                           Largest free fragment is 2048
               RAM used:   67 (18%) at main() level
                           104 (28%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   255
0003:  NOP
.................... #include <main.h> 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  00
0061:  RETLW  04
0062:  RETLW  02
0063:  RETLW  7F
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
0215:  CLRF   77
0216:  CLRF   78
0217:  MOVF   70,W
0218:  BCF    03.0
0219:  BTFSC  71.0
021A:  ADDWF  77,F
021B:  RRF    77,F
021C:  RRF    78,F
021D:  BTFSC  71.1
021E:  ADDWF  77,F
021F:  RRF    77,F
0220:  RRF    78,F
0221:  BTFSC  71.2
0222:  ADDWF  77,F
0223:  RRF    77,F
0224:  RRF    78,F
0225:  BTFSC  71.3
0226:  ADDWF  77,F
0227:  RRF    77,F
0228:  RRF    78,F
0229:  BTFSC  71.4
022A:  ADDWF  77,F
022B:  RRF    77,F
022C:  RRF    78,F
022D:  BTFSC  71.5
022E:  ADDWF  77,F
022F:  RRF    77,F
0230:  RRF    78,F
0231:  BTFSC  71.6
0232:  ADDWF  77,F
0233:  RRF    77,F
0234:  RRF    78,F
0235:  BTFSC  71.7
0236:  ADDWF  77,F
0237:  RRF    77,F
0238:  RRF    78,F
0239:  RETURN
*
0530:  MOVF   6B,W
0531:  BTFSC  03.2
0532:  GOTO   5BC
0533:  BSF    03.5
0534:  MOVWF  20
0535:  BCF    03.5
0536:  MOVF   6F,W
0537:  BTFSC  03.2
0538:  GOTO   5BC
0539:  BSF    03.5
053A:  ADDWF  20,F
053B:  BTFSC  03.0
053C:  GOTO   548
053D:  MOVLW  7F
053E:  SUBWF  20,F
053F:  BTFSC  03.0
0540:  GOTO   543
0541:  BCF    03.5
0542:  GOTO   5BC
0543:  BTFSS  03.2
0544:  GOTO   547
0545:  BCF    03.5
0546:  GOTO   5BC
0547:  GOTO   54E
0548:  MOVLW  81
0549:  ADDWF  20,F
054A:  BTFSS  03.0
054B:  GOTO   54E
054C:  BCF    03.5
054D:  GOTO   5BC
054E:  MOVF   20,W
054F:  MOVWF  77
0550:  CLRF   78
0551:  CLRF   79
0552:  CLRF   7A
0553:  BCF    03.5
0554:  MOVF   6C,W
0555:  BSF    03.5
0556:  MOVWF  24
0557:  BSF    24.7
0558:  BCF    03.5
0559:  MOVF   6D,W
055A:  BSF    03.5
055B:  MOVWF  23
055C:  BCF    03.5
055D:  MOVF   6E,W
055E:  BSF    03.5
055F:  MOVWF  22
0560:  MOVLW  18
0561:  MOVWF  20
0562:  CLRF   21
0563:  BTFSS  22.0
0564:  GOTO   582
0565:  MOVF   72,W
0566:  ADDWF  7A,F
0567:  BTFSS  03.0
0568:  GOTO   56F
0569:  INCF   79,F
056A:  BTFSS  03.2
056B:  GOTO   56F
056C:  INCF   78,F
056D:  BTFSC  03.2
056E:  BSF    21.7
056F:  MOVF   71,W
0570:  ADDWF  79,F
0571:  BTFSS  03.0
0572:  GOTO   576
0573:  INCF   78,F
0574:  BTFSC  03.2
0575:  BSF    21.7
0576:  MOVF   70,W
0577:  BCF    03.5
0578:  MOVWF  6D
0579:  BSF    6D.7
057A:  MOVF   6D,W
057B:  ADDWF  78,F
057C:  BTFSS  03.0
057D:  GOTO   581
057E:  BSF    03.5
057F:  BSF    21.7
0580:  BCF    03.5
0581:  BSF    03.5
0582:  RLF    21,F
0583:  RRF    78,F
0584:  RRF    79,F
0585:  RRF    7A,F
0586:  RRF    24,F
0587:  RRF    23,F
0588:  RRF    22,F
0589:  BCF    03.0
058A:  DECFSZ 20,F
058B:  GOTO   562
058C:  MOVLW  01
058D:  ADDWF  77,F
058E:  BTFSS  03.0
058F:  GOTO   592
0590:  BCF    03.5
0591:  GOTO   5BC
0592:  BTFSC  78.7
0593:  GOTO   59C
0594:  RLF    24,F
0595:  RLF    7A,F
0596:  RLF    79,F
0597:  RLF    78,F
0598:  DECFSZ 77,F
0599:  GOTO   59C
059A:  BCF    03.5
059B:  GOTO   5BC
059C:  BTFSS  24.7
059D:  GOTO   5AF
059E:  INCF   7A,F
059F:  BTFSS  03.2
05A0:  GOTO   5AF
05A1:  INCF   79,F
05A2:  BTFSS  03.2
05A3:  GOTO   5AF
05A4:  INCF   78,F
05A5:  BTFSS  03.2
05A6:  GOTO   5AF
05A7:  RRF    78,F
05A8:  RRF    79,F
05A9:  RRF    7A,F
05AA:  INCF   77,F
05AB:  BTFSS  03.2
05AC:  GOTO   5AF
05AD:  BCF    03.5
05AE:  GOTO   5BC
05AF:  BCF    03.5
05B0:  MOVF   6C,W
05B1:  BSF    03.5
05B2:  MOVWF  21
05B3:  MOVF   70,W
05B4:  XORWF  21,F
05B5:  BTFSS  21.7
05B6:  GOTO   5B9
05B7:  BSF    78.7
05B8:  GOTO   5C1
05B9:  BCF    78.7
05BA:  GOTO   5C1
05BB:  BCF    03.5
05BC:  CLRF   77
05BD:  CLRF   78
05BE:  CLRF   79
05BF:  CLRF   7A
05C0:  BSF    03.5
05C1:  BCF    03.5
05C2:  RETURN
05C3:  BTFSC  03.1
05C4:  GOTO   5C8
05C5:  MOVLW  A0
05C6:  MOVWF  04
05C7:  BCF    03.7
05C8:  CLRF   77
05C9:  CLRF   78
05CA:  CLRF   79
05CB:  CLRF   7A
05CC:  BSF    03.5
05CD:  CLRF   20
05CE:  CLRF   21
05CF:  CLRF   22
05D0:  CLRF   23
05D1:  MOVF   72,W
05D2:  IORWF  71,W
05D3:  IORWF  70,W
05D4:  BCF    03.5
05D5:  IORWF  6F,W
05D6:  BTFSC  03.2
05D7:  GOTO   610
05D8:  MOVLW  20
05D9:  BSF    03.5
05DA:  MOVWF  24
05DB:  BCF    03.0
05DC:  BCF    03.5
05DD:  RLF    6B,F
05DE:  RLF    6C,F
05DF:  RLF    6D,F
05E0:  RLF    6E,F
05E1:  BSF    03.5
05E2:  RLF    20,F
05E3:  RLF    21,F
05E4:  RLF    22,F
05E5:  RLF    23,F
05E6:  MOVF   72,W
05E7:  SUBWF  23,W
05E8:  BTFSS  03.2
05E9:  GOTO   5F6
05EA:  MOVF   71,W
05EB:  SUBWF  22,W
05EC:  BTFSS  03.2
05ED:  GOTO   5F6
05EE:  MOVF   70,W
05EF:  SUBWF  21,W
05F0:  BTFSS  03.2
05F1:  GOTO   5F6
05F2:  BCF    03.5
05F3:  MOVF   6F,W
05F4:  BSF    03.5
05F5:  SUBWF  20,W
05F6:  BTFSS  03.0
05F7:  GOTO   609
05F8:  BCF    03.5
05F9:  MOVF   6F,W
05FA:  BSF    03.5
05FB:  SUBWF  20,F
05FC:  MOVF   70,W
05FD:  BTFSS  03.0
05FE:  INCFSZ 70,W
05FF:  SUBWF  21,F
0600:  MOVF   71,W
0601:  BTFSS  03.0
0602:  INCFSZ 71,W
0603:  SUBWF  22,F
0604:  MOVF   72,W
0605:  BTFSS  03.0
0606:  INCFSZ 72,W
0607:  SUBWF  23,F
0608:  BSF    03.0
0609:  RLF    77,F
060A:  RLF    78,F
060B:  RLF    79,F
060C:  RLF    7A,F
060D:  DECFSZ 24,F
060E:  GOTO   5DB
060F:  BCF    03.5
0610:  BSF    03.5
0611:  MOVF   20,W
0612:  MOVWF  00
0613:  INCF   04,F
0614:  MOVF   21,W
0615:  MOVWF  00
0616:  INCF   04,F
0617:  MOVF   22,W
0618:  MOVWF  00
0619:  INCF   04,F
061A:  MOVF   23,W
061B:  MOVWF  00
061C:  BCF    03.5
061D:  RETURN
061E:  MOVF   27,W
061F:  MOVWF  04
0620:  BCF    03.7
0621:  BTFSC  28.0
0622:  BSF    03.7
0623:  MOVF   6B,W
0624:  MOVWF  00
0625:  INCF   04,F
0626:  CLRF   00
0627:  INCF   27,F
0628:  BTFSC  03.2
0629:  INCF   28,F
062A:  RETURN
062B:  MOVF   04,W
062C:  MOVWF  63
062D:  MOVF   62,W
062E:  MOVWF  65
062F:  BTFSC  03.2
0630:  GOTO   64A
0631:  MOVF   61,W
0632:  MOVWF  6E
0633:  MOVF   60,W
0634:  MOVWF  6D
0635:  MOVF   5F,W
0636:  MOVWF  6C
0637:  MOVF   5E,W
0638:  MOVWF  6B
0639:  CLRF   72
063A:  CLRF   71
063B:  MOVLW  20
063C:  MOVWF  70
063D:  MOVLW  82
063E:  MOVWF  6F
063F:  CALL   530
0640:  MOVF   7A,W
0641:  MOVWF  61
0642:  MOVF   79,W
0643:  MOVWF  60
0644:  MOVF   78,W
0645:  MOVWF  5F
0646:  MOVF   77,W
0647:  MOVWF  5E
0648:  DECFSZ 65,F
0649:  GOTO   631
064A:  MOVF   61,W
064B:  MOVWF  6E
064C:  MOVF   60,W
064D:  MOVWF  6D
064E:  MOVF   5F,W
064F:  MOVWF  6C
0650:  MOVF   5E,W
0651:  MOVWF  6B
0652:  MOVF   6B,W
0653:  SUBLW  B6
0654:  MOVWF  6B
0655:  CLRF   7A
0656:  MOVF   6C,W
0657:  MOVWF  6F
0658:  BSF    6C.7
0659:  BCF    03.0
065A:  RRF    6C,F
065B:  RRF    6D,F
065C:  RRF    6E,F
065D:  RRF    7A,F
065E:  RRF    79,F
065F:  RRF    78,F
0660:  RRF    77,F
0661:  DECFSZ 6B,F
0662:  GOTO   659
0663:  BTFSS  6F.7
0664:  GOTO   670
0665:  COMF   77,F
0666:  COMF   78,F
0667:  COMF   79,F
0668:  COMF   7A,F
0669:  INCF   77,F
066A:  BTFSC  03.2
066B:  INCF   78,F
066C:  BTFSC  03.2
066D:  INCF   79,F
066E:  BTFSC  03.2
066F:  INCF   7A,F
0670:  MOVF   7A,W
0671:  MOVWF  61
0672:  MOVF   79,W
0673:  MOVWF  60
0674:  MOVF   78,W
0675:  MOVWF  5F
0676:  MOVF   77,W
0677:  MOVWF  5E
0678:  BTFSS  61.7
0679:  GOTO   687
067A:  DECF   63,F
067B:  BSF    63.5
067C:  COMF   5E,F
067D:  COMF   5F,F
067E:  COMF   60,F
067F:  COMF   61,F
0680:  INCF   5E,F
0681:  BTFSC  03.2
0682:  INCF   5F,F
0683:  BTFSC  03.2
0684:  INCF   60,F
0685:  BTFSC  03.2
0686:  INCF   61,F
0687:  MOVLW  3B
0688:  MOVWF  6A
0689:  MOVLW  9A
068A:  MOVWF  69
068B:  MOVLW  CA
068C:  MOVWF  68
068D:  CLRF   67
068E:  MOVLW  0A
068F:  MOVWF  65
0690:  MOVF   62,W
0691:  BTFSC  03.2
0692:  INCF   63,F
0693:  BSF    03.1
0694:  MOVLW  5E
0695:  MOVWF  04
0696:  BCF    03.7
0697:  MOVF   61,W
0698:  MOVWF  6E
0699:  MOVF   60,W
069A:  MOVWF  6D
069B:  MOVF   5F,W
069C:  MOVWF  6C
069D:  MOVF   5E,W
069E:  MOVWF  6B
069F:  MOVF   6A,W
06A0:  MOVWF  72
06A1:  MOVF   69,W
06A2:  MOVWF  71
06A3:  MOVF   68,W
06A4:  MOVWF  70
06A5:  MOVF   67,W
06A6:  MOVWF  6F
06A7:  CALL   5C3
06A8:  MOVF   78,W
06A9:  MOVF   77,F
06AA:  BTFSS  03.2
06AB:  GOTO   6BF
06AC:  INCF   62,W
06AD:  SUBWF  65,W
06AE:  BTFSC  03.2
06AF:  GOTO   6BF
06B0:  MOVF   63,W
06B1:  BTFSC  03.2
06B2:  GOTO   6C1
06B3:  ANDLW  0F
06B4:  SUBWF  65,W
06B5:  BTFSC  03.2
06B6:  GOTO   6B9
06B7:  BTFSC  03.0
06B8:  GOTO   6F1
06B9:  BTFSC  63.7
06BA:  GOTO   6F1
06BB:  BTFSC  63.6
06BC:  GOTO   6C1
06BD:  MOVLW  20
06BE:  GOTO   6ED
06BF:  MOVLW  20
06C0:  ANDWF  63,F
06C1:  BTFSS  63.5
06C2:  GOTO   6CF
06C3:  BCF    63.5
06C4:  MOVF   62,W
06C5:  BTFSS  03.2
06C6:  DECF   63,F
06C7:  MOVF   77,W
06C8:  MOVWF  63
06C9:  MOVLW  2D
06CA:  MOVWF  6B
06CB:  CALL   61E
06CC:  MOVF   63,W
06CD:  MOVWF  77
06CE:  CLRF   63
06CF:  MOVF   62,W
06D0:  SUBWF  65,W
06D1:  BTFSS  03.2
06D2:  GOTO   6DD
06D3:  MOVF   77,W
06D4:  MOVWF  63
06D5:  MOVLW  2E
06D6:  MOVWF  6B
06D7:  CALL   61E
06D8:  MOVF   63,W
06D9:  MOVWF  77
06DA:  MOVLW  20
06DB:  ANDWF  63,F
06DC:  MOVLW  00
06DD:  MOVLW  30
06DE:  BTFSS  63.5
06DF:  GOTO   6ED
06E0:  BCF    63.5
06E1:  MOVF   62,W
06E2:  BTFSS  03.2
06E3:  DECF   63,F
06E4:  MOVF   77,W
06E5:  MOVWF  63
06E6:  MOVLW  2D
06E7:  MOVWF  6B
06E8:  CALL   61E
06E9:  MOVF   63,W
06EA:  MOVWF  77
06EB:  CLRF   63
06EC:  MOVLW  30
06ED:  ADDWF  77,F
06EE:  MOVF   77,W
06EF:  MOVWF  6B
06F0:  CALL   61E
06F1:  BCF    03.1
06F2:  MOVF   6A,W
06F3:  MOVWF  6E
06F4:  MOVF   69,W
06F5:  MOVWF  6D
06F6:  MOVF   68,W
06F7:  MOVWF  6C
06F8:  MOVF   67,W
06F9:  MOVWF  6B
06FA:  CLRF   72
06FB:  CLRF   71
06FC:  CLRF   70
06FD:  MOVLW  0A
06FE:  MOVWF  6F
06FF:  CALL   5C3
0700:  MOVF   7A,W
0701:  MOVWF  6A
0702:  MOVF   79,W
0703:  MOVWF  69
0704:  MOVF   78,W
0705:  MOVWF  68
0706:  MOVF   77,W
0707:  MOVWF  67
0708:  DECFSZ 65,F
0709:  GOTO   693
070A:  BSF    0A.3
070B:  BCF    0A.4
070C:  GOTO   2FB (RETURN)
*
0744:  MOVLW  8E
0745:  MOVWF  77
0746:  MOVF   69,W
0747:  MOVWF  78
0748:  MOVF   68,W
0749:  MOVWF  79
074A:  CLRF   7A
074B:  MOVF   78,F
074C:  BTFSS  03.2
074D:  GOTO   758
074E:  MOVF   79,W
074F:  MOVWF  78
0750:  CLRF   79
0751:  MOVLW  08
0752:  SUBWF  77,F
0753:  MOVF   78,F
0754:  BTFSS  03.2
0755:  GOTO   758
0756:  CLRF   77
0757:  GOTO   760
0758:  BCF    03.0
0759:  BTFSC  78.7
075A:  GOTO   75F
075B:  RLF    79,F
075C:  RLF    78,F
075D:  DECF   77,F
075E:  GOTO   758
075F:  BCF    78.7
0760:  RETURN
0761:  MOVLW  8E
0762:  MOVWF  77
0763:  MOVF   64,W
0764:  SUBWF  77,F
0765:  MOVF   65,W
0766:  MOVWF  79
0767:  MOVF   66,W
0768:  MOVWF  78
0769:  BSF    79.7
076A:  MOVF   77,F
076B:  BTFSC  03.2
076C:  GOTO   778
076D:  BCF    03.0
076E:  MOVF   79,F
076F:  BTFSS  03.2
0770:  GOTO   774
0771:  MOVF   78,F
0772:  BTFSC  03.2
0773:  GOTO   778
0774:  RRF    79,F
0775:  RRF    78,F
0776:  DECFSZ 77,F
0777:  GOTO   76D
0778:  BTFSS  65.7
0779:  GOTO   77F
077A:  COMF   78,F
077B:  COMF   79,F
077C:  INCF   78,F
077D:  BTFSC  03.2
077E:  INCF   79,F
077F:  RETURN
*
0800:  MOVLW  80
0801:  BTFSC  03.1
0802:  XORWF  6D,F
0803:  BSF    03.5
0804:  CLRF   22
0805:  CLRF   23
0806:  BCF    03.5
0807:  MOVF   69,W
0808:  BSF    03.5
0809:  MOVWF  21
080A:  BCF    03.5
080B:  MOVF   6D,W
080C:  BSF    03.5
080D:  XORWF  21,F
080E:  BCF    03.5
080F:  MOVF   68,W
0810:  BTFSC  03.2
0811:  GOTO   11B
0812:  BSF    03.5
0813:  MOVWF  20
0814:  MOVWF  77
0815:  BCF    03.5
0816:  MOVF   6C,W
0817:  BTFSC  03.2
0818:  GOTO   12A
0819:  BSF    03.5
081A:  SUBWF  20,F
081B:  BTFSC  03.2
081C:  GOTO   0B3
081D:  BTFSC  03.0
081E:  GOTO   020
081F:  GOTO   065
0820:  BCF    03.5
0821:  MOVF   6D,W
0822:  BSF    03.5
0823:  MOVWF  26
0824:  BSF    26.7
0825:  BCF    03.5
0826:  MOVF   6E,W
0827:  BSF    03.5
0828:  MOVWF  25
0829:  BCF    03.5
082A:  MOVF   6F,W
082B:  BSF    03.5
082C:  MOVWF  24
082D:  CLRF   23
082E:  BCF    03.0
082F:  RRF    26,F
0830:  RRF    25,F
0831:  RRF    24,F
0832:  RRF    23,F
0833:  DECFSZ 20,F
0834:  GOTO   02D
0835:  BTFSS  21.7
0836:  GOTO   03A
0837:  BSF    22.0
0838:  GOTO   143
0839:  BCF    22.0
083A:  BCF    20.0
083B:  BSF    22.4
083C:  MOVLW  6B
083D:  MOVWF  04
083E:  BCF    03.7
083F:  GOTO   159
0840:  BCF    22.4
0841:  BTFSC  21.7
0842:  GOTO   04D
0843:  BTFSS  20.0
0844:  GOTO   058
0845:  RRF    26,F
0846:  RRF    25,F
0847:  RRF    24,F
0848:  RRF    23,F
0849:  INCF   77,F
084A:  BTFSC  03.2
084B:  GOTO   13E
084C:  GOTO   058
084D:  BTFSC  26.7
084E:  GOTO   05B
084F:  BCF    03.0
0850:  RLF    23,F
0851:  RLF    24,F
0852:  RLF    25,F
0853:  RLF    26,F
0854:  DECF   77,F
0855:  BTFSC  03.2
0856:  GOTO   13E
0857:  GOTO   04D
0858:  BSF    22.6
0859:  GOTO   0DB
085A:  BCF    22.6
085B:  BCF    03.5
085C:  MOVF   69,W
085D:  BSF    03.5
085E:  MOVWF  21
085F:  BTFSS  21.7
0860:  GOTO   063
0861:  BSF    26.7
0862:  GOTO   137
0863:  BCF    26.7
0864:  GOTO   137
0865:  BCF    03.5
0866:  MOVF   6C,W
0867:  BSF    03.5
0868:  MOVWF  20
0869:  MOVWF  77
086A:  BCF    03.5
086B:  MOVF   68,W
086C:  BSF    03.5
086D:  SUBWF  20,F
086E:  BCF    03.5
086F:  MOVF   69,W
0870:  BSF    03.5
0871:  MOVWF  26
0872:  BSF    26.7
0873:  BCF    03.5
0874:  MOVF   6A,W
0875:  BSF    03.5
0876:  MOVWF  25
0877:  BCF    03.5
0878:  MOVF   6B,W
0879:  BSF    03.5
087A:  MOVWF  24
087B:  CLRF   23
087C:  BCF    03.0
087D:  RRF    26,F
087E:  RRF    25,F
087F:  RRF    24,F
0880:  RRF    23,F
0881:  DECFSZ 20,F
0882:  GOTO   07B
0883:  BTFSS  21.7
0884:  GOTO   088
0885:  BSF    22.1
0886:  GOTO   143
0887:  BCF    22.1
0888:  BCF    20.0
0889:  BSF    22.5
088A:  MOVLW  6F
088B:  MOVWF  04
088C:  BCF    03.7
088D:  GOTO   159
088E:  BCF    22.5
088F:  BTFSC  21.7
0890:  GOTO   09B
0891:  BTFSS  20.0
0892:  GOTO   0A6
0893:  RRF    26,F
0894:  RRF    25,F
0895:  RRF    24,F
0896:  RRF    23,F
0897:  INCF   77,F
0898:  BTFSC  03.2
0899:  GOTO   13E
089A:  GOTO   0A6
089B:  BTFSC  26.7
089C:  GOTO   0A9
089D:  BCF    03.0
089E:  RLF    23,F
089F:  RLF    24,F
08A0:  RLF    25,F
08A1:  RLF    26,F
08A2:  DECF   77,F
08A3:  BTFSC  03.2
08A4:  GOTO   13E
08A5:  GOTO   09B
08A6:  BSF    22.7
08A7:  GOTO   0DB
08A8:  BCF    22.7
08A9:  BCF    03.5
08AA:  MOVF   6D,W
08AB:  BSF    03.5
08AC:  MOVWF  21
08AD:  BTFSS  21.7
08AE:  GOTO   0B1
08AF:  BSF    26.7
08B0:  GOTO   137
08B1:  BCF    26.7
08B2:  GOTO   137
08B3:  BCF    03.5
08B4:  MOVF   6D,W
08B5:  BSF    03.5
08B6:  MOVWF  26
08B7:  BSF    26.7
08B8:  BCF    03.5
08B9:  MOVF   6E,W
08BA:  BSF    03.5
08BB:  MOVWF  25
08BC:  BCF    03.5
08BD:  MOVF   6F,W
08BE:  BSF    03.5
08BF:  MOVWF  24
08C0:  BTFSS  21.7
08C1:  GOTO   0C6
08C2:  BCF    26.7
08C3:  BSF    22.2
08C4:  GOTO   143
08C5:  BCF    22.2
08C6:  CLRF   23
08C7:  BCF    20.0
08C8:  MOVLW  6B
08C9:  MOVWF  04
08CA:  BCF    03.7
08CB:  GOTO   159
08CC:  BTFSC  21.7
08CD:  GOTO   0F1
08CE:  BCF    03.5
08CF:  MOVF   69,W
08D0:  BSF    03.5
08D1:  MOVWF  21
08D2:  BTFSS  20.0
08D3:  GOTO   0DB
08D4:  RRF    26,F
08D5:  RRF    25,F
08D6:  RRF    24,F
08D7:  RRF    23,F
08D8:  INCF   77,F
08D9:  BTFSC  03.2
08DA:  GOTO   13E
08DB:  BTFSS  23.7
08DC:  GOTO   0EC
08DD:  INCF   24,F
08DE:  BTFSS  03.2
08DF:  GOTO   0EC
08E0:  INCF   25,F
08E1:  BTFSS  03.2
08E2:  GOTO   0EC
08E3:  INCF   26,F
08E4:  BTFSS  03.2
08E5:  GOTO   0EC
08E6:  RRF    26,F
08E7:  RRF    25,F
08E8:  RRF    24,F
08E9:  INCF   77,F
08EA:  BTFSC  03.2
08EB:  GOTO   13E
08EC:  BTFSC  22.6
08ED:  GOTO   05A
08EE:  BTFSC  22.7
08EF:  GOTO   0A8
08F0:  GOTO   114
08F1:  MOVLW  80
08F2:  XORWF  26,F
08F3:  BTFSS  26.7
08F4:  GOTO   0FB
08F5:  GOTO   143
08F6:  BCF    03.5
08F7:  MOVF   6D,W
08F8:  BSF    03.5
08F9:  MOVWF  21
08FA:  GOTO   10A
08FB:  BCF    03.5
08FC:  MOVF   69,W
08FD:  BSF    03.5
08FE:  MOVWF  21
08FF:  MOVF   26,F
0900:  BTFSS  03.2
0901:  GOTO   10A
0902:  MOVF   25,F
0903:  BTFSS  03.2
0904:  GOTO   10A
0905:  MOVF   24,F
0906:  BTFSS  03.2
0907:  GOTO   10A
0908:  CLRF   77
0909:  GOTO   137
090A:  BTFSC  26.7
090B:  GOTO   114
090C:  BCF    03.0
090D:  RLF    23,F
090E:  RLF    24,F
090F:  RLF    25,F
0910:  RLF    26,F
0911:  DECFSZ 77,F
0912:  GOTO   10A
0913:  GOTO   13E
0914:  BTFSS  21.7
0915:  GOTO   118
0916:  BSF    26.7
0917:  GOTO   137
0918:  BCF    26.7
0919:  GOTO   137
091A:  BCF    03.5
091B:  MOVF   6C,W
091C:  MOVWF  77
091D:  MOVF   6D,W
091E:  BSF    03.5
091F:  MOVWF  26
0920:  BCF    03.5
0921:  MOVF   6E,W
0922:  BSF    03.5
0923:  MOVWF  25
0924:  BCF    03.5
0925:  MOVF   6F,W
0926:  BSF    03.5
0927:  MOVWF  24
0928:  GOTO   137
0929:  BCF    03.5
092A:  MOVF   68,W
092B:  MOVWF  77
092C:  MOVF   69,W
092D:  BSF    03.5
092E:  MOVWF  26
092F:  BCF    03.5
0930:  MOVF   6A,W
0931:  BSF    03.5
0932:  MOVWF  25
0933:  BCF    03.5
0934:  MOVF   6B,W
0935:  BSF    03.5
0936:  MOVWF  24
0937:  MOVF   26,W
0938:  MOVWF  78
0939:  MOVF   25,W
093A:  MOVWF  79
093B:  MOVF   24,W
093C:  MOVWF  7A
093D:  GOTO   178
093E:  CLRF   77
093F:  CLRF   78
0940:  CLRF   79
0941:  CLRF   7A
0942:  GOTO   178
0943:  CLRF   23
0944:  COMF   24,F
0945:  COMF   25,F
0946:  COMF   26,F
0947:  COMF   23,F
0948:  INCF   23,F
0949:  BTFSS  03.2
094A:  GOTO   152
094B:  INCF   24,F
094C:  BTFSS  03.2
094D:  GOTO   152
094E:  INCF   25,F
094F:  BTFSS  03.2
0950:  GOTO   152
0951:  INCF   26,F
0952:  BTFSC  22.0
0953:  GOTO   039
0954:  BTFSC  22.1
0955:  GOTO   087
0956:  BTFSC  22.2
0957:  GOTO   0C5
0958:  GOTO   0F6
0959:  MOVF   00,W
095A:  ADDWF  24,F
095B:  BTFSS  03.0
095C:  GOTO   163
095D:  INCF   25,F
095E:  BTFSS  03.2
095F:  GOTO   163
0960:  INCF   26,F
0961:  BTFSC  03.2
0962:  BSF    20.0
0963:  DECF   04,F
0964:  MOVF   00,W
0965:  ADDWF  25,F
0966:  BTFSS  03.0
0967:  GOTO   16B
0968:  INCF   26,F
0969:  BTFSC  03.2
096A:  BSF    20.0
096B:  DECF   04,F
096C:  MOVF   00,W
096D:  BTFSC  00.7
096E:  GOTO   170
096F:  XORLW  80
0970:  ADDWF  26,F
0971:  BTFSC  03.0
0972:  BSF    20.0
0973:  BTFSC  22.4
0974:  GOTO   040
0975:  BTFSC  22.5
0976:  GOTO   08E
0977:  GOTO   0CC
0978:  BCF    03.5
0979:  RETURN
*
0992:  MOVLW  8E
0993:  MOVWF  77
0994:  MOVF   64,W
0995:  MOVWF  78
0996:  MOVF   63,W
0997:  MOVWF  79
0998:  CLRF   7A
0999:  BTFSS  64.7
099A:  GOTO   1A0
099B:  COMF   78,F
099C:  COMF   79,F
099D:  INCF   79,F
099E:  BTFSC  03.2
099F:  INCF   78,F
09A0:  MOVF   78,F
09A1:  BTFSS  03.2
09A2:  GOTO   1AD
09A3:  MOVF   79,W
09A4:  MOVWF  78
09A5:  CLRF   79
09A6:  MOVLW  08
09A7:  SUBWF  77,F
09A8:  MOVF   78,F
09A9:  BTFSS  03.2
09AA:  GOTO   1AD
09AB:  CLRF   77
09AC:  GOTO   1B6
09AD:  BCF    03.0
09AE:  BTFSC  78.7
09AF:  GOTO   1B4
09B0:  RLF    79,F
09B1:  RLF    78,F
09B2:  DECF   77,F
09B3:  GOTO   1AD
09B4:  BTFSS  64.7
09B5:  BCF    78.7
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=8000000) 
*
0780:  MOVLW  5B
0781:  MOVWF  04
0782:  BCF    03.7
0783:  MOVF   00,W
0784:  BTFSC  03.2
0785:  GOTO   793
0786:  MOVLW  02
0787:  MOVWF  78
0788:  CLRF   77
0789:  DECFSZ 77,F
078A:  GOTO   789
078B:  DECFSZ 78,F
078C:  GOTO   788
078D:  MOVLW  97
078E:  MOVWF  77
078F:  DECFSZ 77,F
0790:  GOTO   78F
0791:  DECFSZ 00,F
0792:  GOTO   786
0793:  RETURN
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
070D:  MOVF   5B,W
070E:  MOVWF  5D
070F:  MOVF   5A,W
0710:  MOVWF  5C
0711:  MOVF   5D,W
0712:  MOVWF  7A
0713:  MOVF   5C,W
0714:  MOVWF  04
0715:  BCF    03.7
0716:  BTFSC  7A.0
0717:  BSF    03.7
0718:  MOVF   00,F
0719:  BTFSC  03.2
071A:  GOTO   71F
071B:  INCF   5C,F
071C:  BTFSC  03.2
071D:  INCF   5D,F
071E:  GOTO   711
....................    return(sc - s); 
071F:  MOVF   5A,W
0720:  SUBWF  5C,W
0721:  MOVWF  77
0722:  MOVF   5D,W
0723:  MOVWF  7A
0724:  MOVF   5B,W
0725:  BTFSS  03.0
0726:  INCFSZ 5B,W
0727:  SUBWF  7A,F
0728:  MOVF   77,W
0729:  MOVWF  78
072A:  RETURN
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0A67:  BCF    03.5
0A68:  CLRF   20
0A69:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses XT 
.................... #include <HDM64GS12.c> //Manejo del display gráfico 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
023A:  BCF    22.0
023B:  MOVF   22,W
023C:  BSF    03.5
023D:  MOVWF  07
023E:  BCF    03.5
023F:  BSF    07.0
....................    output_low(GLCD_E); 
0240:  BSF    03.5
0241:  BCF    06.5
0242:  BCF    03.5
0243:  BCF    06.5
....................    output_low(GLCD_CS1); 
0244:  BSF    03.5
0245:  BCF    06.0
0246:  BCF    03.5
0247:  BCF    06.0
....................    output_low(GLCD_CS2); 
0248:  BSF    03.5
0249:  BCF    06.1
024A:  BCF    03.5
024B:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
024C:  BSF    03.5
024D:  BCF    06.2
024E:  BCF    03.5
024F:  BCF    06.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
0250:  BSF    03.5
0251:  CLRF   22
0252:  MOVLW  C0
0253:  MOVWF  23
0254:  BCF    03.5
0255:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
0256:  MOVLW  01
0257:  BSF    03.5
0258:  MOVWF  22
0259:  MOVLW  C0
025A:  MOVWF  23
025B:  BCF    03.5
025C:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
025D:  BSF    03.5
025E:  CLRF   22
025F:  MOVLW  40
0260:  MOVWF  23
0261:  BCF    03.5
0262:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
0263:  MOVLW  01
0264:  BSF    03.5
0265:  MOVWF  22
0266:  MOVLW  40
0267:  MOVWF  23
0268:  BCF    03.5
0269:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
026A:  BSF    03.5
026B:  CLRF   22
026C:  MOVLW  B8
026D:  MOVWF  23
026E:  BCF    03.5
026F:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
0270:  MOVLW  01
0271:  BSF    03.5
0272:  MOVWF  22
0273:  MOVLW  B8
0274:  MOVWF  23
0275:  BCF    03.5
0276:  CALL   1EA
....................  
....................    if(mode == ON) 
0277:  DECFSZ 5A,W
0278:  GOTO   287
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
0279:  BSF    03.5
027A:  CLRF   22
027B:  MOVLW  3F
027C:  MOVWF  23
027D:  BCF    03.5
027E:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
027F:  MOVLW  01
0280:  BSF    03.5
0281:  MOVWF  22
0282:  MOVLW  3F
0283:  MOVWF  23
0284:  BCF    03.5
0285:  CALL   1EA
....................    } 
0286:  GOTO   294
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
0287:  BSF    03.5
0288:  CLRF   22
0289:  MOVLW  3E
028A:  MOVWF  23
028B:  BCF    03.5
028C:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
028D:  MOVLW  01
028E:  BSF    03.5
028F:  MOVWF  22
0290:  MOVLW  3E
0291:  MOVWF  23
0292:  BCF    03.5
0293:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
0294:  CLRF   5B
....................  
....................    #ifdef FAST_GLCD 
*
02EE:  BSF    0A.3
02EF:  BCF    0A.4
02F0:  GOTO   2AC (RETURN)
....................    glcd_update(); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
*
0320:  BCF    7D.0
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
0321:  MOVF   75,W
0322:  SUBLW  3F
0323:  BTFSC  03.0
0324:  GOTO   328
....................    { 
....................       x -= 64; 
0325:  MOVLW  40
0326:  SUBWF  75,F
....................       side = GLCD_RIGHT; 
0327:  BSF    7D.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
0328:  BSF    03.5
0329:  BCF    06.2
032A:  BCF    03.5
032B:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
032C:  BCF    75.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
032D:  BSF    75.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
032E:  MOVLW  00
032F:  BTFSC  7D.0
0330:  MOVLW  01
0331:  BSF    03.5
0332:  MOVWF  20
0333:  MOVWF  22
0334:  MOVF   75,W
0335:  MOVWF  23
0336:  BCF    03.5
0337:  CALL   1EA
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
0338:  MOVLW  00
0339:  BTFSC  7D.0
033A:  MOVLW  01
033B:  BSF    03.5
033C:  MOVWF  20
033D:  RRF    76,W
033E:  MOVWF  77
033F:  RRF    77,F
0340:  RRF    77,F
0341:  MOVLW  1F
0342:  ANDWF  77,F
0343:  MOVF   77,W
0344:  ANDLW  BF
0345:  IORLW  B8
0346:  MOVWF  21
0347:  MOVF   20,W
0348:  MOVWF  22
0349:  MOVF   21,W
034A:  MOVWF  23
034B:  BCF    03.5
034C:  CALL   1EA
....................    output_high(GLCD_DI);                        // Set for data 
034D:  BSF    03.5
034E:  BCF    06.2
034F:  BCF    03.5
0350:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
0351:  MOVLW  00
0352:  BTFSC  7D.0
0353:  MOVLW  01
0354:  BSF    03.5
0355:  MOVWF  20
0356:  MOVWF  21
0357:  BCF    03.5
0358:  CALL   2F1
....................    data = glcd_readByte(side);                  //  at new address 
0359:  MOVLW  00
035A:  BTFSC  7D.0
035B:  MOVLW  01
035C:  BSF    03.5
035D:  MOVWF  20
035E:  MOVWF  21
035F:  BCF    03.5
0360:  CALL   2F1
0361:  MOVF   78,W
0362:  MOVWF  7C
....................  
....................    if(color == ON) 
0363:  DECFSZ 7B,W
0364:  GOTO   377
....................       bit_set(data, y%8);        // Turn the pixel on 
0365:  MOVF   76,W
0366:  ANDLW  07
0367:  BSF    03.5
0368:  MOVWF  20
0369:  MOVLW  01
036A:  MOVWF  77
036B:  MOVF   20,W
036C:  MOVWF  78
036D:  BTFSC  03.2
036E:  GOTO   373
036F:  BCF    03.0
0370:  RLF    77,F
0371:  DECFSZ 78,F
0372:  GOTO   36F
0373:  MOVF   77,W
0374:  IORWF  7C,F
0375:  GOTO   388
0376:  BCF    03.5
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
0377:  MOVF   76,W
0378:  ANDLW  07
0379:  BSF    03.5
037A:  MOVWF  20
037B:  MOVLW  01
037C:  MOVWF  77
037D:  MOVF   20,W
037E:  MOVWF  78
037F:  BTFSC  03.2
0380:  GOTO   385
0381:  BCF    03.0
0382:  RLF    77,F
0383:  DECFSZ 78,F
0384:  GOTO   381
0385:  MOVF   77,W
0386:  XORLW  FF
0387:  ANDWF  7C,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
0388:  BCF    06.2
0389:  BCF    03.5
038A:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
038B:  MOVLW  00
038C:  BTFSC  7D.0
038D:  MOVLW  01
038E:  BSF    03.5
038F:  MOVWF  20
0390:  MOVWF  22
0391:  MOVF   75,W
0392:  MOVWF  23
0393:  BCF    03.5
0394:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
0395:  BSF    03.5
0396:  BCF    06.2
0397:  BCF    03.5
0398:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
0399:  MOVLW  00
039A:  BTFSC  7D.0
039B:  MOVLW  01
039C:  BSF    03.5
039D:  MOVWF  20
039E:  MOVWF  22
039F:  MOVF   7C,W
03A0:  MOVWF  23
03A1:  BCF    03.5
03A2:  CALL   1EA
03A3:  RETURN
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0295:  CLRF   5C
0296:  MOVF   5C,W
0297:  SUBLW  07
0298:  BTFSS  03.0
0299:  GOTO   2EE
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
029A:  BSF    03.5
029B:  BCF    06.2
029C:  BCF    03.5
029D:  BCF    06.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
029E:  BSF    03.5
029F:  CLRF   22
02A0:  MOVLW  40
02A1:  MOVWF  23
02A2:  BCF    03.5
02A3:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
02A4:  MOVLW  01
02A5:  BSF    03.5
02A6:  MOVWF  22
02A7:  MOVLW  40
02A8:  MOVWF  23
02A9:  BCF    03.5
02AA:  CALL   1EA
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
02AB:  MOVF   5C,W
02AC:  IORLW  B8
02AD:  MOVWF  5E
02AE:  BSF    03.5
02AF:  CLRF   22
02B0:  BCF    03.5
02B1:  MOVF   5E,W
02B2:  BSF    03.5
02B3:  MOVWF  23
02B4:  BCF    03.5
02B5:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
02B6:  MOVF   5C,W
02B7:  IORLW  B8
02B8:  MOVWF  5E
02B9:  MOVLW  01
02BA:  BSF    03.5
02BB:  MOVWF  22
02BC:  BCF    03.5
02BD:  MOVF   5E,W
02BE:  BSF    03.5
02BF:  MOVWF  23
02C0:  BCF    03.5
02C1:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
02C2:  BSF    03.5
02C3:  BCF    06.2
02C4:  BCF    03.5
02C5:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02C6:  CLRF   5D
02C7:  MOVF   5D,W
02C8:  SUBLW  3F
02C9:  BTFSS  03.0
02CA:  GOTO   2EC
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
02CB:  MOVLW  FF
02CC:  MOVWF  70
02CD:  MOVF   5B,W
02CE:  MOVWF  71
02CF:  CALL   215
02D0:  MOVF   78,W
02D1:  MOVWF  5E
02D2:  BSF    03.5
02D3:  CLRF   22
02D4:  BCF    03.5
02D5:  MOVF   78,W
02D6:  BSF    03.5
02D7:  MOVWF  23
02D8:  BCF    03.5
02D9:  CALL   1EA
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
02DA:  MOVLW  FF
02DB:  MOVWF  70
02DC:  MOVF   5B,W
02DD:  MOVWF  71
02DE:  CALL   215
02DF:  MOVF   78,W
02E0:  MOVWF  5E
02E1:  MOVLW  01
02E2:  BSF    03.5
02E3:  MOVWF  22
02E4:  BCF    03.5
02E5:  MOVF   78,W
02E6:  BSF    03.5
02E7:  MOVWF  23
02E8:  BCF    03.5
02E9:  CALL   1EA
02EA:  INCF   5D,F
02EB:  GOTO   2C7
....................       } 
02EC:  INCF   5C,F
02ED:  GOTO   296
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    set_tris_d(0x00); 
*
01EA:  MOVLW  00
01EB:  BSF    03.5
01EC:  MOVWF  08
....................     
....................    output_low(GLCD_RW);       // Set for writing 
01ED:  BCF    06.4
01EE:  BCF    03.5
01EF:  BCF    06.4
....................  
.................... 	 if(side)                   // Choose which side to write to 
01F0:  BSF    03.5
01F1:  MOVF   22,F
01F2:  BTFSC  03.2
01F3:  GOTO   1F9
....................       output_high(GLCD_CS2); 
01F4:  BCF    06.1
01F5:  BCF    03.5
01F6:  BSF    06.1
01F7:  GOTO   1FC
01F8:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS1); 
01F9:  BCF    06.0
01FA:  BCF    03.5
01FB:  BSF    06.0
....................  
.................... 	 delay_us(1); 
01FC:  GOTO   1FD
....................  
....................    output_d(data);            // Put the data on the port 
01FD:  BSF    03.5
01FE:  CLRF   08
01FF:  MOVF   23,W
0200:  BCF    03.5
0201:  MOVWF  08
....................    delay_us(1); 
0202:  GOTO   203
....................    output_high(GLCD_E);       // Pulse the enable pin 
0203:  BSF    03.5
0204:  BCF    06.5
0205:  BCF    03.5
0206:  BSF    06.5
....................    delay_us(1); 
0207:  GOTO   208
....................    output_low(GLCD_E); 
0208:  BSF    03.5
0209:  BCF    06.5
020A:  BCF    03.5
020B:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020C:  BSF    03.5
020D:  BCF    06.0
020E:  BCF    03.5
020F:  BCF    06.0
....................    output_low(GLCD_CS2); 
0210:  BSF    03.5
0211:  BCF    06.1
0212:  BCF    03.5
0213:  BCF    06.1
0214:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
02F1:  MOVLW  FF
02F2:  BSF    03.5
02F3:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
02F4:  BCF    06.4
02F5:  BCF    03.5
02F6:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
02F7:  BSF    03.5
02F8:  MOVF   21,F
02F9:  BTFSC  03.2
02FA:  GOTO   300
....................       output_high(GLCD_CS2); 
02FB:  BCF    06.1
02FC:  BCF    03.5
02FD:  BSF    06.1
02FE:  GOTO   303
02FF:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS1); 
0300:  BCF    06.0
0301:  BCF    03.5
0302:  BSF    06.0
....................  
....................    delay_us(1); 
0303:  GOTO   304
....................    output_high(GLCD_E);       // Pulse the enable pin 
0304:  BSF    03.5
0305:  BCF    06.5
0306:  BCF    03.5
0307:  BSF    06.5
....................    delay_us(1); 
0308:  GOTO   309
....................    data = input_d();          // Get the data from the display's output register 
0309:  MOVLW  FF
030A:  BSF    03.5
030B:  MOVWF  08
030C:  BCF    03.5
030D:  MOVF   08,W
030E:  BSF    03.5
030F:  MOVWF  22
....................    output_low(GLCD_E); 
0310:  BCF    06.5
0311:  BCF    03.5
0312:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0313:  BSF    03.5
0314:  BCF    06.0
0315:  BCF    03.5
0316:  BCF    06.0
....................    output_low(GLCD_CS2); 
0317:  BSF    03.5
0318:  BCF    06.1
0319:  BCF    03.5
031A:  BCF    06.1
....................    return data;               // Return the read data 
031B:  BSF    03.5
031C:  MOVF   22,W
031D:  MOVWF  78
031E:  BCF    03.5
031F:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <graphics.c> //Funciones para dibujar y escribir en el display 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
*
047A:  MOVLW  01
047B:  MOVWF  6E
047C:  MOVWF  6F
047D:  CLRF   74
.................... { 
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
047E:  MOVF   65,W
047F:  SUBWF  67,W
0480:  MOVWF  75
0481:  MOVF   75,W
0482:  BTFSS  75.7
0483:  GOTO   486
0484:  MOVF   75,W
0485:  SUBLW  00
0486:  CLRF   7A
0487:  MOVWF  6C
0488:  MOVF   7A,W
0489:  MOVWF  6D
....................    dy = abs((signed int8)(y2 - y1)); 
048A:  MOVF   66,W
048B:  SUBWF  68,W
048C:  MOVWF  75
048D:  MOVF   75,W
048E:  BTFSS  75.7
048F:  GOTO   492
0490:  MOVF   75,W
0491:  SUBLW  00
0492:  CLRF   7A
0493:  MOVWF  6A
0494:  MOVF   7A,W
0495:  MOVWF  6B
....................    #endif 
....................  
....................    if(x1 > x2) 
0496:  MOVF   65,W
0497:  SUBWF  67,W
0498:  BTFSC  03.0
0499:  GOTO   49C
....................       addx = -1; 
049A:  MOVLW  FF
049B:  MOVWF  6E
....................    if(y1 > y2) 
049C:  MOVF   66,W
049D:  SUBWF  68,W
049E:  BTFSC  03.0
049F:  GOTO   4A2
....................       addy = -1; 
04A0:  MOVLW  FF
04A1:  MOVWF  6F
....................  
....................    if(dx >= dy) 
04A2:  MOVF   6B,W
04A3:  SUBWF  6D,W
04A4:  BTFSS  03.0
04A5:  GOTO   4EE
04A6:  BTFSS  03.2
04A7:  GOTO   4AC
04A8:  MOVF   6A,W
04A9:  SUBWF  6C,W
04AA:  BTFSS  03.0
04AB:  GOTO   4EE
....................    { 
....................       dy *= 2; 
04AC:  BCF    03.0
04AD:  RLF    6A,F
04AE:  RLF    6B,F
....................       P = dy - dx; 
04AF:  MOVF   6C,W
04B0:  SUBWF  6A,W
04B1:  MOVWF  77
04B2:  MOVF   6B,W
04B3:  MOVWF  7A
04B4:  MOVF   6D,W
04B5:  BTFSS  03.0
04B6:  INCFSZ 6D,W
04B7:  SUBWF  7A,F
04B8:  MOVF   77,W
04B9:  MOVWF  70
04BA:  MOVF   7A,W
04BB:  MOVWF  71
....................       diff = P - dx; 
04BC:  MOVF   6C,W
04BD:  SUBWF  70,W
04BE:  MOVWF  72
04BF:  MOVF   71,W
04C0:  MOVWF  73
04C1:  MOVF   6D,W
04C2:  BTFSS  03.0
04C3:  INCFSZ 6D,W
04C4:  SUBWF  73,F
....................  
....................       for(; i<=dx; ++i) 
04C5:  MOVF   6D,F
04C6:  BTFSS  03.2
04C7:  GOTO   4CC
04C8:  MOVF   74,W
04C9:  SUBWF  6C,W
04CA:  BTFSS  03.0
04CB:  GOTO   4ED
....................       { 
....................          glcd_pixel(x1, y1, color); 
04CC:  MOVF   65,W
04CD:  MOVWF  75
04CE:  MOVF   66,W
04CF:  MOVWF  76
04D0:  MOVF   69,W
04D1:  MOVWF  7B
04D2:  CALL   320
....................  
....................          if(P < 0) 
04D3:  BTFSS  71.7
04D4:  GOTO   4DF
....................          { 
....................             P  += dy; 
04D5:  MOVF   6A,W
04D6:  ADDWF  70,F
04D7:  MOVF   6B,W
04D8:  BTFSC  03.0
04D9:  INCFSZ 6B,W
04DA:  ADDWF  71,F
....................             x1 += addx; 
04DB:  MOVF   6E,W
04DC:  ADDWF  65,W
04DD:  MOVWF  65
....................          } 
04DE:  GOTO   4EB
....................          else 
....................          { 
....................             P  += diff; 
04DF:  MOVF   72,W
04E0:  ADDWF  70,F
04E1:  MOVF   73,W
04E2:  BTFSC  03.0
04E3:  INCFSZ 73,W
04E4:  ADDWF  71,F
....................             x1 += addx; 
04E5:  MOVF   6E,W
04E6:  ADDWF  65,W
04E7:  MOVWF  65
....................             y1 += addy; 
04E8:  MOVF   6F,W
04E9:  ADDWF  66,W
04EA:  MOVWF  66
....................          } 
04EB:  INCF   74,F
04EC:  GOTO   4C5
....................       } 
....................    } 
04ED:  GOTO   52F
....................    else 
....................    { 
....................       dx *= 2; 
04EE:  BCF    03.0
04EF:  RLF    6C,F
04F0:  RLF    6D,F
....................       P = dx - dy; 
04F1:  MOVF   6A,W
04F2:  SUBWF  6C,W
04F3:  MOVWF  77
04F4:  MOVF   6D,W
04F5:  MOVWF  7A
04F6:  MOVF   6B,W
04F7:  BTFSS  03.0
04F8:  INCFSZ 6B,W
04F9:  SUBWF  7A,F
04FA:  MOVF   77,W
04FB:  MOVWF  70
04FC:  MOVF   7A,W
04FD:  MOVWF  71
....................       diff = P - dy; 
04FE:  MOVF   6A,W
04FF:  SUBWF  70,W
0500:  MOVWF  72
0501:  MOVF   71,W
0502:  MOVWF  73
0503:  MOVF   6B,W
0504:  BTFSS  03.0
0505:  INCFSZ 6B,W
0506:  SUBWF  73,F
....................  
....................       for(; i<=dy; ++i) 
0507:  MOVF   6B,F
0508:  BTFSS  03.2
0509:  GOTO   50E
050A:  MOVF   74,W
050B:  SUBWF  6A,W
050C:  BTFSS  03.0
050D:  GOTO   52F
....................       { 
....................          glcd_pixel(x1, y1, color); 
050E:  MOVF   65,W
050F:  MOVWF  75
0510:  MOVF   66,W
0511:  MOVWF  76
0512:  MOVF   69,W
0513:  MOVWF  7B
0514:  CALL   320
....................  
....................          if(P < 0) 
0515:  BTFSS  71.7
0516:  GOTO   521
....................          { 
....................             P  += dx; 
0517:  MOVF   6C,W
0518:  ADDWF  70,F
0519:  MOVF   6D,W
051A:  BTFSC  03.0
051B:  INCFSZ 6D,W
051C:  ADDWF  71,F
....................             y1 += addy; 
051D:  MOVF   6F,W
051E:  ADDWF  66,W
051F:  MOVWF  66
....................          } 
0520:  GOTO   52D
....................          else 
....................          { 
....................             P  += diff; 
0521:  MOVF   72,W
0522:  ADDWF  70,F
0523:  MOVF   73,W
0524:  BTFSC  03.0
0525:  INCFSZ 73,W
0526:  ADDWF  71,F
....................             x1 += addx; 
0527:  MOVF   6E,W
0528:  ADDWF  65,W
0529:  MOVWF  65
....................             y1 += addy; 
052A:  MOVF   6F,W
052B:  ADDWF  66,W
052C:  MOVWF  66
....................          } 
052D:  INCF   74,F
052E:  GOTO   507
....................       } 
....................    } 
052F:  RETURN
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
....................       { 
....................          xmin = x1; 
....................          xmax = x2; 
....................       } 
....................       else 
....................       { 
....................          xmin = x2; 
....................          xmax = x1; 
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
....................       { 
....................          ymin = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          ymin = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
....................          { 
....................             glcd_pixel(xmin, i, color); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
03A4:  MOVF   62,W
03A5:  MOVWF  7A
03A6:  MOVF   61,W
03A7:  MOVWF  04
03A8:  BCF    03.7
03A9:  BTFSC  7A.0
03AA:  BSF    03.7
03AB:  MOVF   00,F
03AC:  BTFSC  03.2
03AD:  GOTO   479
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
03AE:  MOVF   62,W
03AF:  MOVWF  7A
03B0:  MOVF   61,W
03B1:  MOVWF  04
03B2:  BCF    03.7
03B3:  BTFSC  7A.0
03B4:  BSF    03.7
03B5:  MOVF   00,W
03B6:  SUBLW  52
03B7:  BTFSS  03.0
03B8:  GOTO   3D7
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
03B9:  MOVF   62,W
03BA:  MOVWF  7A
03BB:  MOVF   61,W
03BC:  MOVWF  04
03BD:  BCF    03.7
03BE:  BTFSC  7A.0
03BF:  BSF    03.7
03C0:  MOVLW  20
03C1:  SUBWF  00,W
03C2:  MOVWF  6F
03C3:  MOVWF  70
03C4:  MOVLW  05
03C5:  MOVWF  71
03C6:  CALL   215
03C7:  MOVF   78,W
03C8:  MOVWF  6E
03C9:  MOVWF  78
03CA:  MOVLW  05
03CB:  MOVWF  77
03CC:  MOVLW  69
03CD:  MOVWF  04
03CE:  BCF    03.7
03CF:  MOVF   78,W
03D0:  CALL   004
03D1:  MOVWF  00
03D2:  INCF   78,F
03D3:  INCF   04,F
03D4:  DECFSZ 77,F
03D5:  GOTO   3CF
03D6:  GOTO   405
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
03D7:  MOVF   62,W
03D8:  MOVWF  7A
03D9:  MOVF   61,W
03DA:  MOVWF  04
03DB:  BCF    03.7
03DC:  BTFSC  7A.0
03DD:  BSF    03.7
03DE:  MOVF   00,W
03DF:  SUBLW  7E
03E0:  BTFSS  03.0
03E1:  GOTO   400
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
03E2:  MOVF   62,W
03E3:  MOVWF  7A
03E4:  MOVF   61,W
03E5:  MOVWF  04
03E6:  BCF    03.7
03E7:  BTFSC  7A.0
03E8:  BSF    03.7
03E9:  MOVLW  53
03EA:  SUBWF  00,W
03EB:  MOVWF  6F
03EC:  MOVWF  70
03ED:  MOVLW  05
03EE:  MOVWF  71
03EF:  CALL   215
03F0:  MOVF   78,W
03F1:  MOVWF  6E
03F2:  MOVWF  78
03F3:  MOVLW  05
03F4:  MOVWF  77
03F5:  MOVLW  69
03F6:  MOVWF  04
03F7:  BCF    03.7
03F8:  MOVF   78,W
03F9:  CALL   10A
03FA:  MOVWF  00
03FB:  INCF   78,F
03FC:  INCF   04,F
03FD:  DECFSZ 77,F
03FE:  GOTO   3F8
03FF:  GOTO   405
....................       else 
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
0400:  CLRF   69
0401:  CLRF   6A
0402:  CLRF   6B
0403:  CLRF   6C
0404:  CLRF   6D
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
0405:  MOVF   62,W
0406:  MOVWF  7A
0407:  MOVF   61,W
0408:  MOVWF  04
0409:  BCF    03.7
040A:  BTFSC  7A.0
040B:  BSF    03.7
040C:  MOVF   00,W
040D:  XORLW  0A
040E:  BTFSC  03.2
040F:  GOTO   414
0410:  XORLW  07
0411:  BTFSC  03.2
0412:  GOTO   41D
0413:  GOTO   41F
....................       { 
....................          case '\n': 
....................             y += 7*size + 1; 
0414:  MOVLW  07
0415:  MOVWF  70
0416:  MOVF   63,W
0417:  MOVWF  71
0418:  CALL   215
0419:  MOVLW  01
041A:  ADDWF  78,W
041B:  ADDWF  60,F
....................             continue; 
041C:  GOTO   474
....................          case '\r': 
....................             x = 0; 
041D:  CLRF   5F
....................             continue; 
041E:  GOTO   474
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
041F:  MOVLW  05
0420:  MOVWF  70
0421:  MOVF   63,W
0422:  MOVWF  71
0423:  CALL   215
0424:  MOVF   78,W
0425:  ADDWF  5F,W
0426:  SUBLW  7F
0427:  BTFSC  03.0
0428:  GOTO   432
....................       { 
....................          x = 0;                           // Set x at far left position 
0429:  CLRF   5F
....................          y += 7*size + 1;                 // Set y at next position down 
042A:  MOVLW  07
042B:  MOVWF  70
042C:  MOVF   63,W
042D:  MOVWF  71
042E:  CALL   215
042F:  MOVLW  01
0430:  ADDWF  78,W
0431:  ADDWF  60,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0432:  CLRF   65
0433:  MOVF   65,W
0434:  SUBLW  04
0435:  BTFSS  03.0
0436:  GOTO   474
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
0437:  CLRF   66
0438:  MOVF   66,W
0439:  SUBLW  06
043A:  BTFSS  03.0
043B:  GOTO   470
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
043C:  MOVLW  69
043D:  ADDWF  65,W
043E:  MOVWF  04
043F:  BCF    03.7
0440:  MOVF   00,W
0441:  MOVWF  6E
0442:  MOVWF  77
0443:  MOVF   66,W
0444:  MOVWF  78
0445:  BTFSC  03.2
0446:  GOTO   44B
0447:  BCF    03.0
0448:  RRF    77,F
0449:  DECFSZ 78,F
044A:  GOTO   447
044B:  BTFSS  77.0
044C:  GOTO   46E
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
044D:  CLRF   67
044E:  MOVF   63,W
044F:  SUBWF  67,W
0450:  BTFSC  03.0
0451:  GOTO   46E
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
0452:  CLRF   68
0453:  MOVF   63,W
0454:  SUBWF  68,W
0455:  BTFSC  03.0
0456:  GOTO   46C
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0457:  MOVF   68,W
0458:  ADDWF  5F,W
0459:  MOVWF  6E
045A:  MOVF   66,W
045B:  MOVWF  70
045C:  MOVF   63,W
045D:  MOVWF  71
045E:  CALL   215
045F:  MOVF   78,W
0460:  ADDWF  60,W
0461:  ADDWF  67,W
0462:  MOVWF  6F
0463:  MOVF   6E,W
0464:  MOVWF  75
0465:  MOVF   6F,W
0466:  MOVWF  76
0467:  MOVF   64,W
0468:  MOVWF  7B
0469:  CALL   320
046A:  INCF   68,F
046B:  GOTO   453
....................                   } 
046C:  INCF   67,F
046D:  GOTO   44E
....................                } 
....................             } 
046E:  INCF   66,F
046F:  GOTO   438
....................          } 
0470:  INCF   65,F
0471:  MOVF   63,W
0472:  ADDWF  5F,F
0473:  GOTO   433
....................       } 
0474:  INCF   61,F
0475:  BTFSC  03.2
0476:  INCF   62,F
0477:  INCF   5F,F
0478:  GOTO   3A4
....................    } 
0479:  RETURN
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #byte trisb=0x86 
....................  
.................... #define escala -0.20 //Escala negativa para que crezca hacia arriba. 
....................  
.................... int x=0; //Posicion inicial de x para graficar la temperatura 
.................... signed int16 y=0; //Posicion inicial de y (Vamos a tener que cambiarla a la primer temperatura leida) para graficar la temperatura 
.................... int offset=52; //es el offset para la altura de la grafica 
....................  
.................... void mostrarBT(int1 estado){ //Mostramos BT si el bluetooth esta prendido 
.................... 	char bt[]="BT"; 
*
0794:  MOVLW  42
0795:  MOVWF  5C
0796:  MOVLW  54
0797:  MOVWF  5D
0798:  CLRF   5E
.................... 	glcd_text57(110,0,bt,1,estado); 
0799:  MOVLW  6E
079A:  MOVWF  5F
079B:  CLRF   60
079C:  CLRF   62
079D:  MOVLW  5C
079E:  MOVWF  61
079F:  MOVLW  01
07A0:  MOVWF  63
07A1:  MOVF   5B,W
07A2:  MOVWF  64
07A3:  CALL   3A4
07A4:  BSF    0A.3
07A5:  BCF    0A.4
07A6:  GOTO   375 (RETURN)
.................... } 
....................  
.................... void limpiarPorcion(int x1, int y1, int x2, int y2){ //(x1, y1) = posición del primer pixel. (x2, y2) = cantididad de pixeles hacia la derecha y hacia abajo 
.................... 	for(int i=x1;i<x1+x2;i++){ 
*
072B:  MOVF   63,W
072C:  MOVWF  67
072D:  MOVF   65,W
072E:  ADDWF  63,W
072F:  SUBWF  67,W
0730:  BTFSC  03.0
0731:  GOTO   743
.................... 		for(int j=y1;j<y1+y2;j++){ 
0732:  MOVF   64,W
0733:  MOVWF  68
0734:  MOVF   66,W
0735:  ADDWF  64,W
0736:  SUBWF  68,W
0737:  BTFSC  03.0
0738:  GOTO   741
.................... 			glcd_pixel(i, j, OFF); //Apagamos el pixel. 
0739:  MOVF   67,W
073A:  MOVWF  75
073B:  MOVF   68,W
073C:  MOVWF  76
073D:  CLRF   7B
073E:  CALL   320
073F:  INCF   68,F
0740:  GOTO   734
.................... 		} 
0741:  INCF   67,F
0742:  GOTO   72D
.................... 	} 
0743:  RETURN
.................... } 
....................  
.................... void nuevaLinea(float temp){ //Funcion para graficar las nuevas lineas de temperatura 
*
097A:  MOVLW  02
097B:  ADDWF  23,W
097C:  MOVWF  62
.................... 	int x1=x+2; 
.................... 	if(x1>128){ //Revisamos si sobrepasamos el tamaño de la pantalla 
097D:  MOVF   62,W
097E:  SUBLW  80
097F:  BTFSC  03.0
0980:  GOTO   18E
.................... 		limpiarPorcion(0, 20, 128, 44); //Limpiamos la porcion del grafico de la pantalla 
0981:  CLRF   63
0982:  MOVLW  14
0983:  MOVWF  64
0984:  MOVLW  80
0985:  MOVWF  65
0986:  MOVLW  2C
0987:  MOVWF  66
0988:  BCF    0A.3
0989:  CALL   72B
098A:  BSF    0A.3
.................... 		x=0; 
098B:  CLRF   23
.................... 		x1=2; 
098C:  MOVLW  02
098D:  MOVWF  62
.................... 	} 
.................... 	glcd_line(x, (y*escala)+offset, x1, (temp*escala)+offset, ON); //multiplicamos por la escala para que la grafica entre en el area del grafico. El offset esta explicado arriba 
098E:  MOVF   25,W
098F:  MOVWF  64
0990:  MOVF   24,W
0991:  MOVWF  63
*
09B6:  MOVF   7A,W
09B7:  MOVWF  6E
09B8:  MOVF   79,W
09B9:  MOVWF  6D
09BA:  MOVF   78,W
09BB:  MOVWF  6C
09BC:  MOVF   77,W
09BD:  MOVWF  6B
09BE:  MOVLW  CD
09BF:  MOVWF  72
09C0:  MOVLW  CC
09C1:  MOVWF  71
09C2:  MOVWF  70
09C3:  MOVLW  7C
09C4:  MOVWF  6F
09C5:  BCF    0A.3
09C6:  CALL   530
09C7:  BSF    0A.3
09C8:  MOVF   7A,W
09C9:  MOVWF  66
09CA:  MOVF   79,W
09CB:  MOVWF  65
09CC:  MOVF   78,W
09CD:  MOVWF  64
09CE:  MOVF   77,W
09CF:  MOVWF  63
09D0:  CLRF   69
09D1:  MOVF   26,W
09D2:  MOVWF  68
09D3:  BCF    0A.3
09D4:  CALL   744
09D5:  BSF    0A.3
09D6:  BCF    03.1
09D7:  MOVF   66,W
09D8:  MOVWF  6B
09D9:  MOVF   65,W
09DA:  MOVWF  6A
09DB:  MOVF   64,W
09DC:  MOVWF  69
09DD:  MOVF   63,W
09DE:  MOVWF  68
09DF:  MOVF   7A,W
09E0:  MOVWF  6F
09E1:  MOVF   79,W
09E2:  MOVWF  6E
09E3:  MOVF   78,W
09E4:  MOVWF  6D
09E5:  MOVF   77,W
09E6:  MOVWF  6C
09E7:  CALL   000
09E8:  MOVF   7A,W
09E9:  MOVWF  67
09EA:  MOVF   79,W
09EB:  MOVWF  66
09EC:  MOVF   78,W
09ED:  MOVWF  65
09EE:  MOVF   77,W
09EF:  MOVWF  64
09F0:  BCF    0A.3
09F1:  CALL   761
09F2:  BSF    0A.3
09F3:  MOVF   78,W
09F4:  MOVWF  63
09F5:  MOVF   61,W
09F6:  MOVWF  6E
09F7:  MOVF   60,W
09F8:  MOVWF  6D
09F9:  MOVF   5F,W
09FA:  MOVWF  6C
09FB:  MOVF   5E,W
09FC:  MOVWF  6B
09FD:  MOVLW  CD
09FE:  MOVWF  72
09FF:  MOVLW  CC
0A00:  MOVWF  71
0A01:  MOVWF  70
0A02:  MOVLW  7C
0A03:  MOVWF  6F
0A04:  BCF    0A.3
0A05:  CALL   530
0A06:  BSF    0A.3
0A07:  MOVF   7A,W
0A08:  MOVWF  67
0A09:  MOVF   79,W
0A0A:  MOVWF  66
0A0B:  MOVF   78,W
0A0C:  MOVWF  65
0A0D:  MOVF   77,W
0A0E:  MOVWF  64
0A0F:  CLRF   69
0A10:  MOVF   26,W
0A11:  MOVWF  68
0A12:  BCF    0A.3
0A13:  CALL   744
0A14:  BSF    0A.3
0A15:  BCF    03.1
0A16:  MOVF   67,W
0A17:  MOVWF  6B
0A18:  MOVF   66,W
0A19:  MOVWF  6A
0A1A:  MOVF   65,W
0A1B:  MOVWF  69
0A1C:  MOVF   64,W
0A1D:  MOVWF  68
0A1E:  MOVF   7A,W
0A1F:  MOVWF  6F
0A20:  MOVF   79,W
0A21:  MOVWF  6E
0A22:  MOVF   78,W
0A23:  MOVWF  6D
0A24:  MOVF   77,W
0A25:  MOVWF  6C
0A26:  CALL   000
0A27:  MOVF   7A,W
0A28:  MOVWF  67
0A29:  MOVF   79,W
0A2A:  MOVWF  66
0A2B:  MOVF   78,W
0A2C:  MOVWF  65
0A2D:  MOVF   77,W
0A2E:  MOVWF  64
0A2F:  BCF    0A.3
0A30:  CALL   761
0A31:  BSF    0A.3
0A32:  MOVF   78,W
0A33:  MOVWF  64
0A34:  MOVF   23,W
0A35:  MOVWF  65
0A36:  MOVF   63,W
0A37:  MOVWF  66
0A38:  MOVF   62,W
0A39:  MOVWF  67
0A3A:  MOVF   64,W
0A3B:  MOVWF  68
0A3C:  MOVLW  01
0A3D:  MOVWF  69
0A3E:  BCF    0A.3
0A3F:  CALL   47A
0A40:  BSF    0A.3
.................... 	y=temp; 
0A41:  MOVF   61,W
0A42:  MOVWF  67
0A43:  MOVF   60,W
0A44:  MOVWF  66
0A45:  MOVF   5F,W
0A46:  MOVWF  65
0A47:  MOVF   5E,W
0A48:  MOVWF  64
0A49:  BCF    0A.3
0A4A:  CALL   761
0A4B:  BSF    0A.3
0A4C:  MOVF   79,W
0A4D:  MOVWF  25
0A4E:  MOVF   78,W
0A4F:  MOVWF  24
.................... 	x=x1; 
0A50:  MOVF   62,W
0A51:  MOVWF  23
0A52:  BSF    0A.3
0A53:  BCF    0A.4
0A54:  GOTO   356 (RETURN)
.................... } 
....................  
.................... void main() 
0A55:  MOVF   03,W
0A56:  ANDLW  1F
0A57:  MOVWF  03
0A58:  MOVLW  FF
0A59:  MOVWF  22
0A5A:  CLRF   23
0A5B:  CLRF   25
0A5C:  CLRF   24
0A5D:  MOVLW  34
0A5E:  MOVWF  26
0A5F:  CLRF   28
0A60:  CLRF   27
0A61:  BSF    03.5
0A62:  BSF    1F.0
0A63:  BSF    1F.1
0A64:  BSF    1F.2
0A65:  BCF    1F.3
0A66:  BCF    03.7
*
0A6A:  BCF    29.0
.................... { 
.................... 	int1 toggle=0; //Para mostrar si el bt esta encendido 
.................... 	char str[10]; 
.................... 	char temp[]="Temperatura:"; 
0A6B:  MOVLW  54
0A6C:  MOVWF  34
0A6D:  MOVLW  65
0A6E:  MOVWF  35
0A6F:  MOVLW  6D
0A70:  MOVWF  36
0A71:  MOVLW  70
0A72:  MOVWF  37
0A73:  MOVLW  65
0A74:  MOVWF  38
0A75:  MOVLW  72
0A76:  MOVWF  39
0A77:  MOVLW  61
0A78:  MOVWF  3A
0A79:  MOVLW  74
0A7A:  MOVWF  3B
0A7B:  MOVLW  75
0A7C:  MOVWF  3C
0A7D:  MOVLW  72
0A7E:  MOVWF  3D
0A7F:  MOVLW  61
0A80:  MOVWF  3E
0A81:  MOVLW  3A
0A82:  MOVWF  3F
0A83:  CLRF   40
.................... 	float t[]={37, 36.5, 38, -55, 150, 30}; //ESTO HAY QUE FLETARLO CUANDO YA ESTÉ LA CAPTURA REAL 
0A84:  MOVLW  84
0A85:  MOVWF  41
0A86:  MOVLW  14
0A87:  MOVWF  42
0A88:  CLRF   43
0A89:  CLRF   44
0A8A:  MOVLW  84
0A8B:  MOVWF  45
0A8C:  MOVLW  12
0A8D:  MOVWF  46
0A8E:  CLRF   47
0A8F:  CLRF   48
0A90:  MOVLW  84
0A91:  MOVWF  49
0A92:  MOVLW  18
0A93:  MOVWF  4A
0A94:  CLRF   4B
0A95:  CLRF   4C
0A96:  MOVLW  84
0A97:  MOVWF  4D
0A98:  MOVLW  DC
0A99:  MOVWF  4E
0A9A:  CLRF   4F
0A9B:  CLRF   50
0A9C:  MOVLW  86
0A9D:  MOVWF  51
0A9E:  MOVLW  16
0A9F:  MOVWF  52
0AA0:  CLRF   53
0AA1:  CLRF   54
0AA2:  MOVLW  83
0AA3:  MOVWF  55
0AA4:  MOVLW  70
0AA5:  MOVWF  56
0AA6:  CLRF   57
0AA7:  CLRF   58
.................... 	glcd_init(on); //Inicializamos el lcd 
0AA8:  MOVLW  01
0AA9:  MOVWF  5A
0AAA:  BCF    0A.3
0AAB:  GOTO   23A
0AAC:  BSF    0A.3
....................  
.................... 	//texto 
.................... 	glcd_text57(0,10,temp,1,ON); //Escribimos el texto "Tempreatura:" en la posicion 0,10 
0AAD:  CLRF   5F
0AAE:  MOVLW  0A
0AAF:  MOVWF  60
0AB0:  CLRF   62
0AB1:  MOVLW  34
0AB2:  MOVWF  61
0AB3:  MOVLW  01
0AB4:  MOVWF  63
0AB5:  MOVWF  64
0AB6:  BCF    0A.3
0AB7:  CALL   3A4
0AB8:  BSF    0A.3
.................... 	//dibujar una linea 
.................... 	glcd_line(0, 8, 128, 8, ON); //Pintamos una linea por debajo del barra de notificaciones 
0AB9:  CLRF   65
0ABA:  MOVLW  08
0ABB:  MOVWF  66
0ABC:  MOVLW  80
0ABD:  MOVWF  67
0ABE:  MOVLW  08
0ABF:  MOVWF  68
0AC0:  MOVLW  01
0AC1:  MOVWF  69
0AC2:  BCF    0A.3
0AC3:  CALL   47A
0AC4:  BSF    0A.3
.................... 	glcd_line(0, 19, 128, 19, ON); //Pintamos una linea por debajo de la temperatura 
0AC5:  CLRF   65
0AC6:  MOVLW  13
0AC7:  MOVWF  66
0AC8:  MOVLW  80
0AC9:  MOVWF  67
0ACA:  MOVLW  13
0ACB:  MOVWF  68
0ACC:  MOVLW  01
0ACD:  MOVWF  69
0ACE:  BCF    0A.3
0ACF:  CALL   47A
0AD0:  BSF    0A.3
....................   	 
.................... 	for(int i=0; i<6; i++){ //ESTO HAY QUE FLETARLO CUANDO YA ESTÉ LA CAPTURA REAL 
0AD1:  CLRF   59
0AD2:  MOVF   59,W
0AD3:  SUBLW  05
0AD4:  BTFSS  03.0
0AD5:  GOTO   35D
.................... 		sprintf(str, "%4.2f°C", t[i]); //Convertimos la temperatura float en un char* 
0AD6:  RLF    59,W
0AD7:  MOVWF  77
0AD8:  RLF    77,F
0AD9:  MOVLW  FC
0ADA:  ANDWF  77,F
0ADB:  MOVF   77,W
0ADC:  ADDLW  41
0ADD:  MOVWF  04
0ADE:  BCF    03.7
0ADF:  MOVF   00,W
0AE0:  MOVWF  5A
0AE1:  INCF   04,F
0AE2:  MOVF   00,W
0AE3:  MOVWF  5B
0AE4:  INCF   04,F
0AE5:  MOVF   00,W
0AE6:  MOVWF  5C
0AE7:  INCF   04,F
0AE8:  MOVF   00,W
0AE9:  MOVWF  5D
0AEA:  CLRF   28
0AEB:  MOVLW  2A
0AEC:  MOVWF  27
0AED:  MOVLW  03
0AEE:  MOVWF  04
0AEF:  MOVF   5D,W
0AF0:  MOVWF  61
0AF1:  MOVF   5C,W
0AF2:  MOVWF  60
0AF3:  MOVF   5B,W
0AF4:  MOVWF  5F
0AF5:  MOVF   5A,W
0AF6:  MOVWF  5E
0AF7:  MOVLW  02
0AF8:  MOVWF  62
0AF9:  BCF    0A.3
0AFA:  GOTO   62B
0AFB:  BSF    0A.3
0AFC:  MOVLW  B0
0AFD:  MOVWF  6B
0AFE:  BCF    0A.3
0AFF:  CALL   61E
0B00:  BSF    0A.3
0B01:  MOVLW  43
0B02:  MOVWF  6B
0B03:  BCF    0A.3
0B04:  CALL   61E
0B05:  BSF    0A.3
.................... 		limpiarPorcion(strlen(temp)*6, 10, 9*6, 7); //Limpiamos la porcion de pantalla que tiene el valor de la temperatura. 
0B06:  CLRF   5B
0B07:  MOVLW  34
0B08:  MOVWF  5A
0B09:  BCF    0A.3
0B0A:  CALL   70D
0B0B:  BSF    0A.3
0B0C:  MOVF   78,W
0B0D:  MOVWF  70
0B0E:  MOVLW  06
0B0F:  MOVWF  71
0B10:  BCF    0A.3
0B11:  CALL   215
0B12:  BSF    0A.3
0B13:  MOVF   78,W
0B14:  MOVWF  5A
0B15:  MOVWF  63
0B16:  MOVLW  0A
0B17:  MOVWF  64
0B18:  MOVLW  36
0B19:  MOVWF  65
0B1A:  MOVLW  07
0B1B:  MOVWF  66
0B1C:  BCF    0A.3
0B1D:  CALL   72B
0B1E:  BSF    0A.3
.................... 		glcd_text57(strlen(temp)*6, 10, str, 1, ON); //Escribimos la temperatura. 
0B1F:  CLRF   5B
0B20:  MOVLW  34
0B21:  MOVWF  5A
0B22:  BCF    0A.3
0B23:  CALL   70D
0B24:  BSF    0A.3
0B25:  MOVF   78,W
0B26:  MOVWF  70
0B27:  MOVLW  06
0B28:  MOVWF  71
0B29:  BCF    0A.3
0B2A:  CALL   215
0B2B:  BSF    0A.3
0B2C:  MOVF   78,W
0B2D:  MOVWF  5A
0B2E:  MOVWF  5F
0B2F:  MOVLW  0A
0B30:  MOVWF  60
0B31:  CLRF   62
0B32:  MOVLW  2A
0B33:  MOVWF  61
0B34:  MOVLW  01
0B35:  MOVWF  63
0B36:  MOVWF  64
0B37:  BCF    0A.3
0B38:  CALL   3A4
0B39:  BSF    0A.3
.................... 		nuevaLinea(t[i]); //Dibujamos la nueva linea en el grafico. 
0B3A:  RLF    59,W
0B3B:  MOVWF  77
0B3C:  RLF    77,F
0B3D:  MOVLW  FC
0B3E:  ANDWF  77,F
0B3F:  MOVF   77,W
0B40:  ADDLW  41
0B41:  MOVWF  04
0B42:  BCF    03.7
0B43:  MOVF   00,W
0B44:  MOVWF  5A
0B45:  INCF   04,F
0B46:  MOVF   00,W
0B47:  MOVWF  5B
0B48:  INCF   04,F
0B49:  MOVF   00,W
0B4A:  MOVWF  5C
0B4B:  INCF   04,F
0B4C:  MOVF   00,W
0B4D:  MOVWF  5D
0B4E:  MOVWF  61
0B4F:  MOVF   5C,W
0B50:  MOVWF  60
0B51:  MOVF   5B,W
0B52:  MOVWF  5F
0B53:  MOVF   5A,W
0B54:  MOVWF  5E
0B55:  GOTO   17A
.................... 		delay_ms(200); 
0B56:  MOVLW  C8
0B57:  MOVWF  5B
0B58:  BCF    0A.3
0B59:  CALL   780
0B5A:  BSF    0A.3
0B5B:  INCF   59,F
0B5C:  GOTO   2D2
.................... 	} 
....................   	 
.................... 	while(TRUE){ 
.................... 		trisb|=0b00000100; 
0B5D:  BSF    03.5
0B5E:  BSF    06.2
.................... 		if(input(pin_b3)){ 
0B5F:  BSF    06.3
0B60:  BCF    03.5
0B61:  BTFSS  06.3
0B62:  GOTO   376
.................... 			delay_ms(300); 
0B63:  MOVLW  02
0B64:  MOVWF  5A
0B65:  MOVLW  96
0B66:  MOVWF  5B
0B67:  BCF    0A.3
0B68:  CALL   780
0B69:  BSF    0A.3
0B6A:  DECFSZ 5A,F
0B6B:  GOTO   365
.................... 			toggle=~toggle; 
0B6C:  MOVLW  01
0B6D:  XORWF  29,F
.................... 			mostrarBT(toggle); 
0B6E:  MOVLW  00
0B6F:  BTFSC  29.0
0B70:  MOVLW  01
0B71:  MOVWF  5A
0B72:  MOVWF  5B
0B73:  BCF    0A.3
0B74:  GOTO   794
0B75:  BSF    0A.3
.................... 		} 
0B76:  GOTO   35D
.................... 	} 
.................... } 
0B77:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
