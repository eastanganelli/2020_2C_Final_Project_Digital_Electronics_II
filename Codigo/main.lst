CCS PCM C Compiler, Version 5.076, 56587               20-Nov-20 19:39

               Filename:   D:\Ezequiel\My eBooks\Favaloro\ED\II\GIT_TP_FINAL\tp_final_edi2\Codigo\main.lst

               ROM used:   5968 words (73%)
                           Largest free fragment is 2048
               RAM used:   143 (39%) at main() level
                           244 (66%) worst case
               Stack used: 9 locations (4 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  13
0001:  MOVWF  0A
0002:  GOTO   376
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.3
0018:  GOTO   01B
0019:  BTFSC  0B.0
001A:  GOTO   03C
001B:  MOVLW  8C
001C:  MOVWF  04
001D:  BTFSS  00.5
001E:  GOTO   021
001F:  BTFSC  0C.5
0020:  GOTO   03F
0021:  MOVLW  8C
0022:  MOVWF  04
0023:  BTFSS  00.0
0024:  GOTO   027
0025:  BTFSC  0C.0
0026:  GOTO   042
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   045
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   20,W
0036:  MOVWF  0A
0037:  SWAPF  21,W
0038:  MOVWF  03
0039:  SWAPF  7F,F
003A:  SWAPF  7F,W
003B:  RETFIE
003C:  BSF    0A.3
003D:  BCF    0A.4
003E:  GOTO   403
003F:  BSF    0A.3
0040:  BCF    0A.4
0041:  GOTO   717
0042:  BCF    0A.3
0043:  BCF    0A.4
0044:  GOTO   299
0045:  BCF    0A.3
0046:  BCF    0A.4
0047:  GOTO   282
.................... #include <main.h> 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0048:  BCF    0A.0
0049:  BCF    0A.1
004A:  BCF    0A.2
004B:  ADDLW  4F
004C:  BTFSC  03.0
004D:  INCF   0A,F
004E:  MOVWF  02
004F:  RETLW  00
0050:  RETLW  00
0051:  RETLW  00
0052:  RETLW  00
0053:  RETLW  00
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  5F
0057:  RETLW  00
0058:  RETLW  00
0059:  RETLW  00
005A:  RETLW  03
005B:  RETLW  00
005C:  RETLW  03
005D:  RETLW  00
005E:  RETLW  14
005F:  RETLW  3E
0060:  RETLW  14
0061:  RETLW  3E
0062:  RETLW  14
0063:  RETLW  24
0064:  RETLW  2A
0065:  RETLW  7F
0066:  RETLW  2A
0067:  RETLW  12
0068:  RETLW  43
0069:  RETLW  33
006A:  RETLW  08
006B:  RETLW  66
006C:  RETLW  61
006D:  RETLW  36
006E:  RETLW  49
006F:  RETLW  55
0070:  RETLW  22
0071:  RETLW  50
0072:  RETLW  00
0073:  RETLW  05
0074:  RETLW  03
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  1C
0079:  RETLW  22
007A:  RETLW  41
007B:  RETLW  00
007C:  RETLW  00
007D:  RETLW  41
007E:  RETLW  22
007F:  RETLW  1C
0080:  RETLW  00
0081:  RETLW  14
0082:  RETLW  08
0083:  RETLW  3E
0084:  RETLW  08
0085:  RETLW  14
0086:  RETLW  08
0087:  RETLW  08
0088:  RETLW  3E
0089:  RETLW  08
008A:  RETLW  08
008B:  RETLW  00
008C:  RETLW  50
008D:  RETLW  30
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  08
0091:  RETLW  08
0092:  RETLW  08
0093:  RETLW  08
0094:  RETLW  08
0095:  RETLW  00
0096:  RETLW  60
0097:  RETLW  60
0098:  RETLW  00
0099:  RETLW  00
009A:  RETLW  20
009B:  RETLW  10
009C:  RETLW  08
009D:  RETLW  04
009E:  RETLW  02
009F:  RETLW  3E
00A0:  RETLW  51
00A1:  RETLW  49
00A2:  RETLW  45
00A3:  RETLW  3E
00A4:  RETLW  00
00A5:  RETLW  04
00A6:  RETLW  02
00A7:  RETLW  7F
00A8:  RETLW  00
00A9:  RETLW  42
00AA:  RETLW  61
00AB:  RETLW  51
00AC:  RETLW  49
00AD:  RETLW  46
00AE:  RETLW  22
00AF:  RETLW  41
00B0:  RETLW  49
00B1:  RETLW  49
00B2:  RETLW  36
00B3:  RETLW  18
00B4:  RETLW  14
00B5:  RETLW  12
00B6:  RETLW  7F
00B7:  RETLW  10
00B8:  RETLW  27
00B9:  RETLW  45
00BA:  RETLW  45
00BB:  RETLW  45
00BC:  RETLW  39
00BD:  RETLW  3E
00BE:  RETLW  49
00BF:  RETLW  49
00C0:  RETLW  49
00C1:  RETLW  32
00C2:  RETLW  01
00C3:  RETLW  01
00C4:  RETLW  71
00C5:  RETLW  09
00C6:  RETLW  07
00C7:  RETLW  36
00C8:  RETLW  49
00C9:  RETLW  49
00CA:  RETLW  49
00CB:  RETLW  36
00CC:  RETLW  26
00CD:  RETLW  49
00CE:  RETLW  49
00CF:  RETLW  49
00D0:  RETLW  3E
00D1:  RETLW  00
00D2:  RETLW  36
00D3:  RETLW  36
00D4:  RETLW  00
00D5:  RETLW  00
00D6:  RETLW  00
00D7:  RETLW  56
00D8:  RETLW  36
00D9:  RETLW  00
00DA:  RETLW  00
00DB:  RETLW  08
00DC:  RETLW  14
00DD:  RETLW  22
00DE:  RETLW  41
00DF:  RETLW  00
00E0:  RETLW  14
00E1:  RETLW  14
00E2:  RETLW  14
00E3:  RETLW  14
00E4:  RETLW  14
00E5:  RETLW  00
00E6:  RETLW  41
00E7:  RETLW  22
00E8:  RETLW  14
00E9:  RETLW  08
00EA:  RETLW  02
00EB:  RETLW  01
00EC:  RETLW  51
00ED:  RETLW  09
00EE:  RETLW  06
00EF:  RETLW  3E
00F0:  RETLW  41
00F1:  RETLW  59
00F2:  RETLW  55
00F3:  RETLW  5E
00F4:  RETLW  7E
00F5:  RETLW  09
00F6:  RETLW  09
00F7:  RETLW  09
00F8:  RETLW  7E
00F9:  RETLW  7F
00FA:  RETLW  49
00FB:  RETLW  49
00FC:  RETLW  49
00FD:  RETLW  36
00FE:  RETLW  3E
00FF:  RETLW  41
0100:  RETLW  41
0101:  RETLW  41
0102:  RETLW  22
0103:  RETLW  7F
0104:  RETLW  41
0105:  RETLW  41
0106:  RETLW  41
0107:  RETLW  3E
0108:  RETLW  7F
0109:  RETLW  49
010A:  RETLW  49
010B:  RETLW  49
010C:  RETLW  41
010D:  RETLW  7F
010E:  RETLW  09
010F:  RETLW  09
0110:  RETLW  09
0111:  RETLW  01
0112:  RETLW  3E
0113:  RETLW  41
0114:  RETLW  41
0115:  RETLW  49
0116:  RETLW  3A
0117:  RETLW  7F
0118:  RETLW  08
0119:  RETLW  08
011A:  RETLW  08
011B:  RETLW  7F
011C:  RETLW  00
011D:  RETLW  41
011E:  RETLW  7F
011F:  RETLW  41
0120:  RETLW  00
0121:  RETLW  30
0122:  RETLW  40
0123:  RETLW  40
0124:  RETLW  40
0125:  RETLW  3F
0126:  RETLW  7F
0127:  RETLW  08
0128:  RETLW  14
0129:  RETLW  22
012A:  RETLW  41
012B:  RETLW  7F
012C:  RETLW  40
012D:  RETLW  40
012E:  RETLW  40
012F:  RETLW  40
0130:  RETLW  7F
0131:  RETLW  02
0132:  RETLW  0C
0133:  RETLW  02
0134:  RETLW  7F
0135:  RETLW  7F
0136:  RETLW  02
0137:  RETLW  04
0138:  RETLW  08
0139:  RETLW  7F
013A:  RETLW  3E
013B:  RETLW  41
013C:  RETLW  41
013D:  RETLW  41
013E:  RETLW  3E
013F:  RETLW  7F
0140:  RETLW  09
0141:  RETLW  09
0142:  RETLW  09
0143:  RETLW  06
0144:  RETLW  1E
0145:  RETLW  21
0146:  RETLW  21
0147:  RETLW  21
0148:  RETLW  5E
0149:  RETLW  7F
014A:  RETLW  09
014B:  RETLW  09
014C:  RETLW  09
014D:  RETLW  76
014E:  BSF    0A.0
014F:  BCF    0A.1
0150:  BCF    0A.2
0151:  ADDLW  55
0152:  BTFSC  03.0
0153:  INCF   0A,F
0154:  MOVWF  02
0155:  RETLW  26
0156:  RETLW  49
0157:  RETLW  49
0158:  RETLW  49
0159:  RETLW  32
015A:  RETLW  01
015B:  RETLW  01
015C:  RETLW  7F
015D:  RETLW  01
015E:  RETLW  01
015F:  RETLW  3F
0160:  RETLW  40
0161:  RETLW  40
0162:  RETLW  40
0163:  RETLW  3F
0164:  RETLW  1F
0165:  RETLW  20
0166:  RETLW  40
0167:  RETLW  20
0168:  RETLW  1F
0169:  RETLW  7F
016A:  RETLW  20
016B:  RETLW  10
016C:  RETLW  20
016D:  RETLW  7F
016E:  RETLW  41
016F:  RETLW  22
0170:  RETLW  1C
0171:  RETLW  22
0172:  RETLW  41
0173:  RETLW  07
0174:  RETLW  08
0175:  RETLW  70
0176:  RETLW  08
0177:  RETLW  07
0178:  RETLW  61
0179:  RETLW  51
017A:  RETLW  49
017B:  RETLW  45
017C:  RETLW  43
017D:  RETLW  00
017E:  RETLW  7F
017F:  RETLW  41
0180:  RETLW  00
0181:  RETLW  00
0182:  RETLW  02
0183:  RETLW  04
0184:  RETLW  08
0185:  RETLW  10
0186:  RETLW  20
0187:  RETLW  00
0188:  RETLW  00
0189:  RETLW  41
018A:  RETLW  7F
018B:  RETLW  00
018C:  RETLW  04
018D:  RETLW  02
018E:  RETLW  01
018F:  RETLW  02
0190:  RETLW  04
0191:  RETLW  40
0192:  RETLW  40
0193:  RETLW  40
0194:  RETLW  40
0195:  RETLW  40
0196:  RETLW  00
0197:  RETLW  01
0198:  RETLW  02
0199:  RETLW  04
019A:  RETLW  00
019B:  RETLW  20
019C:  RETLW  54
019D:  RETLW  54
019E:  RETLW  54
019F:  RETLW  78
01A0:  RETLW  7F
01A1:  RETLW  44
01A2:  RETLW  44
01A3:  RETLW  44
01A4:  RETLW  38
01A5:  RETLW  38
01A6:  RETLW  44
01A7:  RETLW  44
01A8:  RETLW  44
01A9:  RETLW  44
01AA:  RETLW  38
01AB:  RETLW  44
01AC:  RETLW  44
01AD:  RETLW  44
01AE:  RETLW  7F
01AF:  RETLW  38
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  54
01B3:  RETLW  18
01B4:  RETLW  04
01B5:  RETLW  04
01B6:  RETLW  7E
01B7:  RETLW  05
01B8:  RETLW  05
01B9:  RETLW  08
01BA:  RETLW  54
01BB:  RETLW  54
01BC:  RETLW  54
01BD:  RETLW  3C
01BE:  RETLW  7F
01BF:  RETLW  08
01C0:  RETLW  04
01C1:  RETLW  04
01C2:  RETLW  78
01C3:  RETLW  00
01C4:  RETLW  44
01C5:  RETLW  7D
01C6:  RETLW  40
01C7:  RETLW  00
01C8:  RETLW  20
01C9:  RETLW  40
01CA:  RETLW  44
01CB:  RETLW  3D
01CC:  RETLW  00
01CD:  RETLW  7F
01CE:  RETLW  10
01CF:  RETLW  28
01D0:  RETLW  44
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  41
01D4:  RETLW  7F
01D5:  RETLW  40
01D6:  RETLW  00
01D7:  RETLW  7C
01D8:  RETLW  04
01D9:  RETLW  78
01DA:  RETLW  04
01DB:  RETLW  78
01DC:  RETLW  7C
01DD:  RETLW  08
01DE:  RETLW  04
01DF:  RETLW  04
01E0:  RETLW  78
01E1:  RETLW  38
01E2:  RETLW  44
01E3:  RETLW  44
01E4:  RETLW  44
01E5:  RETLW  38
01E6:  RETLW  7C
01E7:  RETLW  14
01E8:  RETLW  14
01E9:  RETLW  14
01EA:  RETLW  08
01EB:  RETLW  08
01EC:  RETLW  14
01ED:  RETLW  14
01EE:  RETLW  14
01EF:  RETLW  7C
01F0:  RETLW  00
01F1:  RETLW  7C
01F2:  RETLW  08
01F3:  RETLW  04
01F4:  RETLW  04
01F5:  RETLW  48
01F6:  RETLW  54
01F7:  RETLW  54
01F8:  RETLW  54
01F9:  RETLW  20
01FA:  RETLW  04
01FB:  RETLW  04
01FC:  RETLW  3F
01FD:  RETLW  44
01FE:  RETLW  44
01FF:  RETLW  3C
0200:  RETLW  40
0201:  RETLW  40
0202:  RETLW  20
0203:  RETLW  7C
0204:  RETLW  1C
0205:  RETLW  20
0206:  RETLW  40
0207:  RETLW  20
0208:  RETLW  1C
0209:  RETLW  3C
020A:  RETLW  40
020B:  RETLW  30
020C:  RETLW  40
020D:  RETLW  3C
020E:  RETLW  44
020F:  RETLW  28
0210:  RETLW  10
0211:  RETLW  28
0212:  RETLW  44
0213:  RETLW  0C
0214:  RETLW  50
0215:  RETLW  50
0216:  RETLW  50
0217:  RETLW  3C
0218:  RETLW  44
0219:  RETLW  64
021A:  RETLW  54
021B:  RETLW  4C
021C:  RETLW  44
021D:  RETLW  00
021E:  RETLW  08
021F:  RETLW  36
0220:  RETLW  41
0221:  RETLW  41
0222:  RETLW  00
0223:  RETLW  00
0224:  RETLW  7F
0225:  RETLW  00
0226:  RETLW  00
0227:  RETLW  41
0228:  RETLW  41
0229:  RETLW  36
022A:  RETLW  08
022B:  RETLW  00
022C:  RETLW  02
022D:  RETLW  01
022E:  RETLW  02
022F:  RETLW  04
0230:  RETLW  02
0231:  BCF    0A.0
0232:  BSF    0A.1
0233:  BCF    0A.2
0234:  ADDWF  02,F
0235:  RETLW  43
0236:  RETLW  61
0237:  RETLW  70
0238:  RETLW  74
0239:  RETLW  75
023A:  RETLW  72
023B:  RETLW  61
023C:  RETLW  6E
023D:  RETLW  64
023E:  RETLW  6F
023F:  RETLW  00
0240:  BCF    0A.0
0241:  BSF    0A.1
0242:  BCF    0A.2
0243:  ADDWF  02,F
0244:  RETLW  4C
0245:  RETLW  69
0246:  RETLW  6D
0247:  RETLW  70
0248:  RETLW  69
0249:  RETLW  61
024A:  RETLW  6E
024B:  RETLW  64
024C:  RETLW  6F
024D:  RETLW  00
024E:  BCF    0A.0
024F:  BSF    0A.1
0250:  BCF    0A.2
0251:  ADDWF  02,F
0252:  RETLW  47
0253:  RETLW  75
0254:  RETLW  61
0255:  RETLW  72
0256:  RETLW  64
0257:  RETLW  61
0258:  RETLW  6E
0259:  RETLW  64
025A:  RETLW  6F
025B:  RETLW  00
025C:  BCF    0A.0
025D:  BSF    0A.1
025E:  BCF    0A.2
025F:  ADDWF  02,F
0260:  RETLW  54
0261:  RETLW  65
0262:  RETLW  6D
0263:  RETLW  70
0264:  RETLW  65
0265:  RETLW  72
0266:  RETLW  61
0267:  RETLW  74
0268:  RETLW  75
0269:  RETLW  72
026A:  RETLW  61
026B:  RETLW  3A
026C:  RETLW  00
*
02CB:  CLRF   77
02CC:  CLRF   78
02CD:  BSF    03.5
02CE:  BSF    03.6
02CF:  MOVF   19,W
02D0:  BCF    03.0
02D1:  BTFSC  1A.0
02D2:  ADDWF  77,F
02D3:  RRF    77,F
02D4:  RRF    78,F
02D5:  BTFSC  1A.1
02D6:  ADDWF  77,F
02D7:  RRF    77,F
02D8:  RRF    78,F
02D9:  BTFSC  1A.2
02DA:  ADDWF  77,F
02DB:  RRF    77,F
02DC:  RRF    78,F
02DD:  BTFSC  1A.3
02DE:  ADDWF  77,F
02DF:  RRF    77,F
02E0:  RRF    78,F
02E1:  BTFSC  1A.4
02E2:  ADDWF  77,F
02E3:  RRF    77,F
02E4:  RRF    78,F
02E5:  BTFSC  1A.5
02E6:  ADDWF  77,F
02E7:  RRF    77,F
02E8:  RRF    78,F
02E9:  BTFSC  1A.6
02EA:  ADDWF  77,F
02EB:  RRF    77,F
02EC:  RRF    78,F
02ED:  BTFSC  1A.7
02EE:  ADDWF  77,F
02EF:  RRF    77,F
02F0:  RRF    78,F
02F1:  BCF    03.5
02F2:  BCF    03.6
02F3:  RETURN
*
0539:  BSF    03.5
053A:  BSF    03.6
053B:  MOVF   19,W
053C:  BTFSC  03.2
053D:  GOTO   5AB
053E:  MOVWF  21
053F:  MOVF   1D,W
0540:  BTFSC  03.2
0541:  GOTO   5AB
0542:  ADDWF  21,F
0543:  BTFSC  03.0
0544:  GOTO   54C
0545:  MOVLW  7F
0546:  SUBWF  21,F
0547:  BTFSS  03.0
0548:  GOTO   5AB
0549:  BTFSC  03.2
054A:  GOTO   5AB
054B:  GOTO   550
054C:  MOVLW  81
054D:  ADDWF  21,F
054E:  BTFSC  03.0
054F:  GOTO   5AB
0550:  MOVF   21,W
0551:  MOVWF  77
0552:  CLRF   78
0553:  CLRF   79
0554:  CLRF   7A
0555:  MOVF   1A,W
0556:  MOVWF  25
0557:  BSF    25.7
0558:  MOVF   1B,W
0559:  MOVWF  24
055A:  MOVF   1C,W
055B:  MOVWF  23
055C:  MOVLW  18
055D:  MOVWF  21
055E:  CLRF   22
055F:  BTFSS  23.0
0560:  GOTO   579
0561:  MOVF   20,W
0562:  ADDWF  7A,F
0563:  BTFSS  03.0
0564:  GOTO   56B
0565:  INCF   79,F
0566:  BTFSS  03.2
0567:  GOTO   56B
0568:  INCF   78,F
0569:  BTFSC  03.2
056A:  BSF    22.7
056B:  MOVF   1F,W
056C:  ADDWF  79,F
056D:  BTFSS  03.0
056E:  GOTO   572
056F:  INCF   78,F
0570:  BTFSC  03.2
0571:  BSF    22.7
0572:  MOVF   1E,W
0573:  MOVWF  1B
0574:  BSF    1B.7
0575:  MOVF   1B,W
0576:  ADDWF  78,F
0577:  BTFSC  03.0
0578:  BSF    22.7
0579:  RLF    22,F
057A:  RRF    78,F
057B:  RRF    79,F
057C:  RRF    7A,F
057D:  RRF    25,F
057E:  RRF    24,F
057F:  RRF    23,F
0580:  BCF    03.0
0581:  DECFSZ 21,F
0582:  GOTO   55E
0583:  MOVLW  01
0584:  ADDWF  77,F
0585:  BTFSC  03.0
0586:  GOTO   5AB
0587:  BTFSC  78.7
0588:  GOTO   590
0589:  RLF    25,F
058A:  RLF    7A,F
058B:  RLF    79,F
058C:  RLF    78,F
058D:  DECF   77,F
058E:  BTFSC  03.2
058F:  GOTO   5AB
0590:  BTFSS  25.7
0591:  GOTO   5A1
0592:  INCF   7A,F
0593:  BTFSS  03.2
0594:  GOTO   5A1
0595:  INCF   79,F
0596:  BTFSS  03.2
0597:  GOTO   5A1
0598:  INCF   78,F
0599:  BTFSS  03.2
059A:  GOTO   5A1
059B:  RRF    78,F
059C:  RRF    79,F
059D:  RRF    7A,F
059E:  INCF   77,F
059F:  BTFSC  03.2
05A0:  GOTO   5AB
05A1:  MOVF   1A,W
05A2:  MOVWF  22
05A3:  MOVF   1E,W
05A4:  XORWF  22,F
05A5:  BTFSS  22.7
05A6:  GOTO   5A9
05A7:  BSF    78.7
05A8:  GOTO   5AF
05A9:  BCF    78.7
05AA:  GOTO   5AF
05AB:  CLRF   77
05AC:  CLRF   78
05AD:  CLRF   79
05AE:  CLRF   7A
05AF:  BCF    03.5
05B0:  BCF    03.6
05B1:  RETURN
05B2:  BSF    03.5
05B3:  BSF    03.6
05B4:  MOVF   19,W
05B5:  SUBLW  B6
05B6:  MOVWF  19
05B7:  CLRF   7A
05B8:  MOVF   1A,W
05B9:  MOVWF  1D
05BA:  BSF    1A.7
05BB:  BCF    03.0
05BC:  RRF    1A,F
05BD:  RRF    1B,F
05BE:  RRF    1C,F
05BF:  RRF    7A,F
05C0:  RRF    79,F
05C1:  RRF    78,F
05C2:  RRF    77,F
05C3:  DECFSZ 19,F
05C4:  GOTO   5BB
05C5:  BTFSS  1D.7
05C6:  GOTO   5D2
05C7:  COMF   77,F
05C8:  COMF   78,F
05C9:  COMF   79,F
05CA:  COMF   7A,F
05CB:  INCF   77,F
05CC:  BTFSC  03.2
05CD:  INCF   78,F
05CE:  BTFSC  03.2
05CF:  INCF   79,F
05D0:  BTFSC  03.2
05D1:  INCF   7A,F
05D2:  BCF    03.5
05D3:  BCF    03.6
05D4:  RETURN
05D5:  BTFSC  03.1
05D6:  GOTO   5DA
05D7:  MOVLW  A1
05D8:  MOVWF  04
05D9:  BSF    03.7
05DA:  CLRF   77
05DB:  CLRF   78
05DC:  CLRF   79
05DD:  CLRF   7A
05DE:  BSF    03.5
05DF:  BSF    03.6
05E0:  CLRF   21
05E1:  CLRF   22
05E2:  CLRF   23
05E3:  CLRF   24
05E4:  MOVF   20,W
05E5:  IORWF  1F,W
05E6:  IORWF  1E,W
05E7:  IORWF  1D,W
05E8:  BTFSC  03.2
05E9:  GOTO   61A
05EA:  MOVLW  20
05EB:  MOVWF  25
05EC:  BCF    03.0
05ED:  RLF    19,F
05EE:  RLF    1A,F
05EF:  RLF    1B,F
05F0:  RLF    1C,F
05F1:  RLF    21,F
05F2:  RLF    22,F
05F3:  RLF    23,F
05F4:  RLF    24,F
05F5:  MOVF   20,W
05F6:  SUBWF  24,W
05F7:  BTFSS  03.2
05F8:  GOTO   603
05F9:  MOVF   1F,W
05FA:  SUBWF  23,W
05FB:  BTFSS  03.2
05FC:  GOTO   603
05FD:  MOVF   1E,W
05FE:  SUBWF  22,W
05FF:  BTFSS  03.2
0600:  GOTO   603
0601:  MOVF   1D,W
0602:  SUBWF  21,W
0603:  BTFSS  03.0
0604:  GOTO   614
0605:  MOVF   1D,W
0606:  SUBWF  21,F
0607:  MOVF   1E,W
0608:  BTFSS  03.0
0609:  INCFSZ 1E,W
060A:  SUBWF  22,F
060B:  MOVF   1F,W
060C:  BTFSS  03.0
060D:  INCFSZ 1F,W
060E:  SUBWF  23,F
060F:  MOVF   20,W
0610:  BTFSS  03.0
0611:  INCFSZ 20,W
0612:  SUBWF  24,F
0613:  BSF    03.0
0614:  RLF    77,F
0615:  RLF    78,F
0616:  RLF    79,F
0617:  RLF    7A,F
0618:  DECFSZ 25,F
0619:  GOTO   5EC
061A:  MOVF   21,W
061B:  MOVWF  00
061C:  INCF   04,F
061D:  MOVF   22,W
061E:  MOVWF  00
061F:  INCF   04,F
0620:  MOVF   23,W
0621:  MOVWF  00
0622:  INCF   04,F
0623:  MOVF   24,W
0624:  MOVWF  00
0625:  BCF    03.5
0626:  BCF    03.6
0627:  RETURN
0628:  MOVF   38,W
0629:  MOVWF  04
062A:  BCF    03.7
062B:  BTFSC  39.0
062C:  BSF    03.7
062D:  BSF    03.5
062E:  BSF    03.6
062F:  MOVF   19,W
0630:  MOVWF  00
0631:  INCF   04,F
0632:  CLRF   00
0633:  BCF    03.5
0634:  BCF    03.6
0635:  INCF   38,F
0636:  BTFSC  03.2
0637:  INCF   39,F
0638:  RETURN
0639:  MOVF   04,W
063A:  BSF    03.5
063B:  BSF    03.6
063C:  MOVWF  10
063D:  BCF    03.5
063E:  MOVF   69,W
063F:  BSF    03.5
0640:  MOVWF  12
0641:  BTFSC  03.2
0642:  GOTO   668
0643:  BCF    03.5
0644:  MOVF   68,W
0645:  BSF    03.5
0646:  MOVWF  1C
0647:  BCF    03.5
0648:  MOVF   67,W
0649:  BSF    03.5
064A:  MOVWF  1B
064B:  BCF    03.5
064C:  MOVF   66,W
064D:  BSF    03.5
064E:  MOVWF  1A
064F:  BCF    03.5
0650:  MOVF   65,W
0651:  BSF    03.5
0652:  MOVWF  19
0653:  CLRF   20
0654:  CLRF   1F
0655:  MOVLW  20
0656:  MOVWF  1E
0657:  MOVLW  82
0658:  MOVWF  1D
0659:  BCF    03.5
065A:  BCF    03.6
065B:  CALL   539
065C:  MOVF   7A,W
065D:  BSF    03.6
065E:  MOVWF  68
065F:  MOVF   79,W
0660:  MOVWF  67
0661:  MOVF   78,W
0662:  MOVWF  66
0663:  MOVF   77,W
0664:  MOVWF  65
0665:  BSF    03.5
0666:  DECFSZ 12,F
0667:  GOTO   643
0668:  BCF    03.5
0669:  MOVF   68,W
066A:  BSF    03.5
066B:  MOVWF  1C
066C:  BCF    03.5
066D:  MOVF   67,W
066E:  BSF    03.5
066F:  MOVWF  1B
0670:  BCF    03.5
0671:  MOVF   66,W
0672:  BSF    03.5
0673:  MOVWF  1A
0674:  BCF    03.5
0675:  MOVF   65,W
0676:  BSF    03.5
0677:  MOVWF  19
0678:  BCF    03.5
0679:  BCF    03.6
067A:  CALL   5B2
067B:  MOVF   7A,W
067C:  BSF    03.6
067D:  MOVWF  68
067E:  MOVF   79,W
067F:  MOVWF  67
0680:  MOVF   78,W
0681:  MOVWF  66
0682:  MOVF   77,W
0683:  MOVWF  65
0684:  BTFSS  68.7
0685:  GOTO   695
0686:  BSF    03.5
0687:  DECF   10,F
0688:  BSF    10.5
0689:  BCF    03.5
068A:  COMF   65,F
068B:  COMF   66,F
068C:  COMF   67,F
068D:  COMF   68,F
068E:  INCF   65,F
068F:  BTFSC  03.2
0690:  INCF   66,F
0691:  BTFSC  03.2
0692:  INCF   67,F
0693:  BTFSC  03.2
0694:  INCF   68,F
0695:  MOVLW  3B
0696:  BSF    03.5
0697:  MOVWF  17
0698:  MOVLW  9A
0699:  MOVWF  16
069A:  MOVLW  CA
069B:  MOVWF  15
069C:  CLRF   14
069D:  MOVLW  0A
069E:  MOVWF  12
069F:  BCF    03.5
06A0:  MOVF   69,W
06A1:  BTFSS  03.2
06A2:  GOTO   6A6
06A3:  BSF    03.5
06A4:  INCF   10,F
06A5:  BCF    03.5
06A6:  BSF    03.1
06A7:  MOVLW  65
06A8:  MOVWF  04
06A9:  BSF    03.7
06AA:  MOVF   68,W
06AB:  BSF    03.5
06AC:  MOVWF  1C
06AD:  BCF    03.5
06AE:  MOVF   67,W
06AF:  BSF    03.5
06B0:  MOVWF  1B
06B1:  BCF    03.5
06B2:  MOVF   66,W
06B3:  BSF    03.5
06B4:  MOVWF  1A
06B5:  BCF    03.5
06B6:  MOVF   65,W
06B7:  BSF    03.5
06B8:  MOVWF  19
06B9:  MOVF   17,W
06BA:  MOVWF  20
06BB:  MOVF   16,W
06BC:  MOVWF  1F
06BD:  MOVF   15,W
06BE:  MOVWF  1E
06BF:  MOVF   14,W
06C0:  MOVWF  1D
06C1:  BCF    03.5
06C2:  BCF    03.6
06C3:  CALL   5D5
06C4:  MOVF   78,W
06C5:  MOVF   77,F
06C6:  BTFSS  03.2
06C7:  GOTO   6E2
06C8:  BSF    03.6
06C9:  INCF   69,W
06CA:  BSF    03.5
06CB:  SUBWF  12,W
06CC:  BTFSS  03.2
06CD:  GOTO   6D1
06CE:  BCF    03.5
06CF:  BCF    03.6
06D0:  GOTO   6E2
06D1:  MOVF   10,W
06D2:  BTFSC  03.2
06D3:  GOTO   6E6
06D4:  ANDLW  0F
06D5:  SUBWF  12,W
06D6:  BTFSC  03.2
06D7:  GOTO   6DA
06D8:  BTFSC  03.0
06D9:  GOTO   732
06DA:  BTFSC  10.7
06DB:  GOTO   732
06DC:  BTFSC  10.6
06DD:  GOTO   6E6
06DE:  MOVLW  20
06DF:  GOTO   72A
06E0:  BCF    03.5
06E1:  BCF    03.6
06E2:  MOVLW  20
06E3:  BSF    03.5
06E4:  BSF    03.6
06E5:  ANDWF  10,F
06E6:  BTFSS  10.5
06E7:  GOTO   6FD
06E8:  BCF    10.5
06E9:  BCF    03.5
06EA:  MOVF   69,W
06EB:  BTFSC  03.2
06EC:  GOTO   6F0
06ED:  BSF    03.5
06EE:  DECF   10,F
06EF:  BCF    03.5
06F0:  MOVF   77,W
06F1:  BSF    03.5
06F2:  MOVWF  10
06F3:  MOVLW  2D
06F4:  MOVWF  19
06F5:  BCF    03.5
06F6:  BCF    03.6
06F7:  CALL   628
06F8:  BSF    03.5
06F9:  BSF    03.6
06FA:  MOVF   10,W
06FB:  MOVWF  77
06FC:  CLRF   10
06FD:  BCF    03.5
06FE:  MOVF   69,W
06FF:  BSF    03.5
0700:  SUBWF  12,W
0701:  BTFSS  03.2
0702:  GOTO   711
0703:  MOVF   77,W
0704:  MOVWF  10
0705:  MOVLW  2E
0706:  MOVWF  19
0707:  BCF    03.5
0708:  BCF    03.6
0709:  CALL   628
070A:  BSF    03.5
070B:  BSF    03.6
070C:  MOVF   10,W
070D:  MOVWF  77
070E:  MOVLW  20
070F:  ANDWF  10,F
0710:  MOVLW  00
0711:  MOVLW  30
0712:  BTFSS  10.5
0713:  GOTO   72A
0714:  BCF    10.5
0715:  BCF    03.5
0716:  MOVF   69,W
0717:  BTFSC  03.2
0718:  GOTO   71C
0719:  BSF    03.5
071A:  DECF   10,F
071B:  BCF    03.5
071C:  MOVF   77,W
071D:  BSF    03.5
071E:  MOVWF  10
071F:  MOVLW  2D
0720:  MOVWF  19
0721:  BCF    03.5
0722:  BCF    03.6
0723:  CALL   628
0724:  BSF    03.5
0725:  BSF    03.6
0726:  MOVF   10,W
0727:  MOVWF  77
0728:  CLRF   10
0729:  MOVLW  30
072A:  ADDWF  77,F
072B:  MOVF   77,W
072C:  MOVWF  19
072D:  BCF    03.5
072E:  BCF    03.6
072F:  CALL   628
0730:  BSF    03.5
0731:  BSF    03.6
0732:  BCF    03.1
0733:  MOVF   17,W
0734:  MOVWF  1C
0735:  MOVF   16,W
0736:  MOVWF  1B
0737:  MOVF   15,W
0738:  MOVWF  1A
0739:  MOVF   14,W
073A:  MOVWF  19
073B:  CLRF   20
073C:  CLRF   1F
073D:  CLRF   1E
073E:  MOVLW  0A
073F:  MOVWF  1D
0740:  BCF    03.5
0741:  BCF    03.6
0742:  CALL   5D5
0743:  MOVF   7A,W
0744:  BSF    03.5
0745:  BSF    03.6
0746:  MOVWF  17
0747:  MOVF   79,W
0748:  MOVWF  16
0749:  MOVF   78,W
074A:  MOVWF  15
074B:  MOVF   77,W
074C:  MOVWF  14
074D:  DECFSZ 12,F
074E:  GOTO   750
074F:  GOTO   752
0750:  BCF    03.5
0751:  GOTO   6A6
0752:  BCF    03.5
0753:  BCF    03.6
0754:  RETURN
0755:  MOVLW  8E
0756:  MOVWF  77
0757:  BSF    03.6
0758:  MOVF   66,W
0759:  MOVWF  78
075A:  MOVF   65,W
075B:  MOVWF  79
075C:  CLRF   7A
075D:  MOVF   78,F
075E:  BTFSS  03.2
075F:  GOTO   76A
0760:  MOVF   79,W
0761:  MOVWF  78
0762:  CLRF   79
0763:  MOVLW  08
0764:  SUBWF  77,F
0765:  MOVF   78,F
0766:  BTFSS  03.2
0767:  GOTO   76A
0768:  CLRF   77
0769:  GOTO   772
076A:  BCF    03.0
076B:  BTFSC  78.7
076C:  GOTO   771
076D:  RLF    79,F
076E:  RLF    78,F
076F:  DECF   77,F
0770:  GOTO   76A
0771:  BCF    78.7
0772:  BCF    03.6
0773:  RETURN
0774:  BSF    03.6
0775:  MOVF   66,W
0776:  MOVWF  6D
0777:  MOVF   6A,W
0778:  XORWF  6D,F
0779:  BTFSS  6D.7
077A:  GOTO   780
077B:  BCF    03.2
077C:  BCF    03.0
077D:  BTFSC  66.7
077E:  BSF    03.0
077F:  GOTO   7B3
0780:  MOVF   66,W
0781:  MOVWF  6D
0782:  MOVF   69,W
0783:  MOVWF  6E
0784:  MOVF   65,W
0785:  SUBWF  6E,F
0786:  BTFSC  03.2
0787:  GOTO   78E
0788:  BTFSS  6D.7
0789:  GOTO   7B3
078A:  MOVF   03,W
078B:  XORLW  01
078C:  MOVWF  03
078D:  GOTO   7B3
078E:  MOVF   6A,W
078F:  MOVWF  6E
0790:  MOVF   66,W
0791:  SUBWF  6E,F
0792:  BTFSC  03.2
0793:  GOTO   79A
0794:  BTFSS  6D.7
0795:  GOTO   7B3
0796:  MOVF   03,W
0797:  XORLW  01
0798:  MOVWF  03
0799:  GOTO   7B3
079A:  MOVF   6B,W
079B:  MOVWF  6E
079C:  MOVF   67,W
079D:  SUBWF  6E,F
079E:  BTFSC  03.2
079F:  GOTO   7A6
07A0:  BTFSS  6D.7
07A1:  GOTO   7B3
07A2:  MOVF   03,W
07A3:  XORLW  01
07A4:  MOVWF  03
07A5:  GOTO   7B3
07A6:  MOVF   6C,W
07A7:  MOVWF  6E
07A8:  MOVF   68,W
07A9:  SUBWF  6E,F
07AA:  BTFSC  03.2
07AB:  GOTO   7B2
07AC:  BTFSS  6D.7
07AD:  GOTO   7B3
07AE:  MOVF   03,W
07AF:  XORLW  01
07B0:  MOVWF  03
07B1:  GOTO   7B3
07B2:  BCF    03.0
07B3:  BCF    03.6
07B4:  RETURN
07B5:  MOVLW  8E
07B6:  MOVWF  77
07B7:  BSF    03.6
07B8:  MOVF   6B,W
07B9:  SUBWF  77,F
07BA:  MOVF   6C,W
07BB:  MOVWF  79
07BC:  MOVF   6D,W
07BD:  MOVWF  78
07BE:  BSF    79.7
07BF:  MOVF   77,F
07C0:  BTFSC  03.2
07C1:  GOTO   7CD
07C2:  BCF    03.0
07C3:  MOVF   79,F
07C4:  BTFSS  03.2
07C5:  GOTO   7C9
07C6:  MOVF   78,F
07C7:  BTFSC  03.2
07C8:  GOTO   7CD
07C9:  RRF    79,F
07CA:  RRF    78,F
07CB:  DECFSZ 77,F
07CC:  GOTO   7C2
07CD:  BTFSS  6C.7
07CE:  GOTO   7D4
07CF:  COMF   78,F
07D0:  COMF   79,F
07D1:  INCF   78,F
07D2:  BTFSC  03.2
07D3:  INCF   79,F
07D4:  BCF    03.6
07D5:  RETURN
*
07E0:  BSF    03.6
07E1:  MOVF   28,W
07E2:  CLRF   78
07E3:  SUBWF  27,W
07E4:  BTFSC  03.0
07E5:  GOTO   7E9
07E6:  MOVF   27,W
07E7:  MOVWF  77
07E8:  GOTO   7F5
07E9:  CLRF   77
07EA:  MOVLW  08
07EB:  MOVWF  29
07EC:  RLF    27,F
07ED:  RLF    77,F
07EE:  MOVF   28,W
07EF:  SUBWF  77,W
07F0:  BTFSC  03.0
07F1:  MOVWF  77
07F2:  RLF    78,F
07F3:  DECFSZ 29,F
07F4:  GOTO   7EC
07F5:  BCF    03.6
07F6:  RETURN
*
0800:  BSF    03.6
0801:  MOVF   69,W
0802:  BTFSC  03.2
0803:  GOTO   0DC
0804:  BSF    03.5
0805:  MOVWF  18
0806:  MOVF   10,W
0807:  BTFSS  03.2
0808:  GOTO   00B
0809:  BCF    03.5
080A:  GOTO   0DC
080B:  SUBWF  18,F
080C:  BTFSC  03.0
080D:  GOTO   00F
080E:  GOTO   016
080F:  MOVLW  7F
0810:  ADDWF  18,F
0811:  BTFSS  03.0
0812:  GOTO   015
0813:  BCF    03.5
0814:  GOTO   0DC
0815:  GOTO   020
0816:  MOVLW  81
0817:  SUBWF  18,F
0818:  BTFSC  03.0
0819:  GOTO   01C
081A:  BCF    03.5
081B:  GOTO   0DC
081C:  BTFSS  03.2
081D:  GOTO   020
081E:  BCF    03.5
081F:  GOTO   0DC
0820:  MOVF   18,W
0821:  MOVWF  77
0822:  CLRF   78
0823:  CLRF   79
0824:  CLRF   7A
0825:  CLRF   17
0826:  BCF    03.5
0827:  MOVF   6A,W
0828:  BSF    03.5
0829:  MOVWF  16
082A:  BSF    16.7
082B:  BCF    03.5
082C:  MOVF   6B,W
082D:  BSF    03.5
082E:  MOVWF  15
082F:  BCF    03.5
0830:  MOVF   6C,W
0831:  BSF    03.5
0832:  MOVWF  14
0833:  MOVLW  19
0834:  MOVWF  18
0835:  MOVF   13,W
0836:  SUBWF  14,F
0837:  BTFSC  03.0
0838:  GOTO   049
0839:  MOVLW  01
083A:  SUBWF  15,F
083B:  BTFSC  03.0
083C:  GOTO   049
083D:  SUBWF  16,F
083E:  BTFSC  03.0
083F:  GOTO   049
0840:  SUBWF  17,F
0841:  BTFSC  03.0
0842:  GOTO   049
0843:  INCF   17,F
0844:  INCF   16,F
0845:  INCF   15,F
0846:  MOVF   13,W
0847:  ADDWF  14,F
0848:  GOTO   07B
0849:  MOVF   12,W
084A:  SUBWF  15,F
084B:  BTFSC  03.0
084C:  GOTO   064
084D:  MOVLW  01
084E:  SUBWF  16,F
084F:  BTFSC  03.0
0850:  GOTO   064
0851:  SUBWF  17,F
0852:  BTFSC  03.0
0853:  GOTO   064
0854:  INCF   17,F
0855:  INCF   16,F
0856:  MOVF   12,W
0857:  ADDWF  15,F
0858:  MOVF   13,W
0859:  ADDWF  14,F
085A:  BTFSS  03.0
085B:  GOTO   07B
085C:  INCF   15,F
085D:  BTFSS  03.2
085E:  GOTO   07B
085F:  INCF   16,F
0860:  BTFSS  03.2
0861:  GOTO   07B
0862:  INCF   17,F
0863:  GOTO   07B
0864:  MOVF   11,W
0865:  IORLW  80
0866:  SUBWF  16,F
0867:  BTFSC  03.0
0868:  GOTO   07A
0869:  MOVLW  01
086A:  SUBWF  17,F
086B:  BTFSC  03.0
086C:  GOTO   07A
086D:  INCF   17,F
086E:  MOVF   11,W
086F:  IORLW  80
0870:  ADDWF  16,F
0871:  MOVF   12,W
0872:  ADDWF  15,F
0873:  BTFSS  03.0
0874:  GOTO   058
0875:  INCF   16,F
0876:  BTFSS  03.2
0877:  GOTO   058
0878:  INCF   17,F
0879:  GOTO   058
087A:  BSF    7A.0
087B:  DECFSZ 18,F
087C:  GOTO   07E
087D:  GOTO   089
087E:  BCF    03.0
087F:  RLF    14,F
0880:  RLF    15,F
0881:  RLF    16,F
0882:  RLF    17,F
0883:  BCF    03.0
0884:  RLF    7A,F
0885:  RLF    79,F
0886:  RLF    78,F
0887:  RLF    19,F
0888:  GOTO   035
0889:  BTFSS  19.0
088A:  GOTO   091
088B:  BCF    03.0
088C:  RRF    78,F
088D:  RRF    79,F
088E:  RRF    7A,F
088F:  RRF    19,F
0890:  GOTO   095
0891:  DECFSZ 77,F
0892:  GOTO   095
0893:  BCF    03.5
0894:  GOTO   0DC
0895:  BTFSC  19.7
0896:  GOTO   0BE
0897:  BCF    03.0
0898:  RLF    14,F
0899:  RLF    15,F
089A:  RLF    16,F
089B:  RLF    17,F
089C:  MOVF   13,W
089D:  SUBWF  14,F
089E:  BTFSC  03.0
089F:  GOTO   0AA
08A0:  MOVLW  01
08A1:  SUBWF  15,F
08A2:  BTFSC  03.0
08A3:  GOTO   0AA
08A4:  SUBWF  16,F
08A5:  BTFSC  03.0
08A6:  GOTO   0AA
08A7:  SUBWF  17,F
08A8:  BTFSS  03.0
08A9:  GOTO   0CF
08AA:  MOVF   12,W
08AB:  SUBWF  15,F
08AC:  BTFSC  03.0
08AD:  GOTO   0B5
08AE:  MOVLW  01
08AF:  SUBWF  16,F
08B0:  BTFSC  03.0
08B1:  GOTO   0B5
08B2:  SUBWF  17,F
08B3:  BTFSS  03.0
08B4:  GOTO   0CF
08B5:  MOVF   11,W
08B6:  IORLW  80
08B7:  SUBWF  16,F
08B8:  BTFSC  03.0
08B9:  GOTO   0BE
08BA:  MOVLW  01
08BB:  SUBWF  17,F
08BC:  BTFSS  03.0
08BD:  GOTO   0CF
08BE:  INCF   7A,F
08BF:  BTFSS  03.2
08C0:  GOTO   0CF
08C1:  INCF   79,F
08C2:  BTFSS  03.2
08C3:  GOTO   0CF
08C4:  INCF   78,F
08C5:  BTFSS  03.2
08C6:  GOTO   0CF
08C7:  INCF   77,F
08C8:  BTFSS  03.2
08C9:  GOTO   0CC
08CA:  BCF    03.5
08CB:  GOTO   0DC
08CC:  RRF    78,F
08CD:  RRF    79,F
08CE:  RRF    7A,F
08CF:  BCF    03.5
08D0:  MOVF   6A,W
08D1:  BSF    03.5
08D2:  MOVWF  18
08D3:  MOVF   11,W
08D4:  XORWF  18,F
08D5:  BTFSS  18.7
08D6:  GOTO   0D9
08D7:  BSF    78.7
08D8:  GOTO   0E1
08D9:  BCF    78.7
08DA:  GOTO   0E1
08DB:  BCF    03.5
08DC:  CLRF   77
08DD:  CLRF   78
08DE:  CLRF   79
08DF:  CLRF   7A
08E0:  BSF    03.5
08E1:  BCF    03.5
08E2:  BCF    03.6
08E3:  RETURN
08E4:  MOVLW  80
08E5:  BTFSS  03.1
08E6:  GOTO   0EC
08E7:  BSF    03.5
08E8:  BSF    03.6
08E9:  XORWF  15,F
08EA:  BCF    03.5
08EB:  BCF    03.6
08EC:  BSF    03.5
08ED:  BSF    03.6
08EE:  CLRF   1A
08EF:  CLRF   1B
08F0:  MOVF   11,W
08F1:  MOVWF  19
08F2:  MOVF   15,W
08F3:  XORWF  19,F
08F4:  MOVF   10,W
08F5:  BTFSC  03.2
08F6:  GOTO   1DB
08F7:  MOVWF  18
08F8:  MOVWF  77
08F9:  MOVF   14,W
08FA:  BTFSC  03.2
08FB:  GOTO   1E4
08FC:  SUBWF  18,F
08FD:  BTFSC  03.2
08FE:  GOTO   180
08FF:  BTFSS  03.0
0900:  GOTO   13E
0901:  MOVF   15,W
0902:  MOVWF  1E
0903:  BSF    1E.7
0904:  MOVF   16,W
0905:  MOVWF  1D
0906:  MOVF   17,W
0907:  MOVWF  1C
0908:  CLRF   1B
0909:  BCF    03.0
090A:  RRF    1E,F
090B:  RRF    1D,F
090C:  RRF    1C,F
090D:  RRF    1B,F
090E:  DECFSZ 18,F
090F:  GOTO   108
0910:  BTFSS  19.7
0911:  GOTO   115
0912:  BSF    1A.0
0913:  GOTO   1F8
0914:  BCF    1A.0
0915:  BCF    18.0
0916:  BSF    1A.4
0917:  MOVLW  93
0918:  MOVWF  04
0919:  BSF    03.7
091A:  GOTO   20D
091B:  BCF    1A.4
091C:  BTFSC  19.7
091D:  GOTO   128
091E:  BTFSS  18.0
091F:  GOTO   133
0920:  RRF    1E,F
0921:  RRF    1D,F
0922:  RRF    1C,F
0923:  RRF    1B,F
0924:  INCF   77,F
0925:  BTFSC  03.2
0926:  GOTO   1F3
0927:  GOTO   133
0928:  BTFSC  1E.7
0929:  GOTO   136
092A:  BCF    03.0
092B:  RLF    1B,F
092C:  RLF    1C,F
092D:  RLF    1D,F
092E:  RLF    1E,F
092F:  DECF   77,F
0930:  BTFSC  03.2
0931:  GOTO   1F3
0932:  GOTO   128
0933:  BSF    1A.6
0934:  GOTO   1A0
0935:  BCF    1A.6
0936:  MOVF   11,W
0937:  MOVWF  19
0938:  BTFSS  19.7
0939:  GOTO   13C
093A:  BSF    1E.7
093B:  GOTO   1EC
093C:  BCF    1E.7
093D:  GOTO   1EC
093E:  MOVF   14,W
093F:  MOVWF  18
0940:  MOVWF  77
0941:  MOVF   10,W
0942:  SUBWF  18,F
0943:  MOVF   11,W
0944:  MOVWF  1E
0945:  BSF    1E.7
0946:  MOVF   12,W
0947:  MOVWF  1D
0948:  MOVF   13,W
0949:  MOVWF  1C
094A:  CLRF   1B
094B:  BCF    03.0
094C:  RRF    1E,F
094D:  RRF    1D,F
094E:  RRF    1C,F
094F:  RRF    1B,F
0950:  DECFSZ 18,F
0951:  GOTO   14A
0952:  BTFSS  19.7
0953:  GOTO   157
0954:  BSF    1A.1
0955:  GOTO   1F8
0956:  BCF    1A.1
0957:  BCF    18.0
0958:  BSF    1A.5
0959:  MOVLW  97
095A:  MOVWF  04
095B:  BSF    03.7
095C:  GOTO   20D
095D:  BCF    1A.5
095E:  BTFSC  19.7
095F:  GOTO   16A
0960:  BTFSS  18.0
0961:  GOTO   175
0962:  RRF    1E,F
0963:  RRF    1D,F
0964:  RRF    1C,F
0965:  RRF    1B,F
0966:  INCF   77,F
0967:  BTFSC  03.2
0968:  GOTO   1F3
0969:  GOTO   175
096A:  BTFSC  1E.7
096B:  GOTO   178
096C:  BCF    03.0
096D:  RLF    1B,F
096E:  RLF    1C,F
096F:  RLF    1D,F
0970:  RLF    1E,F
0971:  DECF   77,F
0972:  BTFSC  03.2
0973:  GOTO   1F3
0974:  GOTO   16A
0975:  BSF    1A.7
0976:  GOTO   1A0
0977:  BCF    1A.7
0978:  MOVF   15,W
0979:  MOVWF  19
097A:  BTFSS  19.7
097B:  GOTO   17E
097C:  BSF    1E.7
097D:  GOTO   1EC
097E:  BCF    1E.7
097F:  GOTO   1EC
0980:  MOVF   15,W
0981:  MOVWF  1E
0982:  BSF    1E.7
0983:  MOVF   16,W
0984:  MOVWF  1D
0985:  MOVF   17,W
0986:  MOVWF  1C
0987:  BTFSS  19.7
0988:  GOTO   18D
0989:  BCF    1E.7
098A:  BSF    1A.2
098B:  GOTO   1F8
098C:  BCF    1A.2
098D:  CLRF   1B
098E:  BCF    18.0
098F:  MOVLW  93
0990:  MOVWF  04
0991:  BSF    03.7
0992:  GOTO   20D
0993:  BTFSC  19.7
0994:  GOTO   1B6
0995:  MOVF   11,W
0996:  MOVWF  19
0997:  BTFSS  18.0
0998:  GOTO   1A0
0999:  RRF    1E,F
099A:  RRF    1D,F
099B:  RRF    1C,F
099C:  RRF    1B,F
099D:  INCF   77,F
099E:  BTFSC  03.2
099F:  GOTO   1F3
09A0:  BTFSS  1B.7
09A1:  GOTO   1B1
09A2:  INCF   1C,F
09A3:  BTFSS  03.2
09A4:  GOTO   1B1
09A5:  INCF   1D,F
09A6:  BTFSS  03.2
09A7:  GOTO   1B1
09A8:  INCF   1E,F
09A9:  BTFSS  03.2
09AA:  GOTO   1B1
09AB:  RRF    1E,F
09AC:  RRF    1D,F
09AD:  RRF    1C,F
09AE:  INCF   77,F
09AF:  BTFSC  03.2
09B0:  GOTO   1F3
09B1:  BTFSC  1A.6
09B2:  GOTO   135
09B3:  BTFSC  1A.7
09B4:  GOTO   177
09B5:  GOTO   1D5
09B6:  MOVLW  80
09B7:  XORWF  1E,F
09B8:  BTFSS  1E.7
09B9:  GOTO   1BE
09BA:  GOTO   1F8
09BB:  MOVF   15,W
09BC:  MOVWF  19
09BD:  GOTO   1CB
09BE:  MOVF   11,W
09BF:  MOVWF  19
09C0:  MOVF   1E,F
09C1:  BTFSS  03.2
09C2:  GOTO   1CB
09C3:  MOVF   1D,F
09C4:  BTFSS  03.2
09C5:  GOTO   1CB
09C6:  MOVF   1C,F
09C7:  BTFSS  03.2
09C8:  GOTO   1CB
09C9:  CLRF   77
09CA:  GOTO   1EC
09CB:  BTFSC  1E.7
09CC:  GOTO   1D5
09CD:  BCF    03.0
09CE:  RLF    1B,F
09CF:  RLF    1C,F
09D0:  RLF    1D,F
09D1:  RLF    1E,F
09D2:  DECFSZ 77,F
09D3:  GOTO   1CB
09D4:  GOTO   1F3
09D5:  BTFSS  19.7
09D6:  GOTO   1D9
09D7:  BSF    1E.7
09D8:  GOTO   1EC
09D9:  BCF    1E.7
09DA:  GOTO   1EC
09DB:  MOVF   14,W
09DC:  MOVWF  77
09DD:  MOVF   15,W
09DE:  MOVWF  1E
09DF:  MOVF   16,W
09E0:  MOVWF  1D
09E1:  MOVF   17,W
09E2:  MOVWF  1C
09E3:  GOTO   1EC
09E4:  MOVF   10,W
09E5:  MOVWF  77
09E6:  MOVF   11,W
09E7:  MOVWF  1E
09E8:  MOVF   12,W
09E9:  MOVWF  1D
09EA:  MOVF   13,W
09EB:  MOVWF  1C
09EC:  MOVF   1E,W
09ED:  MOVWF  78
09EE:  MOVF   1D,W
09EF:  MOVWF  79
09F0:  MOVF   1C,W
09F1:  MOVWF  7A
09F2:  GOTO   22B
09F3:  CLRF   77
09F4:  CLRF   78
09F5:  CLRF   79
09F6:  CLRF   7A
09F7:  GOTO   22B
09F8:  CLRF   1B
09F9:  COMF   1C,F
09FA:  COMF   1D,F
09FB:  COMF   1E,F
09FC:  COMF   1B,F
09FD:  INCF   1B,F
09FE:  BTFSS  03.2
09FF:  GOTO   206
0A00:  INCF   1C,F
0A01:  BTFSS  03.2
0A02:  GOTO   206
0A03:  INCF   1D,F
0A04:  BTFSC  03.2
0A05:  INCF   1E,F
0A06:  BTFSC  1A.0
0A07:  GOTO   114
0A08:  BTFSC  1A.1
0A09:  GOTO   156
0A0A:  BTFSC  1A.2
0A0B:  GOTO   18C
0A0C:  GOTO   1BB
0A0D:  MOVF   00,W
0A0E:  ADDWF  1C,F
0A0F:  BTFSS  03.0
0A10:  GOTO   217
0A11:  INCF   1D,F
0A12:  BTFSS  03.2
0A13:  GOTO   217
0A14:  INCF   1E,F
0A15:  BTFSC  03.2
0A16:  BSF    18.0
0A17:  DECF   04,F
0A18:  MOVF   00,W
0A19:  ADDWF  1D,F
0A1A:  BTFSS  03.0
0A1B:  GOTO   21F
0A1C:  INCF   1E,F
0A1D:  BTFSC  03.2
0A1E:  BSF    18.0
0A1F:  DECF   04,F
0A20:  MOVF   00,W
0A21:  BTFSS  00.7
0A22:  XORLW  80
0A23:  ADDWF  1E,F
0A24:  BTFSC  03.0
0A25:  BSF    18.0
0A26:  BTFSC  1A.4
0A27:  GOTO   11B
0A28:  BTFSC  1A.5
0A29:  GOTO   15D
0A2A:  GOTO   193
0A2B:  BCF    03.5
0A2C:  BCF    03.6
0A2D:  RETURN
*
12B3:  MOVLW  20
12B4:  BTFSS  22.4
12B5:  MOVLW  30
12B6:  MOVWF  23
12B7:  MOVF   21,W
12B8:  MOVWF  77
12B9:  BTFSS  21.7
12BA:  GOTO   2C3
12BB:  COMF   77,F
12BC:  INCF   77,F
12BD:  MOVF   77,W
12BE:  MOVWF  21
12BF:  MOVLW  2D
12C0:  MOVWF  23
12C1:  BSF    22.7
12C2:  BSF    22.0
12C3:  MOVF   21,W
12C4:  MOVWF  27
12C5:  MOVLW  64
12C6:  MOVWF  28
12C7:  BCF    0A.4
12C8:  BCF    03.6
12C9:  CALL   7E0
12CA:  BSF    0A.4
12CB:  MOVF   77,W
12CC:  BSF    03.6
12CD:  MOVWF  21
12CE:  MOVLW  30
12CF:  ADDWF  78,W
12D0:  MOVWF  24
12D1:  MOVF   21,W
12D2:  MOVWF  27
12D3:  MOVLW  0A
12D4:  MOVWF  28
12D5:  BCF    0A.4
12D6:  BCF    03.6
12D7:  CALL   7E0
12D8:  BSF    0A.4
12D9:  MOVLW  30
12DA:  ADDWF  77,W
12DB:  BSF    03.6
12DC:  MOVWF  26
12DD:  MOVLW  30
12DE:  ADDWF  78,W
12DF:  MOVWF  25
12E0:  MOVF   23,W
12E1:  MOVWF  77
12E2:  MOVLW  30
12E3:  SUBWF  24,W
12E4:  BTFSC  03.2
12E5:  GOTO   2EA
12E6:  BSF    22.1
12E7:  BTFSC  22.7
12E8:  BSF    22.2
12E9:  GOTO   2FE
12EA:  MOVF   23,W
12EB:  MOVWF  24
12EC:  MOVLW  20
12ED:  MOVWF  23
12EE:  MOVLW  30
12EF:  SUBWF  25,W
12F0:  BTFSC  03.2
12F1:  GOTO   2F6
12F2:  BSF    22.0
12F3:  BTFSC  22.7
12F4:  BSF    22.1
12F5:  GOTO   2FE
12F6:  BTFSS  03.2
12F7:  BSF    22.0
12F8:  BTFSS  03.2
12F9:  GOTO   2FE
12FA:  MOVF   24,W
12FB:  MOVWF  25
12FC:  MOVLW  20
12FD:  MOVWF  24
12FE:  BTFSC  22.2
12FF:  GOTO   305
1300:  BTFSC  22.1
1301:  GOTO   316
1302:  BTFSC  22.0
1303:  GOTO   327
1304:  GOTO   338
1305:  BCF    03.6
1306:  CLRF   27
1307:  BTFSC  0B.7
1308:  BSF    27.7
1309:  BCF    0B.7
130A:  BSF    03.6
130B:  MOVF   23,W
130C:  BSF    03.5
130D:  MOVWF  19
130E:  BCF    0A.4
130F:  BCF    03.5
1310:  BCF    03.6
1311:  CALL   628
1312:  BSF    0A.4
1313:  BTFSC  27.7
1314:  BSF    0B.7
1315:  BSF    03.6
1316:  BCF    03.6
1317:  CLRF   27
1318:  BTFSC  0B.7
1319:  BSF    27.7
131A:  BCF    0B.7
131B:  BSF    03.6
131C:  MOVF   24,W
131D:  BSF    03.5
131E:  MOVWF  19
131F:  BCF    0A.4
1320:  BCF    03.5
1321:  BCF    03.6
1322:  CALL   628
1323:  BSF    0A.4
1324:  BTFSC  27.7
1325:  BSF    0B.7
1326:  BSF    03.6
1327:  BCF    03.6
1328:  CLRF   27
1329:  BTFSC  0B.7
132A:  BSF    27.7
132B:  BCF    0B.7
132C:  BSF    03.6
132D:  MOVF   25,W
132E:  BSF    03.5
132F:  MOVWF  19
1330:  BCF    0A.4
1331:  BCF    03.5
1332:  BCF    03.6
1333:  CALL   628
1334:  BSF    0A.4
1335:  BTFSC  27.7
1336:  BSF    0B.7
1337:  BSF    03.6
1338:  BCF    03.6
1339:  CLRF   27
133A:  BTFSC  0B.7
133B:  BSF    27.7
133C:  BCF    0B.7
133D:  BSF    03.6
133E:  MOVF   26,W
133F:  BSF    03.5
1340:  MOVWF  19
1341:  BCF    0A.4
1342:  BCF    03.5
1343:  BCF    03.6
1344:  CALL   628
1345:  BSF    0A.4
1346:  BTFSC  27.7
1347:  BSF    0B.7
1348:  CLRF   27
1349:  BTFSC  0B.7
134A:  BSF    27.7
134B:  BCF    0B.7
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=4000000) 
*
026D:  MOVLW  3D
026E:  MOVWF  04
026F:  BSF    03.7
0270:  MOVF   00,W
0271:  BTFSC  03.2
0272:  GOTO   281
0273:  MOVLW  01
0274:  MOVWF  78
0275:  CLRF   77
0276:  DECFSZ 77,F
0277:  GOTO   276
0278:  DECFSZ 78,F
0279:  GOTO   275
027A:  MOVLW  4A
027B:  MOVWF  77
027C:  DECFSZ 77,F
027D:  GOTO   27C
027E:  GOTO   27F
027F:  DECFSZ 00,F
0280:  GOTO   273
0281:  RETURN
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, bits=8, parity=N) 
....................  
.................... #fuses XT, NOWDT,NOPROTECT,NOLVP 
.................... #include <HDM64GS12.c> //Manejo del display gráfico 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
1000:  BCF    28.0
1001:  MOVF   28,W
1002:  BSF    03.5
1003:  MOVWF  07
1004:  BCF    03.5
1005:  BSF    07.0
....................    output_low(GLCD_E); 
1006:  BSF    03.5
1007:  BCF    06.5
1008:  BCF    03.5
1009:  BCF    06.5
....................    output_low(GLCD_CS1); 
100A:  BSF    03.5
100B:  BCF    06.0
100C:  BCF    03.5
100D:  BCF    06.0
....................    output_low(GLCD_CS2); 
100E:  BSF    03.5
100F:  BCF    06.1
1010:  BCF    03.5
1011:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
1012:  BSF    03.5
1013:  BCF    06.2
1014:  BCF    03.5
1015:  BCF    06.2
1016:  CLRF   27
1017:  BTFSC  0B.7
1018:  BSF    27.7
1019:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
101A:  BSF    03.5
101B:  BSF    03.6
101C:  CLRF   24
101D:  MOVLW  C0
101E:  MOVWF  25
101F:  BCF    0A.4
1020:  BCF    03.5
1021:  BCF    03.6
1022:  CALL   2F4
1023:  BSF    0A.4
1024:  BTFSC  27.7
1025:  BSF    0B.7
1026:  CLRF   27
1027:  BTFSC  0B.7
1028:  BSF    27.7
1029:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
102A:  MOVLW  01
102B:  BSF    03.5
102C:  BSF    03.6
102D:  MOVWF  24
102E:  MOVLW  C0
102F:  MOVWF  25
1030:  BCF    0A.4
1031:  BCF    03.5
1032:  BCF    03.6
1033:  CALL   2F4
1034:  BSF    0A.4
1035:  BTFSC  27.7
1036:  BSF    0B.7
1037:  CLRF   27
1038:  BTFSC  0B.7
1039:  BSF    27.7
103A:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
103B:  BSF    03.5
103C:  BSF    03.6
103D:  CLRF   24
103E:  MOVLW  40
103F:  MOVWF  25
1040:  BCF    0A.4
1041:  BCF    03.5
1042:  BCF    03.6
1043:  CALL   2F4
1044:  BSF    0A.4
1045:  BTFSC  27.7
1046:  BSF    0B.7
1047:  CLRF   27
1048:  BTFSC  0B.7
1049:  BSF    27.7
104A:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
104B:  MOVLW  01
104C:  BSF    03.5
104D:  BSF    03.6
104E:  MOVWF  24
104F:  MOVLW  40
1050:  MOVWF  25
1051:  BCF    0A.4
1052:  BCF    03.5
1053:  BCF    03.6
1054:  CALL   2F4
1055:  BSF    0A.4
1056:  BTFSC  27.7
1057:  BSF    0B.7
1058:  CLRF   27
1059:  BTFSC  0B.7
105A:  BSF    27.7
105B:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
105C:  BSF    03.5
105D:  BSF    03.6
105E:  CLRF   24
105F:  MOVLW  B8
1060:  MOVWF  25
1061:  BCF    0A.4
1062:  BCF    03.5
1063:  BCF    03.6
1064:  CALL   2F4
1065:  BSF    0A.4
1066:  BTFSC  27.7
1067:  BSF    0B.7
1068:  CLRF   27
1069:  BTFSC  0B.7
106A:  BSF    27.7
106B:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
106C:  MOVLW  01
106D:  BSF    03.5
106E:  BSF    03.6
106F:  MOVWF  24
1070:  MOVLW  B8
1071:  MOVWF  25
1072:  BCF    0A.4
1073:  BCF    03.5
1074:  BCF    03.6
1075:  CALL   2F4
1076:  BSF    0A.4
1077:  BTFSC  27.7
1078:  BSF    0B.7
....................  
....................    if(mode == ON) 
1079:  BSF    03.6
107A:  DECFSZ 1D,W
107B:  GOTO   0A0
107C:  BCF    03.6
107D:  CLRF   27
107E:  BTFSC  0B.7
107F:  BSF    27.7
1080:  BCF    0B.7
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
1081:  BSF    03.5
1082:  BSF    03.6
1083:  CLRF   24
1084:  MOVLW  3F
1085:  MOVWF  25
1086:  BCF    0A.4
1087:  BCF    03.5
1088:  BCF    03.6
1089:  CALL   2F4
108A:  BSF    0A.4
108B:  BTFSC  27.7
108C:  BSF    0B.7
108D:  CLRF   27
108E:  BTFSC  0B.7
108F:  BSF    27.7
1090:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
1091:  MOVLW  01
1092:  BSF    03.5
1093:  BSF    03.6
1094:  MOVWF  24
1095:  MOVLW  3F
1096:  MOVWF  25
1097:  BCF    0A.4
1098:  BCF    03.5
1099:  BCF    03.6
109A:  CALL   2F4
109B:  BSF    0A.4
109C:  BTFSC  27.7
109D:  BSF    0B.7
....................    } 
109E:  GOTO   0C2
109F:  BSF    03.6
10A0:  BCF    03.6
10A1:  CLRF   27
10A2:  BTFSC  0B.7
10A3:  BSF    27.7
10A4:  BCF    0B.7
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
10A5:  BSF    03.5
10A6:  BSF    03.6
10A7:  CLRF   24
10A8:  MOVLW  3E
10A9:  MOVWF  25
10AA:  BCF    0A.4
10AB:  BCF    03.5
10AC:  BCF    03.6
10AD:  CALL   2F4
10AE:  BSF    0A.4
10AF:  BTFSC  27.7
10B0:  BSF    0B.7
10B1:  CLRF   27
10B2:  BTFSC  0B.7
10B3:  BSF    27.7
10B4:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
10B5:  MOVLW  01
10B6:  BSF    03.5
10B7:  BSF    03.6
10B8:  MOVWF  24
10B9:  MOVLW  3E
10BA:  MOVWF  25
10BB:  BCF    0A.4
10BC:  BCF    03.5
10BD:  BCF    03.6
10BE:  CALL   2F4
10BF:  BSF    0A.4
10C0:  BTFSC  27.7
10C1:  BSF    0B.7
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
10C2:  BSF    03.6
10C3:  CLRF   1E
....................  
....................    #ifdef FAST_GLCD 
*
1181:  BCF    03.6
1182:  BCF    0A.3
1183:  BSF    0A.4
1184:  GOTO   3CA (RETURN)
....................    glcd_update(); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
*
0325:  BSF    03.5
0326:  BSF    03.6
0327:  BCF    21.0
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
0328:  MOVF   1D,W
0329:  SUBLW  3F
032A:  BTFSC  03.0
032B:  GOTO   32F
....................    { 
....................       x -= 64; 
032C:  MOVLW  40
032D:  SUBWF  1D,F
....................       side = GLCD_RIGHT; 
032E:  BSF    21.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
032F:  BCF    03.6
0330:  BCF    06.2
0331:  BCF    03.5
0332:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0333:  BSF    03.5
0334:  BSF    03.6
0335:  BCF    1D.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0336:  BSF    1D.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
0337:  MOVLW  00
0338:  BTFSC  21.0
0339:  MOVLW  01
033A:  MOVWF  22
033B:  MOVWF  24
033C:  MOVF   1D,W
033D:  MOVWF  25
033E:  BCF    03.5
033F:  BCF    03.6
0340:  CALL   2F4
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
0341:  MOVLW  00
0342:  BSF    03.5
0343:  BSF    03.6
0344:  BTFSC  21.0
0345:  MOVLW  01
0346:  MOVWF  22
0347:  RRF    1E,W
0348:  MOVWF  77
0349:  RRF    77,F
034A:  RRF    77,F
034B:  MOVLW  1F
034C:  ANDWF  77,F
034D:  MOVF   77,W
034E:  ANDLW  BF
034F:  IORLW  B8
0350:  MOVWF  23
0351:  MOVF   22,W
0352:  MOVWF  24
0353:  MOVF   23,W
0354:  MOVWF  25
0355:  BCF    03.5
0356:  BCF    03.6
0357:  CALL   2F4
....................    output_high(GLCD_DI);                        // Set for data 
0358:  BSF    03.5
0359:  BCF    06.2
035A:  BCF    03.5
035B:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
035C:  MOVLW  00
035D:  BSF    03.5
035E:  BSF    03.6
035F:  BTFSC  21.0
0360:  MOVLW  01
0361:  MOVWF  22
0362:  MOVF   22,W
0363:  MOVWF  23
....................    data = glcd_readByte(side);                  //  at new address 
*
0398:  MOVLW  00
0399:  BTFSC  21.0
039A:  MOVLW  01
039B:  MOVWF  22
039C:  MOVF   22,W
039D:  MOVWF  23
*
03D2:  MOVF   78,W
03D3:  MOVWF  20
....................  
....................    if(color == ON) 
03D4:  DECFSZ 1F,W
03D5:  GOTO   3E6
....................       bit_set(data, y%8);        // Turn the pixel on 
03D6:  MOVF   1E,W
03D7:  ANDLW  07
03D8:  MOVWF  22
03D9:  MOVLW  01
03DA:  MOVWF  77
03DB:  MOVF   22,W
03DC:  MOVWF  78
03DD:  BTFSC  03.2
03DE:  GOTO   3E3
03DF:  BCF    03.0
03E0:  RLF    77,F
03E1:  DECFSZ 78,F
03E2:  GOTO   3DF
03E3:  MOVF   77,W
03E4:  IORWF  20,F
03E5:  GOTO   3F6
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
03E6:  MOVF   1E,W
03E7:  ANDLW  07
03E8:  MOVWF  22
03E9:  MOVLW  01
03EA:  MOVWF  77
03EB:  MOVF   22,W
03EC:  MOVWF  78
03ED:  BTFSC  03.2
03EE:  GOTO   3F3
03EF:  BCF    03.0
03F0:  RLF    77,F
03F1:  DECFSZ 78,F
03F2:  GOTO   3EF
03F3:  MOVF   77,W
03F4:  XORLW  FF
03F5:  ANDWF  20,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
03F6:  BCF    03.6
03F7:  BCF    06.2
03F8:  BCF    03.5
03F9:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
03FA:  MOVLW  00
03FB:  BSF    03.5
03FC:  BSF    03.6
03FD:  BTFSC  21.0
03FE:  MOVLW  01
03FF:  MOVWF  22
0400:  MOVWF  24
0401:  MOVF   1D,W
0402:  MOVWF  25
0403:  BCF    03.5
0404:  BCF    03.6
0405:  CALL   2F4
....................    output_high(GLCD_DI);         // Set for data 
0406:  BSF    03.5
0407:  BCF    06.2
0408:  BCF    03.5
0409:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
040A:  MOVLW  00
040B:  BSF    03.5
040C:  BSF    03.6
040D:  BTFSC  21.0
040E:  MOVLW  01
040F:  MOVWF  22
0410:  MOVWF  24
0411:  MOVF   20,W
0412:  MOVWF  25
0413:  BCF    03.5
0414:  BCF    03.6
0415:  CALL   2F4
0416:  RETURN
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
10C4:  CLRF   1F
10C5:  MOVF   1F,W
10C6:  SUBLW  07
10C7:  BTFSS  03.0
10C8:  GOTO   181
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
10C9:  BSF    03.5
10CA:  BCF    03.6
10CB:  BCF    06.2
10CC:  BCF    03.5
10CD:  BCF    06.2
10CE:  CLRF   27
10CF:  BTFSC  0B.7
10D0:  BSF    27.7
10D1:  BCF    0B.7
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
10D2:  BSF    03.5
10D3:  BSF    03.6
10D4:  CLRF   24
10D5:  MOVLW  40
10D6:  MOVWF  25
10D7:  BCF    0A.4
10D8:  BCF    03.5
10D9:  BCF    03.6
10DA:  CALL   2F4
10DB:  BSF    0A.4
10DC:  BTFSC  27.7
10DD:  BSF    0B.7
10DE:  CLRF   27
10DF:  BTFSC  0B.7
10E0:  BSF    27.7
10E1:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
10E2:  MOVLW  01
10E3:  BSF    03.5
10E4:  BSF    03.6
10E5:  MOVWF  24
10E6:  MOVLW  40
10E7:  MOVWF  25
10E8:  BCF    0A.4
10E9:  BCF    03.5
10EA:  BCF    03.6
10EB:  CALL   2F4
10EC:  BSF    0A.4
10ED:  BTFSC  27.7
10EE:  BSF    0B.7
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
10EF:  BSF    03.6
10F0:  MOVF   1F,W
10F1:  IORLW  B8
10F2:  MOVWF  21
10F3:  BCF    03.6
10F4:  CLRF   27
10F5:  BTFSC  0B.7
10F6:  BSF    27.7
10F7:  BCF    0B.7
10F8:  BSF    03.5
10F9:  BSF    03.6
10FA:  CLRF   24
10FB:  BCF    03.5
10FC:  MOVF   21,W
10FD:  BSF    03.5
10FE:  MOVWF  25
10FF:  BCF    0A.4
1100:  BCF    03.5
1101:  BCF    03.6
1102:  CALL   2F4
1103:  BSF    0A.4
1104:  BTFSC  27.7
1105:  BSF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
1106:  BSF    03.6
1107:  MOVF   1F,W
1108:  IORLW  B8
1109:  MOVWF  21
110A:  BCF    03.6
110B:  CLRF   27
110C:  BTFSC  0B.7
110D:  BSF    27.7
110E:  BCF    0B.7
110F:  MOVLW  01
1110:  BSF    03.5
1111:  BSF    03.6
1112:  MOVWF  24
1113:  BCF    03.5
1114:  MOVF   21,W
1115:  BSF    03.5
1116:  MOVWF  25
1117:  BCF    0A.4
1118:  BCF    03.5
1119:  BCF    03.6
111A:  CALL   2F4
111B:  BSF    0A.4
111C:  BTFSC  27.7
111D:  BSF    0B.7
....................       output_high(GLCD_DI);                     // Set for data 
111E:  BSF    03.5
111F:  BCF    06.2
1120:  BCF    03.5
1121:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
1122:  BSF    03.6
1123:  CLRF   20
1124:  MOVF   20,W
1125:  SUBLW  3F
1126:  BTFSS  03.0
1127:  GOTO   17F
1128:  BCF    03.6
1129:  CLRF   27
112A:  BTFSC  0B.7
112B:  BSF    27.7
112C:  BCF    0B.7
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
112D:  MOVLW  FF
112E:  BSF    03.5
112F:  BSF    03.6
1130:  MOVWF  19
1131:  BCF    03.5
1132:  MOVF   1E,W
1133:  BSF    03.5
1134:  MOVWF  1A
1135:  BCF    0A.4
1136:  BCF    03.5
1137:  BCF    03.6
1138:  CALL   2CB
1139:  BSF    0A.4
113A:  BTFSC  27.7
113B:  BSF    0B.7
113C:  MOVF   78,W
113D:  BSF    03.6
113E:  MOVWF  21
113F:  BCF    03.6
1140:  CLRF   27
1141:  BTFSC  0B.7
1142:  BSF    27.7
1143:  BCF    0B.7
1144:  BSF    03.5
1145:  BSF    03.6
1146:  CLRF   24
1147:  BCF    03.5
1148:  MOVF   21,W
1149:  BSF    03.5
114A:  MOVWF  25
114B:  BCF    0A.4
114C:  BCF    03.5
114D:  BCF    03.6
114E:  CALL   2F4
114F:  BSF    0A.4
1150:  BTFSC  27.7
1151:  BSF    0B.7
1152:  CLRF   27
1153:  BTFSC  0B.7
1154:  BSF    27.7
1155:  BCF    0B.7
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
1156:  MOVLW  FF
1157:  BSF    03.5
1158:  BSF    03.6
1159:  MOVWF  19
115A:  BCF    03.5
115B:  MOVF   1E,W
115C:  BSF    03.5
115D:  MOVWF  1A
115E:  BCF    0A.4
115F:  BCF    03.5
1160:  BCF    03.6
1161:  CALL   2CB
1162:  BSF    0A.4
1163:  BTFSC  27.7
1164:  BSF    0B.7
1165:  MOVF   78,W
1166:  BSF    03.6
1167:  MOVWF  21
1168:  BCF    03.6
1169:  CLRF   27
116A:  BTFSC  0B.7
116B:  BSF    27.7
116C:  BCF    0B.7
116D:  MOVLW  01
116E:  BSF    03.5
116F:  BSF    03.6
1170:  MOVWF  24
1171:  BCF    03.5
1172:  MOVF   21,W
1173:  BSF    03.5
1174:  MOVWF  25
1175:  BCF    0A.4
1176:  BCF    03.5
1177:  BCF    03.6
1178:  CALL   2F4
1179:  BSF    0A.4
117A:  BTFSC  27.7
117B:  BSF    0B.7
117C:  BSF    03.6
117D:  INCF   20,F
117E:  GOTO   124
....................       } 
117F:  INCF   1F,F
1180:  GOTO   0C5
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    set_tris_d(0x00); 
*
02F4:  MOVLW  00
02F5:  BSF    03.5
02F6:  MOVWF  08
....................     
....................    output_low(GLCD_RW);       // Set for writing 
02F7:  BCF    06.4
02F8:  BCF    03.5
02F9:  BCF    06.4
....................  
.................... 	 if(side)                   // Choose which side to write to 
02FA:  BSF    03.5
02FB:  BSF    03.6
02FC:  MOVF   24,F
02FD:  BTFSC  03.2
02FE:  GOTO   306
....................       output_high(GLCD_CS2); 
02FF:  BCF    03.6
0300:  BCF    06.1
0301:  BCF    03.5
0302:  BSF    06.1
0303:  GOTO   30A
0304:  BSF    03.5
0305:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS1); 
0306:  BCF    03.6
0307:  BCF    06.0
0308:  BCF    03.5
0309:  BSF    06.0
....................  
.................... 	 delay_us(1); 
030A:  NOP
....................  
....................    output_d(data);            // Put the data on the port 
030B:  BSF    03.5
030C:  CLRF   08
030D:  BSF    03.6
030E:  MOVF   25,W
030F:  BCF    03.5
0310:  BCF    03.6
0311:  MOVWF  08
....................    delay_us(1); 
0312:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0313:  BSF    03.5
0314:  BCF    06.5
0315:  BCF    03.5
0316:  BSF    06.5
....................    delay_us(1); 
0317:  NOP
....................    output_low(GLCD_E); 
0318:  BSF    03.5
0319:  BCF    06.5
031A:  BCF    03.5
031B:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
031C:  BSF    03.5
031D:  BCF    06.0
031E:  BCF    03.5
031F:  BCF    06.0
....................    output_low(GLCD_CS2); 
0320:  BSF    03.5
0321:  BCF    06.1
0322:  BCF    03.5
0323:  BCF    06.1
0324:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
0364:  MOVLW  FF
0365:  BCF    03.6
0366:  MOVWF  08
*
039E:  MOVLW  FF
039F:  BCF    03.6
03A0:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
*
0367:  BCF    06.4
0368:  BCF    03.5
0369:  BSF    06.4
*
03A1:  BCF    06.4
03A2:  BCF    03.5
03A3:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
*
036A:  BSF    03.5
036B:  BSF    03.6
036C:  MOVF   23,F
036D:  BTFSC  03.2
036E:  GOTO   376
*
03A4:  BSF    03.5
03A5:  BSF    03.6
03A6:  MOVF   23,F
03A7:  BTFSC  03.2
03A8:  GOTO   3B0
....................       output_high(GLCD_CS2); 
*
036F:  BCF    03.6
0370:  BCF    06.1
0371:  BCF    03.5
0372:  BSF    06.1
0373:  GOTO   37A
0374:  BSF    03.5
0375:  BSF    03.6
*
03A9:  BCF    03.6
03AA:  BCF    06.1
03AB:  BCF    03.5
03AC:  BSF    06.1
03AD:  GOTO   3B4
03AE:  BSF    03.5
03AF:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS1); 
*
0376:  BCF    03.6
0377:  BCF    06.0
0378:  BCF    03.5
0379:  BSF    06.0
*
03B0:  BCF    03.6
03B1:  BCF    06.0
03B2:  BCF    03.5
03B3:  BSF    06.0
....................  
....................    delay_us(1); 
*
037A:  NOP
*
03B4:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
*
037B:  BSF    03.5
037C:  BCF    06.5
037D:  BCF    03.5
037E:  BSF    06.5
*
03B5:  BSF    03.5
03B6:  BCF    06.5
03B7:  BCF    03.5
03B8:  BSF    06.5
....................    delay_us(1); 
*
037F:  NOP
*
03B9:  NOP
....................    data = input_d();          // Get the data from the display's output register 
*
0380:  MOVLW  FF
0381:  BSF    03.5
0382:  MOVWF  08
0383:  BCF    03.5
0384:  MOVF   08,W
0385:  BSF    03.5
0386:  BSF    03.6
0387:  MOVWF  24
*
03BA:  MOVLW  FF
03BB:  BSF    03.5
03BC:  MOVWF  08
03BD:  BCF    03.5
03BE:  MOVF   08,W
03BF:  BSF    03.5
03C0:  BSF    03.6
03C1:  MOVWF  24
....................    output_low(GLCD_E); 
*
0388:  BCF    03.6
0389:  BCF    06.5
038A:  BCF    03.5
038B:  BCF    06.5
*
03C2:  BCF    03.6
03C3:  BCF    06.5
03C4:  BCF    03.5
03C5:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
*
038C:  BSF    03.5
038D:  BCF    06.0
038E:  BCF    03.5
038F:  BCF    06.0
*
03C6:  BSF    03.5
03C7:  BCF    06.0
03C8:  BCF    03.5
03C9:  BCF    06.0
....................    output_low(GLCD_CS2); 
*
0390:  BSF    03.5
0391:  BCF    06.1
0392:  BCF    03.5
0393:  BCF    06.1
*
03CA:  BSF    03.5
03CB:  BCF    06.1
03CC:  BCF    03.5
03CD:  BCF    06.1
....................    return data;               // Return the read data 
*
0394:  BSF    03.5
0395:  BSF    03.6
0396:  MOVF   24,W
0397:  MOVWF  78
*
03CE:  BSF    03.5
03CF:  BSF    03.6
03D0:  MOVF   24,W
03D1:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <graphics.c> //Funciones para dibujar y escribir en el display 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
*
0A2E:  MOVLW  01
0A2F:  BSF    03.5
0A30:  BSF    03.6
0A31:  MOVWF  15
0A32:  MOVWF  16
0A33:  CLRF   1B
.................... { 
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
0A34:  BCF    03.5
0A35:  MOVF   6C,W
0A36:  SUBWF  6E,W
0A37:  BSF    03.5
0A38:  MOVWF  1C
0A39:  MOVF   1C,W
0A3A:  BTFSS  1C.7
0A3B:  GOTO   23E
0A3C:  MOVF   1C,W
0A3D:  SUBLW  00
0A3E:  CLRF   7A
0A3F:  MOVWF  13
0A40:  MOVF   7A,W
0A41:  MOVWF  14
....................    dy = abs((signed int8)(y2 - y1)); 
0A42:  BCF    03.5
0A43:  MOVF   6D,W
0A44:  SUBWF  6F,W
0A45:  BSF    03.5
0A46:  MOVWF  1C
0A47:  MOVF   1C,W
0A48:  BTFSS  1C.7
0A49:  GOTO   24C
0A4A:  MOVF   1C,W
0A4B:  SUBLW  00
0A4C:  CLRF   7A
0A4D:  MOVWF  11
0A4E:  MOVF   7A,W
0A4F:  MOVWF  12
....................    #endif 
....................  
....................    if(x1 > x2) 
0A50:  BCF    03.5
0A51:  MOVF   6C,W
0A52:  SUBWF  6E,W
0A53:  BTFSC  03.0
0A54:  GOTO   259
....................       addx = -1; 
0A55:  MOVLW  FF
0A56:  BSF    03.5
0A57:  MOVWF  15
0A58:  BCF    03.5
....................    if(y1 > y2) 
0A59:  MOVF   6D,W
0A5A:  SUBWF  6F,W
0A5B:  BTFSC  03.0
0A5C:  GOTO   261
....................       addy = -1; 
0A5D:  MOVLW  FF
0A5E:  BSF    03.5
0A5F:  MOVWF  16
0A60:  BCF    03.5
....................  
....................    if(dx >= dy) 
0A61:  BSF    03.5
0A62:  MOVF   12,W
0A63:  SUBWF  14,W
0A64:  BTFSS  03.0
0A65:  GOTO   2BB
0A66:  BTFSS  03.2
0A67:  GOTO   26C
0A68:  MOVF   11,W
0A69:  SUBWF  13,W
0A6A:  BTFSS  03.0
0A6B:  GOTO   2BB
....................    { 
....................       dy *= 2; 
0A6C:  BCF    03.0
0A6D:  RLF    11,F
0A6E:  RLF    12,F
....................       P = dy - dx; 
0A6F:  MOVF   13,W
0A70:  SUBWF  11,W
0A71:  MOVWF  77
0A72:  MOVF   12,W
0A73:  MOVWF  7A
0A74:  MOVF   14,W
0A75:  BTFSS  03.0
0A76:  INCFSZ 14,W
0A77:  SUBWF  7A,F
0A78:  MOVF   77,W
0A79:  MOVWF  17
0A7A:  MOVF   7A,W
0A7B:  MOVWF  18
....................       diff = P - dx; 
0A7C:  MOVF   13,W
0A7D:  SUBWF  17,W
0A7E:  MOVWF  19
0A7F:  MOVF   18,W
0A80:  MOVWF  1A
0A81:  MOVF   14,W
0A82:  BTFSS  03.0
0A83:  INCFSZ 14,W
0A84:  SUBWF  1A,F
....................  
....................       for(; i<=dx; ++i) 
0A85:  MOVF   14,F
0A86:  BTFSS  03.2
0A87:  GOTO   28C
0A88:  MOVF   1B,W
0A89:  SUBWF  13,W
0A8A:  BTFSS  03.0
0A8B:  GOTO   2BA
....................       { 
....................          glcd_pixel(x1, y1, color); 
0A8C:  BCF    03.5
0A8D:  MOVF   6C,W
0A8E:  BSF    03.5
0A8F:  MOVWF  1D
0A90:  BCF    03.5
0A91:  MOVF   6D,W
0A92:  BSF    03.5
0A93:  MOVWF  1E
0A94:  MOVF   10,W
0A95:  MOVWF  1F
0A96:  BCF    0A.3
0A97:  BCF    03.5
0A98:  BCF    03.6
0A99:  CALL   325
0A9A:  BSF    0A.3
....................  
....................          if(P < 0) 
0A9B:  BSF    03.5
0A9C:  BSF    03.6
0A9D:  BTFSS  18.7
0A9E:  GOTO   2AA
....................          { 
....................             P  += dy; 
0A9F:  MOVF   11,W
0AA0:  ADDWF  17,F
0AA1:  MOVF   12,W
0AA2:  BTFSC  03.0
0AA3:  INCFSZ 12,W
0AA4:  ADDWF  18,F
....................             x1 += addx; 
0AA5:  MOVF   15,W
0AA6:  BCF    03.5
0AA7:  ADDWF  6C,F
....................          } 
0AA8:  GOTO   2B7
0AA9:  BSF    03.5
....................          else 
....................          { 
....................             P  += diff; 
0AAA:  MOVF   19,W
0AAB:  ADDWF  17,F
0AAC:  MOVF   1A,W
0AAD:  BTFSC  03.0
0AAE:  INCFSZ 1A,W
0AAF:  ADDWF  18,F
....................             x1 += addx; 
0AB0:  MOVF   15,W
0AB1:  BCF    03.5
0AB2:  ADDWF  6C,F
....................             y1 += addy; 
0AB3:  BSF    03.5
0AB4:  MOVF   16,W
0AB5:  BCF    03.5
0AB6:  ADDWF  6D,F
....................          } 
0AB7:  BSF    03.5
0AB8:  INCF   1B,F
0AB9:  GOTO   285
....................       } 
....................    } 
0ABA:  GOTO   309
....................    else 
....................    { 
....................       dx *= 2; 
0ABB:  BCF    03.0
0ABC:  RLF    13,F
0ABD:  RLF    14,F
....................       P = dx - dy; 
0ABE:  MOVF   11,W
0ABF:  SUBWF  13,W
0AC0:  MOVWF  77
0AC1:  MOVF   14,W
0AC2:  MOVWF  7A
0AC3:  MOVF   12,W
0AC4:  BTFSS  03.0
0AC5:  INCFSZ 12,W
0AC6:  SUBWF  7A,F
0AC7:  MOVF   77,W
0AC8:  MOVWF  17
0AC9:  MOVF   7A,W
0ACA:  MOVWF  18
....................       diff = P - dy; 
0ACB:  MOVF   11,W
0ACC:  SUBWF  17,W
0ACD:  MOVWF  19
0ACE:  MOVF   18,W
0ACF:  MOVWF  1A
0AD0:  MOVF   12,W
0AD1:  BTFSS  03.0
0AD2:  INCFSZ 12,W
0AD3:  SUBWF  1A,F
....................  
....................       for(; i<=dy; ++i) 
0AD4:  MOVF   12,F
0AD5:  BTFSS  03.2
0AD6:  GOTO   2DB
0AD7:  MOVF   1B,W
0AD8:  SUBWF  11,W
0AD9:  BTFSS  03.0
0ADA:  GOTO   309
....................       { 
....................          glcd_pixel(x1, y1, color); 
0ADB:  BCF    03.5
0ADC:  MOVF   6C,W
0ADD:  BSF    03.5
0ADE:  MOVWF  1D
0ADF:  BCF    03.5
0AE0:  MOVF   6D,W
0AE1:  BSF    03.5
0AE2:  MOVWF  1E
0AE3:  MOVF   10,W
0AE4:  MOVWF  1F
0AE5:  BCF    0A.3
0AE6:  BCF    03.5
0AE7:  BCF    03.6
0AE8:  CALL   325
0AE9:  BSF    0A.3
....................  
....................          if(P < 0) 
0AEA:  BSF    03.5
0AEB:  BSF    03.6
0AEC:  BTFSS  18.7
0AED:  GOTO   2F9
....................          { 
....................             P  += dx; 
0AEE:  MOVF   13,W
0AEF:  ADDWF  17,F
0AF0:  MOVF   14,W
0AF1:  BTFSC  03.0
0AF2:  INCFSZ 14,W
0AF3:  ADDWF  18,F
....................             y1 += addy; 
0AF4:  MOVF   16,W
0AF5:  BCF    03.5
0AF6:  ADDWF  6D,F
....................          } 
0AF7:  GOTO   306
0AF8:  BSF    03.5
....................          else 
....................          { 
....................             P  += diff; 
0AF9:  MOVF   19,W
0AFA:  ADDWF  17,F
0AFB:  MOVF   1A,W
0AFC:  BTFSC  03.0
0AFD:  INCFSZ 1A,W
0AFE:  ADDWF  18,F
....................             x1 += addx; 
0AFF:  MOVF   15,W
0B00:  BCF    03.5
0B01:  ADDWF  6C,F
....................             y1 += addy; 
0B02:  BSF    03.5
0B03:  MOVF   16,W
0B04:  BCF    03.5
0B05:  ADDWF  6D,F
....................          } 
0B06:  BSF    03.5
0B07:  INCF   1B,F
0B08:  GOTO   2D4
....................       } 
....................    } 
0B09:  BCF    03.5
0B0A:  BCF    03.6
0B0B:  RETURN
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
....................       { 
....................          xmin = x1; 
....................          xmax = x2; 
....................       } 
....................       else 
....................       { 
....................          xmin = x2; 
....................          xmax = x1; 
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
....................       { 
....................          ymin = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          ymin = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
....................          { 
....................             glcd_pixel(xmin, i, color); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
0417:  BSF    03.6
0418:  MOVF   6A,W
0419:  MOVWF  7A
041A:  MOVF   69,W
041B:  MOVWF  04
041C:  BCF    03.7
041D:  BTFSC  7A.0
041E:  BSF    03.7
041F:  MOVF   00,F
0420:  BTFSC  03.2
0421:  GOTO   537
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0422:  MOVF   6A,W
0423:  MOVWF  7A
0424:  MOVF   69,W
0425:  MOVWF  04
0426:  BCF    03.7
0427:  BTFSC  7A.0
0428:  BSF    03.7
0429:  MOVF   00,W
042A:  SUBLW  52
042B:  BTFSS  03.0
042C:  GOTO   457
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
042D:  MOVF   6A,W
042E:  MOVWF  7A
042F:  MOVF   69,W
0430:  MOVWF  04
0431:  BCF    03.7
0432:  BTFSC  7A.0
0433:  BSF    03.7
0434:  MOVLW  20
0435:  SUBWF  00,W
0436:  BSF    03.5
0437:  MOVWF  17
0438:  MOVWF  19
0439:  MOVLW  05
043A:  MOVWF  1A
043B:  BCF    03.5
043C:  BCF    03.6
043D:  CALL   2CB
043E:  MOVF   78,W
043F:  BSF    03.5
0440:  BSF    03.6
0441:  MOVWF  16
0442:  MOVWF  78
0443:  MOVLW  05
0444:  MOVWF  77
0445:  MOVLW  91
0446:  MOVWF  04
0447:  BSF    03.7
0448:  MOVF   78,W
0449:  BCF    03.5
044A:  BCF    03.6
044B:  CALL   048
044C:  MOVWF  00
044D:  INCF   78,F
044E:  INCF   04,F
044F:  DECFSZ 77,F
0450:  GOTO   452
0451:  GOTO   455
0452:  BSF    03.5
0453:  BSF    03.6
0454:  GOTO   448
0455:  GOTO   494
0456:  BSF    03.6
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
0457:  MOVF   6A,W
0458:  MOVWF  7A
0459:  MOVF   69,W
045A:  MOVWF  04
045B:  BCF    03.7
045C:  BTFSC  7A.0
045D:  BSF    03.7
045E:  MOVF   00,W
045F:  SUBLW  7E
0460:  BTFSS  03.0
0461:  GOTO   48C
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
0462:  MOVF   6A,W
0463:  MOVWF  7A
0464:  MOVF   69,W
0465:  MOVWF  04
0466:  BCF    03.7
0467:  BTFSC  7A.0
0468:  BSF    03.7
0469:  MOVLW  53
046A:  SUBWF  00,W
046B:  BSF    03.5
046C:  MOVWF  17
046D:  MOVWF  19
046E:  MOVLW  05
046F:  MOVWF  1A
0470:  BCF    03.5
0471:  BCF    03.6
0472:  CALL   2CB
0473:  MOVF   78,W
0474:  BSF    03.5
0475:  BSF    03.6
0476:  MOVWF  16
0477:  MOVWF  78
0478:  MOVLW  05
0479:  MOVWF  77
047A:  MOVLW  91
047B:  MOVWF  04
047C:  BSF    03.7
047D:  MOVF   78,W
047E:  BCF    03.5
047F:  BCF    03.6
0480:  CALL   14E
0481:  MOVWF  00
0482:  INCF   78,F
0483:  INCF   04,F
0484:  DECFSZ 77,F
0485:  GOTO   487
0486:  GOTO   48A
0487:  BSF    03.5
0488:  BSF    03.6
0489:  GOTO   47D
048A:  GOTO   494
048B:  BSF    03.6
....................       else 
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
048C:  BSF    03.5
048D:  CLRF   11
048E:  CLRF   12
048F:  CLRF   13
0490:  CLRF   14
0491:  CLRF   15
0492:  BCF    03.5
0493:  BCF    03.6
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
0494:  BSF    03.6
0495:  MOVF   6A,W
0496:  MOVWF  7A
0497:  MOVF   69,W
0498:  MOVWF  04
0499:  BCF    03.7
049A:  BTFSC  7A.0
049B:  BSF    03.7
049C:  MOVF   00,W
049D:  XORLW  0A
049E:  BCF    03.6
049F:  BTFSC  03.2
04A0:  GOTO   4A5
04A1:  XORLW  07
04A2:  BTFSC  03.2
04A3:  GOTO   4B6
04A4:  GOTO   4BA
....................       { 
....................          case '\n': 
....................             y += 7*size + 1; 
04A5:  MOVLW  07
04A6:  BSF    03.5
04A7:  BSF    03.6
04A8:  MOVWF  19
04A9:  BCF    03.5
04AA:  MOVF   6B,W
04AB:  BSF    03.5
04AC:  MOVWF  1A
04AD:  BCF    03.5
04AE:  BCF    03.6
04AF:  CALL   2CB
04B0:  MOVLW  01
04B1:  ADDWF  78,W
04B2:  BSF    03.6
04B3:  ADDWF  68,F
....................             continue; 
04B4:  GOTO   532
04B5:  BCF    03.6
....................          case '\r': 
....................             x = 0; 
04B6:  BSF    03.6
04B7:  CLRF   67
....................             continue; 
04B8:  GOTO   532
04B9:  BCF    03.6
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
04BA:  MOVLW  05
04BB:  BSF    03.5
04BC:  BSF    03.6
04BD:  MOVWF  19
04BE:  BCF    03.5
04BF:  MOVF   6B,W
04C0:  BSF    03.5
04C1:  MOVWF  1A
04C2:  BCF    03.5
04C3:  BCF    03.6
04C4:  CALL   2CB
04C5:  MOVF   78,W
04C6:  BSF    03.6
04C7:  ADDWF  67,W
04C8:  SUBLW  7F
04C9:  BTFSC  03.0
04CA:  GOTO   4DA
....................       { 
....................          x = 0;                           // Set x at far left position 
04CB:  CLRF   67
....................          y += 7*size + 1;                 // Set y at next position down 
04CC:  MOVLW  07
04CD:  BSF    03.5
04CE:  MOVWF  19
04CF:  BCF    03.5
04D0:  MOVF   6B,W
04D1:  BSF    03.5
04D2:  MOVWF  1A
04D3:  BCF    03.5
04D4:  BCF    03.6
04D5:  CALL   2CB
04D6:  MOVLW  01
04D7:  ADDWF  78,W
04D8:  BSF    03.6
04D9:  ADDWF  68,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
04DA:  CLRF   6D
04DB:  MOVF   6D,W
04DC:  SUBLW  04
04DD:  BTFSS  03.0
04DE:  GOTO   532
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
04DF:  CLRF   6E
04E0:  MOVF   6E,W
04E1:  SUBLW  06
04E2:  BTFSS  03.0
04E3:  GOTO   52E
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
04E4:  MOVLW  91
04E5:  ADDWF  6D,W
04E6:  MOVWF  04
04E7:  BSF    03.7
04E8:  MOVF   00,W
04E9:  BSF    03.5
04EA:  MOVWF  16
04EB:  MOVWF  77
04EC:  BCF    03.5
04ED:  MOVF   6E,W
04EE:  MOVWF  78
04EF:  BTFSC  03.2
04F0:  GOTO   4F5
04F1:  BCF    03.0
04F2:  RRF    77,F
04F3:  DECFSZ 78,F
04F4:  GOTO   4F1
04F5:  BTFSS  77.0
04F6:  GOTO   52C
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
04F7:  CLRF   6F
04F8:  MOVF   6B,W
04F9:  SUBWF  6F,W
04FA:  BTFSC  03.0
04FB:  GOTO   52C
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
04FC:  BSF    03.5
04FD:  CLRF   10
04FE:  BCF    03.5
04FF:  MOVF   6B,W
0500:  BSF    03.5
0501:  SUBWF  10,W
0502:  BTFSC  03.0
0503:  GOTO   529
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0504:  MOVF   10,W
0505:  BCF    03.5
0506:  ADDWF  67,W
0507:  BSF    03.5
0508:  MOVWF  16
0509:  BCF    03.5
050A:  MOVF   6E,W
050B:  BSF    03.5
050C:  MOVWF  19
050D:  BCF    03.5
050E:  MOVF   6B,W
050F:  BSF    03.5
0510:  MOVWF  1A
0511:  BCF    03.5
0512:  BCF    03.6
0513:  CALL   2CB
0514:  MOVF   78,W
0515:  BSF    03.6
0516:  ADDWF  68,W
0517:  ADDWF  6F,W
0518:  BSF    03.5
0519:  MOVWF  17
051A:  MOVF   16,W
051B:  MOVWF  1D
051C:  MOVF   17,W
051D:  MOVWF  1E
051E:  BCF    03.5
051F:  MOVF   6C,W
0520:  BSF    03.5
0521:  MOVWF  1F
0522:  BCF    03.5
0523:  BCF    03.6
0524:  CALL   325
0525:  BSF    03.5
0526:  BSF    03.6
0527:  INCF   10,F
0528:  GOTO   4FE
....................                   } 
0529:  BCF    03.5
052A:  INCF   6F,F
052B:  GOTO   4F8
....................                } 
....................             } 
052C:  INCF   6E,F
052D:  GOTO   4E0
....................          } 
052E:  INCF   6D,F
052F:  MOVF   6B,W
0530:  ADDWF  67,F
0531:  GOTO   4DB
....................       } 
0532:  INCF   69,F
0533:  BTFSC  03.2
0534:  INCF   6A,F
0535:  INCF   67,F
0536:  GOTO   418
....................    } 
0537:  BCF    03.6
0538:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <srcomLIB.c> 
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
*
11DC:  MOVF   2B,W
11DD:  MOVWF  2D
11DE:  MOVF   2A,W
11DF:  MOVWF  2C
....................    result->size=size; 
11E0:  MOVF   2C,W
11E1:  MOVWF  04
11E2:  BCF    03.7
11E3:  BTFSC  2D.0
11E4:  BSF    03.7
11E5:  MOVF   28,W
11E6:  MOVWF  00
....................    result->next = NULL; 
11E7:  MOVLW  01
11E8:  ADDWF  2C,W
11E9:  MOVWF  04
11EA:  BCF    03.7
11EB:  BTFSC  2D.0
11EC:  BSF    03.7
11ED:  INCF   04,F
11EE:  CLRF   00
11EF:  DECF   04,F
11F0:  CLRF   00
....................    return result; 
11F1:  MOVF   2C,W
11F2:  MOVWF  78
11F3:  MOVF   2D,W
11F4:  MOVWF  79
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
*
07D6:  BSF    03.6
07D7:  MOVF   26,W
07D8:  MOVWF  04
07D9:  BCF    03.7
07DA:  BTFSC  27.0
07DB:  BSF    03.7
07DC:  MOVF   28,W
07DD:  MOVWF  00
07DE:  BCF    03.6
07DF:  RETURN
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
*
1201:  MOVLW  01
1202:  ADDWF  24,W
1203:  MOVWF  04
1204:  BCF    03.7
1205:  BTFSC  25.0
1206:  BSF    03.7
1207:  INCF   04,F
1208:  MOVF   00,W
1209:  MOVWF  29
120A:  DECF   04,F
120B:  MOVF   00,W
120C:  MOVWF  28
120D:  MOVF   28,F
120E:  BTFSS  03.2
120F:  GOTO   21E
1210:  MOVF   29,F
1211:  BTFSS  03.2
1212:  GOTO   21E
....................        node->next= NULL; 
1213:  MOVLW  01
1214:  ADDWF  26,W
1215:  MOVWF  04
1216:  BCF    03.7
1217:  BTFSC  27.0
1218:  BSF    03.7
1219:  INCF   04,F
121A:  CLRF   00
121B:  DECF   04,F
121C:  CLRF   00
121D:  GOTO   242
....................     else 
....................        node->next=place->next; 
121E:  MOVLW  01
121F:  ADDWF  26,W
1220:  MOVWF  78
1221:  MOVF   27,W
1222:  MOVWF  7A
1223:  BTFSC  03.0
1224:  INCF   7A,F
1225:  MOVF   78,W
1226:  MOVWF  28
1227:  MOVF   7A,W
1228:  MOVWF  29
1229:  MOVLW  01
122A:  ADDWF  24,W
122B:  MOVWF  04
122C:  BCF    03.7
122D:  BTFSC  25.0
122E:  BSF    03.7
122F:  INCF   04,F
1230:  MOVF   00,W
1231:  MOVWF  7A
1232:  DECF   04,F
1233:  MOVF   00,W
1234:  MOVWF  2A
1235:  MOVF   7A,W
1236:  MOVWF  2B
1237:  MOVF   28,W
1238:  MOVWF  04
1239:  BCF    03.7
123A:  BTFSC  29.0
123B:  BSF    03.7
123C:  INCF   04,F
123D:  MOVF   2B,W
123E:  MOVWF  00
123F:  DECF   04,F
1240:  MOVF   2A,W
1241:  MOVWF  00
....................     place->next=node; 
1242:  MOVLW  01
1243:  ADDWF  24,W
1244:  MOVWF  04
1245:  BCF    03.7
1246:  BTFSC  25.0
1247:  BSF    03.7
1248:  INCF   04,F
1249:  MOVF   27,W
124A:  MOVWF  00
124B:  DECF   04,F
124C:  MOVF   26,W
124D:  MOVWF  00
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
*
1188:  BCF    03.6
1189:  MOVF   2A,W
118A:  BSF    03.6
118B:  MOVWF  1F
118C:  BCF    03.6
118D:  MOVF   29,W
118E:  BSF    03.6
118F:  MOVWF  1E
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
1190:  MOVF   1E,F
1191:  BTFSS  03.2
1192:  GOTO   196
1193:  MOVF   1F,F
1194:  BTFSC  03.2
1195:  GOTO   280
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
1196:  MOVF   1E,W
1197:  MOVWF  04
1198:  BCF    03.7
1199:  BTFSC  1F.0
119A:  BSF    03.7
119B:  MOVF   00,W
119C:  MOVWF  24
119D:  BTFSC  24.7
119E:  GOTO   273
119F:  MOVF   1E,W
11A0:  MOVWF  04
11A1:  BCF    03.7
11A2:  BTFSC  1F.0
11A3:  BSF    03.7
11A4:  MOVF   1D,W
11A5:  SUBWF  00,W
11A6:  BTFSS  03.0
11A7:  GOTO   273
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
11A8:  MOVF   1E,W
11A9:  MOVWF  04
11AA:  BCF    03.7
11AB:  BTFSC  1F.0
11AC:  BSF    03.7
11AD:  CLRF   23
11AE:  MOVF   00,W
11AF:  MOVWF  22
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
11B0:  MOVLW  03
11B1:  ADDWF  1D,W
11B2:  MOVF   23,F
11B3:  BTFSS  03.2
11B4:  GOTO   1BA
11B5:  SUBWF  22,W
11B6:  BTFSC  03.2
11B7:  GOTO   25E
11B8:  BTFSS  03.0
11B9:  GOTO   25E
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
11BA:  MOVF   1D,W
11BB:  SUBWF  22,W
11BC:  MOVWF  24
11BD:  MOVF   23,W
11BE:  MOVWF  25
11BF:  MOVLW  00
11C0:  BTFSS  03.0
11C1:  MOVLW  01
11C2:  SUBWF  25,F
11C3:  MOVLW  03
11C4:  SUBWF  24,F
11C5:  MOVLW  00
11C6:  BTFSS  03.0
11C7:  MOVLW  01
11C8:  SUBWF  25,F
11C9:  MOVLW  03
11CA:  ADDWF  1E,W
11CB:  MOVWF  26
11CC:  MOVF   1F,W
11CD:  MOVWF  27
11CE:  BTFSC  03.0
11CF:  INCF   27,F
11D0:  MOVF   1D,W
11D1:  ADDWF  26,F
11D2:  BTFSC  03.0
11D3:  INCF   27,F
11D4:  MOVF   25,W
11D5:  MOVWF  29
11D6:  MOVF   24,W
11D7:  MOVWF  28
11D8:  MOVF   27,W
11D9:  MOVWF  2B
11DA:  MOVF   26,W
11DB:  MOVWF  2A
*
11F5:  MOVF   79,W
11F6:  MOVWF  21
11F7:  MOVF   78,W
11F8:  MOVWF  20
....................             insert_node_after(node,new); 
11F9:  MOVF   1F,W
11FA:  MOVWF  25
11FB:  MOVF   1E,W
11FC:  MOVWF  24
11FD:  MOVF   21,W
11FE:  MOVWF  27
11FF:  MOVF   20,W
1200:  MOVWF  26
....................             update_node(node,size+_MEMMGMT_CSIZE); 
*
124E:  MOVLW  7F
124F:  ADDWF  1D,W
1250:  MOVWF  24
1251:  MOVF   1F,W
1252:  MOVWF  27
1253:  MOVF   1E,W
1254:  MOVWF  26
1255:  CLRF   29
1256:  MOVF   24,W
1257:  MOVWF  28
1258:  BCF    0A.4
1259:  BCF    03.6
125A:  CALL   7D6
125B:  BSF    0A.4
....................          } 
125C:  GOTO   271
125D:  BSF    03.6
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
125E:  MOVLW  7F
125F:  ADDWF  22,W
1260:  MOVWF  24
1261:  MOVF   23,W
1262:  MOVWF  25
1263:  BTFSC  03.0
1264:  INCF   25,F
1265:  MOVF   1F,W
1266:  MOVWF  27
1267:  MOVF   1E,W
1268:  MOVWF  26
1269:  MOVF   25,W
126A:  MOVWF  29
126B:  MOVF   24,W
126C:  MOVWF  28
126D:  BCF    0A.4
126E:  BCF    03.6
126F:  CALL   7D6
1270:  BSF    0A.4
....................          //end if 
....................          break; 
1271:  BSF    03.6
1272:  GOTO   280
....................       }//end if 
....................       node=node->next; 
1273:  MOVLW  01
1274:  ADDWF  1E,W
1275:  MOVWF  04
1276:  BCF    03.7
1277:  BTFSC  1F.0
1278:  BSF    03.7
1279:  INCF   04,F
127A:  MOVF   00,W
127B:  MOVWF  1F
127C:  DECF   04,F
127D:  MOVF   00,W
127E:  MOVWF  1E
127F:  GOTO   190
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
1280:  MOVF   1E,F
1281:  BTFSS  03.2
1282:  GOTO   28B
1283:  MOVF   1F,F
1284:  BTFSS  03.2
1285:  GOTO   28B
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
1286:  MOVLW  00
1287:  MOVWF  78
1288:  MOVWF  79
1289:  GOTO   294
....................    } 
128A:  GOTO   294
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
128B:  MOVLW  03
128C:  ADDWF  1E,W
128D:  MOVWF  78
128E:  MOVF   1F,W
128F:  MOVWF  7A
1290:  BTFSC  03.0
1291:  INCF   7A,F
1292:  MOVF   7A,W
1293:  MOVWF  79
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
13A4:  CLRF   2B
13A5:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define SEP '\n' 
.................... #define END '\0' 
....................  
.................... struct SERIAL_LIB { 
....................     char* sSerial; 
.................... }; typedef struct SERIAL_LIB SERIALsr; 
....................  
.................... SERIALsr serialData; 
.................... char str[9] = "\0"; 
13A6:  CLRF   2F
13A7:  CLRF   30
....................  
.................... // SEND SYSTEM 
.................... void set_SERIALsr() { 
....................     serialData.sSerial = malloc(sizeof(char)); 
*
1185:  MOVLW  01
1186:  BSF    03.6
1187:  MOVWF  1D
*
1294:  MOVF   79,W
1295:  BCF    03.6
1296:  MOVWF  2E
1297:  MOVF   78,W
1298:  MOVWF  2D
1299:  BCF    0A.3
129A:  BSF    0A.4
129B:  GOTO   4D3 (RETURN)
.................... } 
.................... void sendFT(char t , float v, char a) { 
....................     sprintf(str, "%c%f%c", t, v, a); 
....................     for(int i = 0; str[i] != a; i++) 
....................         printf("%c", str[i]); 
....................     printf("%c", a); 
.................... } 
.................... void sendINT(char t , int v, char a) { 
....................     sprintf(str, "%c%d%c", t, v, a); 
129C:  CLRF   39
129D:  MOVLW  2F
129E:  MOVWF  38
129F:  CLRF   27
12A0:  BTFSC  0B.7
12A1:  BSF    27.7
12A2:  BCF    0B.7
12A3:  BSF    03.6
12A4:  MOVF   1D,W
12A5:  BSF    03.5
12A6:  MOVWF  19
12A7:  BCF    0A.4
12A8:  BCF    03.5
12A9:  BCF    03.6
12AA:  CALL   628
12AB:  BSF    0A.4
12AC:  BTFSC  27.7
12AD:  BSF    0B.7
12AE:  BSF    03.6
12AF:  MOVF   1E,W
12B0:  MOVWF  21
12B1:  MOVLW  18
12B2:  MOVWF  22
*
134C:  BSF    03.6
134D:  MOVF   1F,W
134E:  BSF    03.5
134F:  MOVWF  19
1350:  BCF    0A.4
1351:  BCF    03.5
1352:  BCF    03.6
1353:  CALL   628
1354:  BSF    0A.4
1355:  BTFSC  27.7
1356:  BSF    0B.7
....................     for(int i = 0; str[i] != a; i++) 
1357:  BSF    03.6
1358:  CLRF   20
1359:  MOVLW  2F
135A:  ADDWF  20,W
135B:  MOVWF  04
135C:  BCF    03.7
135D:  MOVF   1F,W
135E:  SUBWF  00,W
135F:  BTFSC  03.2
1360:  GOTO   36E
....................         printf("%c", str[i]); 
1361:  MOVLW  2F
1362:  ADDWF  20,W
1363:  MOVWF  04
1364:  BCF    03.7
1365:  MOVF   00,W
1366:  MOVWF  21
1367:  BCF    03.6
1368:  BTFSS  0C.4
1369:  GOTO   368
136A:  MOVWF  19
136B:  BSF    03.6
136C:  INCF   20,F
136D:  GOTO   359
....................     printf("%c", a); 
136E:  MOVF   1F,W
136F:  BCF    03.6
1370:  BTFSS  0C.4
1371:  GOTO   370
1372:  MOVWF  19
1373:  BCF    0A.3
1374:  BSF    0A.4
1375:  GOTO   57A (RETURN)
.................... } 
.................... void sendSTR(char t , char v[], char a) { 
....................     sprintf(str, "%c%s%c", t, v, a); 
....................         for(int i = 0; str[i] != a; i++) 
....................             printf("%c", str[i]); 
....................     printf("%c", a); 
.................... } 
.................... void sendDATA(char s_[], char a) { 
....................      for(int i = 0; s_[i] != a; i++) 
....................          printf("%c", s_[i]); 
....................     printf("%c", a); 
.................... } 
.................... // END SEND SYSTEM 
.................... // READ SERIAL 
.................... int getArrSize() { return strlen(serialData.sSerial); } 
.................... int insert(char c_) { 
....................     int i = 0; 
....................     serialData.sSerial = realloc(serialData.sSerial, sizeof(char)*(i + 1)); 
....................     if(serialData.sSerial != NULL) { 
....................         i++; 
....................         *(serialData.sSerial + getArrSize() - 1) = c_; 
....................         return TRUE; 
....................     } return FALSE; 
.................... } 
.................... char* getSTR() { return serialData.sSerial; } 
.................... // END READ SERIAL 
....................  
....................  
.................... #byte trisb=0x86 
....................  
.................... ///Defines 
....................  
.................... #define escala -2 //Escala negativa para que crezca hacia arriba. 
.................... #define limpiarGrafico limpiarPorcion(0,20,128,44) //Limpia el area del grafico 
.................... #define offset 120 //es el offset para la altura de la grafica 
.................... #define TMR1 0x0BDC //Este es el valor para 500ms en el timer1 (0,5s=(4/4000000)8(65536-TMR1))=>TMR1=3036 
.................... #define TMR0 0x40 //Este es el valor para 50ms en el timer0 
.................... #define nMediciones 80 //Numero de mediciones 
....................  
.................... ///Fin Defines 
....................  
.................... ///Variables Globales 
....................  
.................... int x=0; //Posicion inicial de x para graficar la temperatura 
.................... float y; //Temperatura anterior 
.................... float t; //Temperatura actual 
.................... int16 iAn; //Lectura del sensor de temperatura 
.................... int registro[nMediciones]; //registro de las ultimas nMediciones mediciones 
.................... int1 habilitarLectura=0; //Variable para habilitar o deshabilitar la captura de datos del sensor 
.................... int ciclos=10; //Variable que cuenta los ciclos que debe hacer el timer0 antes de ejecutar su codigo 
.................... int ciclosT1=6; //Variable que cuenta los ciclos que debe hacer el timer1 antes de ejecutar su codigo 
.................... short int btST = 0; 
.................... char r_; 
.................... ///Fin Variables Globales 
....................  
.................... ///Funciones 
....................  
.................... void limpiarPorcion(int x1, int y1, int x2, int y2){ //(x1, y1) = posición del primer pixel. (x2, y2) = cantididad de pixeles hacia la derecha y hacia abajo 
....................    for(int i=x1;i<x1+x2;i++) 
*
0B1B:  MOVF   6A,W
0B1C:  MOVWF  6E
0B1D:  MOVF   6C,W
0B1E:  ADDWF  6A,W
0B1F:  SUBWF  6E,W
0B20:  BTFSC  03.0
0B21:  GOTO   33B
*
0CAA:  MOVF   6A,W
0CAB:  MOVWF  6E
0CAC:  MOVF   6C,W
0CAD:  ADDWF  6A,W
0CAE:  SUBWF  6E,W
0CAF:  BTFSC  03.0
0CB0:  GOTO   4CA
....................       for(int j=y1;j<y1+y2;j++) 
*
0B22:  MOVF   6B,W
0B23:  MOVWF  6F
0B24:  MOVF   6D,W
0B25:  ADDWF  6B,W
0B26:  SUBWF  6F,W
0B27:  BTFSC  03.0
0B28:  GOTO   339
*
0CB1:  MOVF   6B,W
0CB2:  MOVWF  6F
0CB3:  MOVF   6D,W
0CB4:  ADDWF  6B,W
0CB5:  SUBWF  6F,W
0CB6:  BTFSC  03.0
0CB7:  GOTO   4C8
....................          glcd_pixel(i, j, OFF); //Apagamos el pixel. 
*
0B29:  MOVF   6E,W
0B2A:  BSF    03.5
0B2B:  MOVWF  1D
0B2C:  BCF    03.5
0B2D:  MOVF   6F,W
0B2E:  BSF    03.5
0B2F:  MOVWF  1E
0B30:  CLRF   1F
0B31:  BCF    0A.3
0B32:  BCF    03.5
0B33:  BCF    03.6
0B34:  CALL   325
0B35:  BSF    0A.3
0B36:  BSF    03.6
0B37:  INCF   6F,F
0B38:  GOTO   324
0B39:  INCF   6E,F
0B3A:  GOTO   31D
*
0CB8:  MOVF   6E,W
0CB9:  BSF    03.5
0CBA:  MOVWF  1D
0CBB:  BCF    03.5
0CBC:  MOVF   6F,W
0CBD:  BSF    03.5
0CBE:  MOVWF  1E
0CBF:  CLRF   1F
0CC0:  BCF    0A.3
0CC1:  BCF    03.5
0CC2:  BCF    03.6
0CC3:  CALL   325
0CC4:  BSF    0A.3
0CC5:  BSF    03.6
0CC6:  INCF   6F,F
0CC7:  GOTO   4B3
0CC8:  INCF   6E,F
0CC9:  GOTO   4AC
.................... } 
....................  
.................... void nuevaLinea(float temp){ //Funcion para graficar las nuevas lineas de temperatura 
*
0B0C:  MOVLW  01
0B0D:  ADDWF  3A,W
0B0E:  BSF    03.6
0B0F:  MOVWF  69
....................    int x1=x+1; 
....................    if(x1>=128){ //Revisamos si sobrepasamos el tamaño de la pantalla 
0B10:  MOVF   69,W
0B11:  SUBLW  7F
0B12:  BTFSC  03.0
0B13:  GOTO   340
....................       limpiarGrafico; //Limpiamos el area del grafico 
0B14:  CLRF   6A
0B15:  MOVLW  14
0B16:  MOVWF  6B
0B17:  MOVLW  80
0B18:  MOVWF  6C
0B19:  MOVLW  2C
0B1A:  MOVWF  6D
....................       x=0; 
*
0B3B:  BCF    03.6
0B3C:  CLRF   3A
....................       x1=1; 
0B3D:  MOVLW  01
0B3E:  BSF    03.6
0B3F:  MOVWF  69
....................    } 
....................    glcd_line(x, (y*escala)+offset, x1, (temp*escala)+offset, ON);   //multiplicamos por la escala para que la grafica entre en el area del grafico. El offset esta explicado arriba 
0B40:  BCF    03.6
0B41:  MOVF   3E,W
0B42:  BSF    03.5
0B43:  BSF    03.6
0B44:  MOVWF  1C
0B45:  BCF    03.5
0B46:  BCF    03.6
0B47:  MOVF   3D,W
0B48:  BSF    03.5
0B49:  BSF    03.6
0B4A:  MOVWF  1B
0B4B:  BCF    03.5
0B4C:  BCF    03.6
0B4D:  MOVF   3C,W
0B4E:  BSF    03.5
0B4F:  BSF    03.6
0B50:  MOVWF  1A
0B51:  BCF    03.5
0B52:  BCF    03.6
0B53:  MOVF   3B,W
0B54:  BSF    03.5
0B55:  BSF    03.6
0B56:  MOVWF  19
0B57:  CLRF   20
0B58:  CLRF   1F
0B59:  MOVLW  80
0B5A:  MOVWF  1E
0B5B:  MOVWF  1D
0B5C:  BCF    0A.3
0B5D:  BCF    03.5
0B5E:  BCF    03.6
0B5F:  CALL   539
0B60:  BSF    0A.3
0B61:  MOVF   7A,W
0B62:  BSF    03.6
0B63:  MOVWF  6D
0B64:  MOVF   79,W
0B65:  MOVWF  6C
0B66:  MOVF   78,W
0B67:  MOVWF  6B
0B68:  MOVF   77,W
0B69:  MOVWF  6A
0B6A:  BCF    03.1
0B6B:  MOVF   6D,W
0B6C:  BSF    03.5
0B6D:  MOVWF  13
0B6E:  BCF    03.5
0B6F:  MOVF   6C,W
0B70:  BSF    03.5
0B71:  MOVWF  12
0B72:  BCF    03.5
0B73:  MOVF   6B,W
0B74:  BSF    03.5
0B75:  MOVWF  11
0B76:  BCF    03.5
0B77:  MOVF   6A,W
0B78:  BSF    03.5
0B79:  MOVWF  10
0B7A:  CLRF   17
0B7B:  CLRF   16
0B7C:  MOVLW  70
0B7D:  MOVWF  15
0B7E:  MOVLW  85
0B7F:  MOVWF  14
0B80:  BCF    03.5
0B81:  BCF    03.6
0B82:  CALL   0E4
0B83:  MOVF   7A,W
0B84:  BSF    03.6
0B85:  MOVWF  6E
0B86:  MOVF   79,W
0B87:  MOVWF  6D
0B88:  MOVF   78,W
0B89:  MOVWF  6C
0B8A:  MOVF   77,W
0B8B:  MOVWF  6B
0B8C:  BCF    0A.3
0B8D:  BCF    03.6
0B8E:  CALL   7B5
0B8F:  BSF    0A.3
0B90:  MOVF   78,W
0B91:  BSF    03.6
0B92:  MOVWF  6A
0B93:  MOVF   68,W
0B94:  BSF    03.5
0B95:  MOVWF  1C
0B96:  BCF    03.5
0B97:  MOVF   67,W
0B98:  BSF    03.5
0B99:  MOVWF  1B
0B9A:  BCF    03.5
0B9B:  MOVF   66,W
0B9C:  BSF    03.5
0B9D:  MOVWF  1A
0B9E:  BCF    03.5
0B9F:  MOVF   65,W
0BA0:  BSF    03.5
0BA1:  MOVWF  19
0BA2:  CLRF   20
0BA3:  CLRF   1F
0BA4:  MOVLW  80
0BA5:  MOVWF  1E
0BA6:  MOVWF  1D
0BA7:  BCF    0A.3
0BA8:  BCF    03.5
0BA9:  BCF    03.6
0BAA:  CALL   539
0BAB:  BSF    0A.3
0BAC:  MOVF   7A,W
0BAD:  BSF    03.6
0BAE:  MOVWF  6E
0BAF:  MOVF   79,W
0BB0:  MOVWF  6D
0BB1:  MOVF   78,W
0BB2:  MOVWF  6C
0BB3:  MOVF   77,W
0BB4:  MOVWF  6B
0BB5:  BCF    03.1
0BB6:  MOVF   6E,W
0BB7:  BSF    03.5
0BB8:  MOVWF  13
0BB9:  BCF    03.5
0BBA:  MOVF   6D,W
0BBB:  BSF    03.5
0BBC:  MOVWF  12
0BBD:  BCF    03.5
0BBE:  MOVF   6C,W
0BBF:  BSF    03.5
0BC0:  MOVWF  11
0BC1:  BCF    03.5
0BC2:  MOVF   6B,W
0BC3:  BSF    03.5
0BC4:  MOVWF  10
0BC5:  CLRF   17
0BC6:  CLRF   16
0BC7:  MOVLW  70
0BC8:  MOVWF  15
0BC9:  MOVLW  85
0BCA:  MOVWF  14
0BCB:  BCF    03.5
0BCC:  BCF    03.6
0BCD:  CALL   0E4
0BCE:  MOVF   7A,W
0BCF:  BSF    03.6
0BD0:  MOVWF  6E
0BD1:  MOVF   79,W
0BD2:  MOVWF  6D
0BD3:  MOVF   78,W
0BD4:  MOVWF  6C
0BD5:  MOVF   77,W
0BD6:  MOVWF  6B
0BD7:  BCF    0A.3
0BD8:  BCF    03.6
0BD9:  CALL   7B5
0BDA:  BSF    0A.3
0BDB:  MOVF   78,W
0BDC:  BSF    03.6
0BDD:  MOVWF  6B
0BDE:  BCF    03.6
0BDF:  MOVF   3A,W
0BE0:  BSF    03.6
0BE1:  MOVWF  6C
0BE2:  MOVF   6A,W
0BE3:  MOVWF  6D
0BE4:  MOVF   69,W
0BE5:  MOVWF  6E
0BE6:  MOVF   6B,W
0BE7:  MOVWF  6F
0BE8:  MOVLW  01
0BE9:  BSF    03.5
0BEA:  MOVWF  10
0BEB:  BCF    03.5
0BEC:  BCF    03.6
0BED:  CALL   22E
....................    y=temp; 
0BEE:  BSF    03.6
0BEF:  MOVF   68,W
0BF0:  BCF    03.6
0BF1:  MOVWF  3E
0BF2:  BSF    03.6
0BF3:  MOVF   67,W
0BF4:  BCF    03.6
0BF5:  MOVWF  3D
0BF6:  BSF    03.6
0BF7:  MOVF   66,W
0BF8:  BCF    03.6
0BF9:  MOVWF  3C
0BFA:  BSF    03.6
0BFB:  MOVF   65,W
0BFC:  BCF    03.6
0BFD:  MOVWF  3B
....................    x=x1; 
0BFE:  BSF    03.6
0BFF:  MOVF   69,W
0C00:  BCF    03.6
0C01:  MOVWF  3A
0C02:  RETURN
.................... } 
.................... void toggleBT(char c_) { 
....................    if(c_ == 'a') { 
*
0F1E:  MOVF   3D,W
0F1F:  SUBLW  61
0F20:  BTFSS  03.2
0F21:  GOTO   73A
....................       btST = !ON; 
0F22:  BCF    03.6
0F23:  BCF    45.1
....................       glcd_text57(110,0,(char*)"BT",1,ON); //Mostramos BT 
0F24:  MOVLW  42
0F25:  BSF    03.6
0F26:  MOVWF  3E
0F27:  MOVLW  54
0F28:  MOVWF  3F
0F29:  CLRF   40
0F2A:  MOVLW  6E
0F2B:  MOVWF  67
0F2C:  CLRF   68
0F2D:  MOVLW  01
0F2E:  MOVWF  6A
0F2F:  MOVLW  3E
0F30:  MOVWF  69
0F31:  MOVLW  01
0F32:  MOVWF  6B
0F33:  MOVWF  6C
0F34:  BCF    0A.3
0F35:  BCF    03.6
0F36:  CALL   417
0F37:  BSF    0A.3
....................    } 
0F38:  GOTO   754
0F39:  BSF    03.6
....................    else if(c_ == 'i') { 
0F3A:  MOVF   3D,W
0F3B:  SUBLW  69
0F3C:  BTFSS  03.2
0F3D:  GOTO   755
....................       btST = !OFF; 
0F3E:  BCF    03.6
0F3F:  BSF    45.1
....................       glcd_text57(110,0,(char*)"BT",1, OFF); //Apagamos BT 
0F40:  MOVLW  42
0F41:  BSF    03.6
0F42:  MOVWF  41
0F43:  MOVLW  54
0F44:  MOVWF  42
0F45:  CLRF   43
0F46:  MOVLW  6E
0F47:  MOVWF  67
0F48:  CLRF   68
0F49:  MOVLW  01
0F4A:  MOVWF  6A
0F4B:  MOVLW  41
0F4C:  MOVWF  69
0F4D:  MOVLW  01
0F4E:  MOVWF  6B
0F4F:  CLRF   6C
0F50:  BCF    0A.3
0F51:  BCF    03.6
0F52:  CALL   417
0F53:  BSF    0A.3
0F54:  BSF    03.6
....................    } 
.................... } 
.................... ///Fin Funciones 
....................  
.................... ///Interrupciones 
....................  
.................... #INT_TIMER0 
.................... void TIMER0_isr(){ //Timer para hacer sonar el buzzer cada 500ms 
....................    ciclos--; 
*
0282:  DECFSZ 46,F
....................    if(ciclos==0){ 
0283:  GOTO   293
....................       ciclos=10; 
0284:  MOVLW  0A
0285:  MOVWF  46
....................       output_low(PIN_B3); 
0286:  BSF    03.5
0287:  BCF    06.3
0288:  BCF    03.5
0289:  BCF    06.3
....................       delay_ms(50); 
028A:  MOVLW  32
028B:  BSF    03.6
028C:  MOVWF  3D
028D:  BCF    03.6
028E:  CALL   26D
....................       output_high(PIN_B3); 
028F:  BSF    03.5
0290:  BCF    06.3
0291:  BCF    03.5
0292:  BSF    06.3
....................    } 
....................    set_timer0(TMR0); 
0293:  MOVLW  40
0294:  MOVWF  01
.................... } 
....................  
0295:  BCF    0B.2
0296:  BCF    0A.3
0297:  BCF    0A.4
0298:  GOTO   02B
.................... #INT_TIMER1 
.................... void TIMER1_isr(){ //Timer para almacenar, en un array, la temepratura actual cada 3 segundos 
....................    ciclosT1--; 
0299:  DECFSZ 47,F
....................    if(ciclosT1==0){ 
029A:  GOTO   2C2
....................       ciclosT1=6; 
029B:  MOVLW  06
029C:  MOVWF  47
....................       //Aca hay que hacer el guardado en sd 
....................       //Con este bloque de codigo guardamos en un array las ultimas N mediciones 
....................       //Las cuales podemos guardar despues donde querramos 
....................       for(int i=0; i<nMediciones-1;i++) 
029D:  BSF    03.6
029E:  CLRF   3D
029F:  MOVF   3D,W
02A0:  SUBLW  4E
02A1:  BTFSS  03.0
02A2:  GOTO   2BD
....................          registro[i]=registro[i+1]; 
02A3:  MOVLW  A0
02A4:  ADDWF  3D,W
02A5:  MOVWF  78
02A6:  CLRF   7A
02A7:  BTFSC  03.0
02A8:  INCF   7A,F
02A9:  MOVF   78,W
02AA:  MOVWF  3E
02AB:  MOVF   7A,W
02AC:  MOVWF  3F
02AD:  MOVLW  01
02AE:  ADDWF  3D,W
02AF:  ADDLW  A0
02B0:  MOVWF  04
02B1:  BCF    03.7
02B2:  MOVF   00,W
02B3:  MOVWF  40
02B4:  MOVF   3E,W
02B5:  MOVWF  04
02B6:  BCF    03.7
02B7:  BTFSC  3F.0
02B8:  BSF    03.7
02B9:  MOVF   40,W
02BA:  MOVWF  00
02BB:  INCF   3D,F
02BC:  GOTO   29F
....................       registro[nMediciones-1]=iAn; 
02BD:  BCF    03.6
02BE:  MOVF   43,W
02BF:  BSF    03.5
02C0:  MOVWF  6F
02C1:  BCF    03.5
....................    } 
....................    set_timer1(TMR1); 
02C2:  CLRF   0E
02C3:  MOVLW  0B
02C4:  MOVWF  0F
02C5:  MOVLW  DC
02C6:  MOVWF  0E
.................... } 
....................  
02C7:  BCF    0C.0
02C8:  BCF    0A.3
02C9:  BCF    0A.4
02CA:  GOTO   02B
.................... #INT_RB 
.................... void RB_isr(){ //Prueba de interrupciones 
....................    if(input(PIN_B6)){ //Habilita o deshabilita la captura de datos 
*
0C03:  BSF    03.5
0C04:  BSF    06.6
0C05:  BCF    03.5
0C06:  BTFSS  06.6
0C07:  GOTO   58C
....................       habilitarLectura=~habilitarLectura; 
0C08:  MOVLW  01
0C09:  XORWF  45,F
....................       disable_interrupts(INT_TIMER0); 
0C0A:  BCF    0B.5
....................       if(habilitarLectura){ 
0C0B:  BTFSS  45.0
0C0C:  GOTO   466
....................          glcd_text57(128/2-30, 0, (char*)"Capturando", 1, ON); 
0C0D:  CLRF   78
0C0E:  MOVLW  0B
0C0F:  MOVWF  77
0C10:  MOVLW  3D
0C11:  MOVWF  04
0C12:  BSF    03.7
0C13:  MOVF   78,W
0C14:  BCF    0A.3
0C15:  CALL   231
0C16:  BSF    0A.3
0C17:  MOVWF  00
0C18:  INCF   78,F
0C19:  INCF   04,F
0C1A:  DECFSZ 77,F
0C1B:  GOTO   413
0C1C:  MOVLW  22
0C1D:  BSF    03.6
0C1E:  MOVWF  67
0C1F:  CLRF   68
0C20:  MOVLW  01
0C21:  MOVWF  6A
0C22:  MOVLW  3D
0C23:  MOVWF  69
0C24:  MOVLW  01
0C25:  MOVWF  6B
0C26:  MOVWF  6C
0C27:  BCF    0A.3
0C28:  BCF    03.6
0C29:  CALL   417
0C2A:  BSF    0A.3
....................          sprintf(str, "%3.2fC", y); 
0C2B:  CLRF   39
0C2C:  MOVLW  2F
0C2D:  MOVWF  38
0C2E:  MOVLW  02
0C2F:  MOVWF  04
0C30:  MOVF   3E,W
0C31:  BSF    03.6
0C32:  MOVWF  68
0C33:  BCF    03.6
0C34:  MOVF   3D,W
0C35:  BSF    03.6
0C36:  MOVWF  67
0C37:  BCF    03.6
0C38:  MOVF   3C,W
0C39:  BSF    03.6
0C3A:  MOVWF  66
0C3B:  BCF    03.6
0C3C:  MOVF   3B,W
0C3D:  BSF    03.6
0C3E:  MOVWF  65
0C3F:  MOVLW  02
0C40:  MOVWF  69
0C41:  BCF    0A.3
0C42:  BCF    03.6
0C43:  CALL   639
0C44:  BSF    0A.3
0C45:  MOVLW  43
0C46:  BSF    03.5
0C47:  BSF    03.6
0C48:  MOVWF  19
0C49:  BCF    0A.3
0C4A:  BCF    03.5
0C4B:  BCF    03.6
0C4C:  CALL   628
0C4D:  BSF    0A.3
....................          glcd_text57(12*6, 10, str, 1, ON); //Escribimos la temperatura. 
0C4E:  MOVLW  48
0C4F:  BSF    03.6
0C50:  MOVWF  67
0C51:  MOVLW  0A
0C52:  MOVWF  68
0C53:  CLRF   6A
0C54:  MOVLW  2F
0C55:  MOVWF  69
0C56:  MOVLW  01
0C57:  MOVWF  6B
0C58:  MOVWF  6C
0C59:  BCF    0A.3
0C5A:  BCF    03.6
0C5B:  CALL   417
0C5C:  BSF    0A.3
....................          enable_interrupts(INT_TIMER1); 
0C5D:  BSF    03.5
0C5E:  BSF    0C.0
....................          set_timer1(TMR1); 
0C5F:  BCF    03.5
0C60:  CLRF   0E
0C61:  MOVLW  0B
0C62:  MOVWF  0F
0C63:  MOVLW  DC
0C64:  MOVWF  0E
....................       } 
0C65:  GOTO   58C
....................       else { 
....................          glcd_text57(128/2-30, 0, (char*)"Capturando", 1, OFF); 
0C66:  CLRF   78
0C67:  MOVLW  0B
0C68:  MOVWF  77
0C69:  MOVLW  48
0C6A:  MOVWF  04
0C6B:  BSF    03.7
0C6C:  MOVF   78,W
0C6D:  BCF    0A.3
0C6E:  CALL   231
0C6F:  BSF    0A.3
0C70:  MOVWF  00
0C71:  INCF   78,F
0C72:  INCF   04,F
0C73:  DECFSZ 77,F
0C74:  GOTO   46C
0C75:  MOVLW  22
0C76:  BSF    03.6
0C77:  MOVWF  67
0C78:  CLRF   68
0C79:  MOVLW  01
0C7A:  MOVWF  6A
0C7B:  MOVLW  48
0C7C:  MOVWF  69
0C7D:  MOVLW  01
0C7E:  MOVWF  6B
0C7F:  CLRF   6C
0C80:  BCF    0A.3
0C81:  BCF    03.6
0C82:  CALL   417
0C83:  BSF    0A.3
....................          glcd_text57(128/2-30, 0, (char*)"Limpiando", 1, ON); 
0C84:  CLRF   78
0C85:  MOVLW  0A
0C86:  MOVWF  77
0C87:  MOVLW  48
0C88:  MOVWF  04
0C89:  BSF    03.7
0C8A:  MOVF   78,W
0C8B:  BCF    0A.3
0C8C:  CALL   240
0C8D:  BSF    0A.3
0C8E:  MOVWF  00
0C8F:  INCF   78,F
0C90:  INCF   04,F
0C91:  DECFSZ 77,F
0C92:  GOTO   48A
0C93:  MOVLW  22
0C94:  BSF    03.6
0C95:  MOVWF  67
0C96:  CLRF   68
0C97:  MOVLW  01
0C98:  MOVWF  6A
0C99:  MOVLW  48
0C9A:  MOVWF  69
0C9B:  MOVLW  01
0C9C:  MOVWF  6B
0C9D:  MOVWF  6C
0C9E:  BCF    0A.3
0C9F:  BCF    03.6
0CA0:  CALL   417
0CA1:  BSF    0A.3
....................          limpiarGrafico; 
0CA2:  BSF    03.6
0CA3:  CLRF   6A
0CA4:  MOVLW  14
0CA5:  MOVWF  6B
0CA6:  MOVLW  80
0CA7:  MOVWF  6C
0CA8:  MOVLW  2C
0CA9:  MOVWF  6D
....................          glcd_text57(128/2-30, 0, (char*)"Limpiando", 1, OFF); 
*
0CCA:  CLRF   78
0CCB:  MOVLW  0A
0CCC:  MOVWF  77
0CCD:  MOVLW  48
0CCE:  MOVWF  04
0CCF:  BSF    03.7
0CD0:  MOVF   78,W
0CD1:  BCF    0A.3
0CD2:  BCF    03.6
0CD3:  CALL   240
0CD4:  BSF    0A.3
0CD5:  MOVWF  00
0CD6:  INCF   78,F
0CD7:  INCF   04,F
0CD8:  DECFSZ 77,F
0CD9:  GOTO   4DB
0CDA:  GOTO   4DD
0CDB:  BSF    03.6
0CDC:  GOTO   4D0
0CDD:  MOVLW  22
0CDE:  BSF    03.6
0CDF:  MOVWF  67
0CE0:  CLRF   68
0CE1:  MOVLW  01
0CE2:  MOVWF  6A
0CE3:  MOVLW  48
0CE4:  MOVWF  69
0CE5:  MOVLW  01
0CE6:  MOVWF  6B
0CE7:  CLRF   6C
0CE8:  BCF    0A.3
0CE9:  BCF    03.6
0CEA:  CALL   417
0CEB:  BSF    0A.3
....................          sprintf(str, "%3.2fC", t); 
0CEC:  CLRF   39
0CED:  MOVLW  2F
0CEE:  MOVWF  38
0CEF:  MOVLW  02
0CF0:  MOVWF  04
0CF1:  MOVF   42,W
0CF2:  BSF    03.6
0CF3:  MOVWF  68
0CF4:  BCF    03.6
0CF5:  MOVF   41,W
0CF6:  BSF    03.6
0CF7:  MOVWF  67
0CF8:  BCF    03.6
0CF9:  MOVF   40,W
0CFA:  BSF    03.6
0CFB:  MOVWF  66
0CFC:  BCF    03.6
0CFD:  MOVF   3F,W
0CFE:  BSF    03.6
0CFF:  MOVWF  65
0D00:  MOVLW  02
0D01:  MOVWF  69
0D02:  BCF    0A.3
0D03:  BCF    03.6
0D04:  CALL   639
0D05:  BSF    0A.3
0D06:  MOVLW  43
0D07:  BSF    03.5
0D08:  BSF    03.6
0D09:  MOVWF  19
0D0A:  BCF    0A.3
0D0B:  BCF    03.5
0D0C:  BCF    03.6
0D0D:  CALL   628
0D0E:  BSF    0A.3
....................          glcd_text57(12*6, 10, str, 1, OFF); 
0D0F:  MOVLW  48
0D10:  BSF    03.6
0D11:  MOVWF  67
0D12:  MOVLW  0A
0D13:  MOVWF  68
0D14:  CLRF   6A
0D15:  MOVLW  2F
0D16:  MOVWF  69
0D17:  MOVLW  01
0D18:  MOVWF  6B
0D19:  CLRF   6C
0D1A:  BCF    0A.3
0D1B:  BCF    03.6
0D1C:  CALL   417
0D1D:  BSF    0A.3
....................          x=0; 
0D1E:  CLRF   3A
....................          disable_interrupts(INT_TIMER1); 
0D1F:  BSF    03.5
0D20:  BCF    0C.0
....................          glcd_text57(128/2-30, 0, (char*)"Guardando", 1, ON); 
0D21:  CLRF   78
0D22:  MOVLW  0A
0D23:  MOVWF  77
0D24:  MOVLW  48
0D25:  MOVWF  04
0D26:  BSF    03.7
0D27:  MOVF   78,W
0D28:  BCF    0A.3
0D29:  BCF    03.5
0D2A:  CALL   24E
0D2B:  BSF    0A.3
0D2C:  MOVWF  00
0D2D:  INCF   78,F
0D2E:  INCF   04,F
0D2F:  DECFSZ 77,F
0D30:  GOTO   532
0D31:  GOTO   534
0D32:  BSF    03.5
0D33:  GOTO   527
0D34:  MOVLW  22
0D35:  BSF    03.6
0D36:  MOVWF  67
0D37:  CLRF   68
0D38:  MOVLW  01
0D39:  MOVWF  6A
0D3A:  MOVLW  48
0D3B:  MOVWF  69
0D3C:  MOVLW  01
0D3D:  MOVWF  6B
0D3E:  MOVWF  6C
0D3F:  BCF    0A.3
0D40:  BCF    03.6
0D41:  CALL   417
0D42:  BSF    0A.3
....................          for(int pos=0; pos<nMediciones; pos++) 
0D43:  BSF    03.6
0D44:  CLRF   53
0D45:  MOVF   53,W
0D46:  SUBLW  4F
0D47:  BTFSS  03.0
0D48:  GOTO   56A
....................             write_eeprom(pos, registro[pos]); 
0D49:  MOVLW  A0
0D4A:  ADDWF  53,W
0D4B:  MOVWF  04
0D4C:  BCF    03.7
0D4D:  MOVF   00,W
0D4E:  MOVWF  65
0D4F:  BCF    03.6
0D50:  MOVF   0B,W
0D51:  MOVWF  77
0D52:  BCF    0B.7
0D53:  BSF    03.6
0D54:  MOVF   53,W
0D55:  MOVWF  0D
0D56:  MOVF   65,W
0D57:  MOVWF  0C
0D58:  BSF    03.5
0D59:  BCF    0C.7
0D5A:  BSF    0C.2
0D5B:  MOVLW  55
0D5C:  MOVWF  0D
0D5D:  MOVLW  AA
0D5E:  MOVWF  0D
0D5F:  BSF    0C.1
0D60:  BTFSC  0C.1
0D61:  GOTO   560
0D62:  BCF    0C.2
0D63:  MOVF   77,W
0D64:  BCF    03.5
0D65:  BCF    03.6
0D66:  IORWF  0B,F
0D67:  BSF    03.6
0D68:  INCF   53,F
0D69:  GOTO   545
....................          glcd_text57(128/2-30, 0, (char*)"Guardando", 1, OFF); 
0D6A:  CLRF   78
0D6B:  MOVLW  0A
0D6C:  MOVWF  77
0D6D:  MOVLW  48
0D6E:  MOVWF  04
0D6F:  BSF    03.7
0D70:  MOVF   78,W
0D71:  BCF    0A.3
0D72:  BCF    03.6
0D73:  CALL   24E
0D74:  BSF    0A.3
0D75:  MOVWF  00
0D76:  INCF   78,F
0D77:  INCF   04,F
0D78:  DECFSZ 77,F
0D79:  GOTO   57B
0D7A:  GOTO   57D
0D7B:  BSF    03.6
0D7C:  GOTO   570
0D7D:  MOVLW  22
0D7E:  BSF    03.6
0D7F:  MOVWF  67
0D80:  CLRF   68
0D81:  MOVLW  01
0D82:  MOVWF  6A
0D83:  MOVLW  48
0D84:  MOVWF  69
0D85:  MOVLW  01
0D86:  MOVWF  6B
0D87:  CLRF   6C
0D88:  BCF    0A.3
0D89:  BCF    03.6
0D8A:  CALL   417
0D8B:  BSF    0A.3
....................       } 
....................    } 
....................    if(input(PIN_B7)){ 
0D8C:  BSF    03.5
0D8D:  BSF    06.7
0D8E:  BCF    03.5
0D8F:  BTFSS  06.7
0D90:  GOTO   713
....................       habilitarLectura=0; 
0D91:  BCF    45.0
....................       glcd_text57(128/2-30, 0, (char*)"Capturando", 1, OFF); 
0D92:  CLRF   78
0D93:  MOVLW  0B
0D94:  MOVWF  77
0D95:  MOVLW  54
0D96:  MOVWF  04
0D97:  BSF    03.7
0D98:  MOVF   78,W
0D99:  BCF    0A.3
0D9A:  CALL   231
0D9B:  BSF    0A.3
0D9C:  MOVWF  00
0D9D:  INCF   78,F
0D9E:  INCF   04,F
0D9F:  DECFSZ 77,F
0DA0:  GOTO   598
0DA1:  MOVLW  22
0DA2:  BSF    03.6
0DA3:  MOVWF  67
0DA4:  CLRF   68
0DA5:  MOVLW  01
0DA6:  MOVWF  6A
0DA7:  MOVLW  54
0DA8:  MOVWF  69
0DA9:  MOVLW  01
0DAA:  MOVWF  6B
0DAB:  CLRF   6C
0DAC:  BCF    0A.3
0DAD:  BCF    03.6
0DAE:  CALL   417
0DAF:  BSF    0A.3
....................       disable_interrupts(INT_TIMER1); 
0DB0:  BSF    03.5
0DB1:  BCF    0C.0
....................       disable_interrupts(INT_TIMER0); 
0DB2:  BCF    03.5
0DB3:  BCF    0B.5
....................       for(int pos=0; pos<nMediciones; pos++){ 
0DB4:  BSF    03.6
0DB5:  CLRF   5F
0DB6:  MOVF   5F,W
0DB7:  SUBLW  4F
0DB8:  BTFSS  03.0
0DB9:  GOTO   6A8
....................          registro[pos]=read_eeprom(pos); 
0DBA:  MOVLW  A0
0DBB:  ADDWF  5F,W
0DBC:  MOVWF  04
0DBD:  BCF    03.7
0DBE:  MOVF   5F,W
0DBF:  MOVWF  0D
0DC0:  BSF    03.5
0DC1:  BCF    0C.7
0DC2:  BSF    0C.0
0DC3:  BCF    03.5
0DC4:  MOVF   0C,W
0DC5:  MOVWF  00
....................          float dato=(5.0*registro[pos]*100.0)/1024.0; 
0DC6:  MOVLW  A0
0DC7:  ADDWF  5F,W
0DC8:  MOVWF  04
0DC9:  BCF    03.7
0DCA:  MOVF   00,W
0DCB:  CLRF   66
0DCC:  MOVWF  65
0DCD:  BCF    0A.3
0DCE:  BCF    03.6
0DCF:  CALL   755
0DD0:  BSF    0A.3
0DD1:  BSF    03.5
0DD2:  BSF    03.6
0DD3:  CLRF   1C
0DD4:  CLRF   1B
0DD5:  MOVLW  20
0DD6:  MOVWF  1A
0DD7:  MOVLW  81
0DD8:  MOVWF  19
0DD9:  MOVF   7A,W
0DDA:  MOVWF  20
0DDB:  MOVF   79,W
0DDC:  MOVWF  1F
0DDD:  MOVF   78,W
0DDE:  MOVWF  1E
0DDF:  MOVF   77,W
0DE0:  MOVWF  1D
0DE1:  BCF    0A.3
0DE2:  BCF    03.5
0DE3:  BCF    03.6
0DE4:  CALL   539
0DE5:  BSF    0A.3
0DE6:  MOVF   7A,W
0DE7:  BSF    03.6
0DE8:  MOVWF  68
0DE9:  MOVF   79,W
0DEA:  MOVWF  67
0DEB:  MOVF   78,W
0DEC:  MOVWF  66
0DED:  MOVF   77,W
0DEE:  MOVWF  65
0DEF:  MOVF   68,W
0DF0:  BSF    03.5
0DF1:  MOVWF  1C
0DF2:  BCF    03.5
0DF3:  MOVF   67,W
0DF4:  BSF    03.5
0DF5:  MOVWF  1B
0DF6:  BCF    03.5
0DF7:  MOVF   66,W
0DF8:  BSF    03.5
0DF9:  MOVWF  1A
0DFA:  BCF    03.5
0DFB:  MOVF   65,W
0DFC:  BSF    03.5
0DFD:  MOVWF  19
0DFE:  CLRF   20
0DFF:  CLRF   1F
0E00:  MOVLW  48
0E01:  MOVWF  1E
0E02:  MOVLW  85
0E03:  MOVWF  1D
0E04:  BCF    0A.3
0E05:  BCF    03.5
0E06:  BCF    03.6
0E07:  CALL   539
0E08:  BSF    0A.3
0E09:  MOVF   7A,W
0E0A:  BSF    03.6
0E0B:  MOVWF  68
0E0C:  MOVF   79,W
0E0D:  MOVWF  67
0E0E:  MOVF   78,W
0E0F:  MOVWF  66
0E10:  MOVF   77,W
0E11:  MOVWF  65
0E12:  MOVF   68,W
0E13:  MOVWF  6C
0E14:  MOVF   67,W
0E15:  MOVWF  6B
0E16:  MOVF   66,W
0E17:  MOVWF  6A
0E18:  MOVF   65,W
0E19:  MOVWF  69
0E1A:  BSF    03.5
0E1B:  CLRF   13
0E1C:  CLRF   12
0E1D:  CLRF   11
0E1E:  MOVLW  89
0E1F:  MOVWF  10
0E20:  BCF    03.5
0E21:  BCF    03.6
0E22:  CALL   000
0E23:  MOVF   7A,W
0E24:  BSF    03.6
0E25:  MOVWF  63
0E26:  MOVF   79,W
0E27:  MOVWF  62
0E28:  MOVF   78,W
0E29:  MOVWF  61
0E2A:  MOVF   77,W
0E2B:  MOVWF  60
....................          if(dato>=28 && dato<=50) 
0E2C:  CLRF   68
0E2D:  CLRF   67
0E2E:  MOVLW  60
0E2F:  MOVWF  66
0E30:  MOVLW  83
0E31:  MOVWF  65
0E32:  MOVF   63,W
0E33:  MOVWF  6C
0E34:  MOVF   62,W
0E35:  MOVWF  6B
0E36:  MOVF   61,W
0E37:  MOVWF  6A
0E38:  MOVF   60,W
0E39:  MOVWF  69
0E3A:  BCF    0A.3
0E3B:  BCF    03.6
0E3C:  CALL   774
0E3D:  BSF    0A.3
0E3E:  BTFSC  03.0
0E3F:  GOTO   642
0E40:  BTFSS  03.2
0E41:  GOTO   664
0E42:  BSF    03.6
0E43:  MOVF   63,W
0E44:  MOVWF  68
0E45:  MOVF   62,W
0E46:  MOVWF  67
0E47:  MOVF   61,W
0E48:  MOVWF  66
0E49:  MOVF   60,W
0E4A:  MOVWF  65
0E4B:  CLRF   6C
0E4C:  CLRF   6B
0E4D:  MOVLW  48
0E4E:  MOVWF  6A
0E4F:  MOVLW  84
0E50:  MOVWF  69
0E51:  BCF    0A.3
0E52:  BCF    03.6
0E53:  CALL   774
0E54:  BSF    0A.3
0E55:  BTFSC  03.0
0E56:  GOTO   659
0E57:  BTFSS  03.2
0E58:  GOTO   664
....................             nuevaLinea(dato); 
0E59:  BSF    03.6
0E5A:  MOVF   63,W
0E5B:  MOVWF  68
0E5C:  MOVF   62,W
0E5D:  MOVWF  67
0E5E:  MOVF   61,W
0E5F:  MOVWF  66
0E60:  MOVF   60,W
0E61:  MOVWF  65
0E62:  BCF    03.6
0E63:  CALL   30C
....................          if(dato<28) 
0E64:  BSF    03.6
0E65:  MOVF   63,W
0E66:  MOVWF  68
0E67:  MOVF   62,W
0E68:  MOVWF  67
0E69:  MOVF   61,W
0E6A:  MOVWF  66
0E6B:  MOVF   60,W
0E6C:  MOVWF  65
0E6D:  CLRF   6C
0E6E:  CLRF   6B
0E6F:  MOVLW  60
0E70:  MOVWF  6A
0E71:  MOVLW  83
0E72:  MOVWF  69
0E73:  BCF    0A.3
0E74:  BCF    03.6
0E75:  CALL   774
0E76:  BSF    0A.3
0E77:  BTFSS  03.0
0E78:  GOTO   682
....................             nuevaLinea(29); 
0E79:  BSF    03.6
0E7A:  CLRF   68
0E7B:  CLRF   67
0E7C:  MOVLW  68
0E7D:  MOVWF  66
0E7E:  MOVLW  83
0E7F:  MOVWF  65
0E80:  BCF    03.6
0E81:  CALL   30C
....................          if(dato>50) 
0E82:  BSF    03.6
0E83:  CLRF   68
0E84:  CLRF   67
0E85:  MOVLW  48
0E86:  MOVWF  66
0E87:  MOVLW  84
0E88:  MOVWF  65
0E89:  MOVF   63,W
0E8A:  MOVWF  6C
0E8B:  MOVF   62,W
0E8C:  MOVWF  6B
0E8D:  MOVF   61,W
0E8E:  MOVWF  6A
0E8F:  MOVF   60,W
0E90:  MOVWF  69
0E91:  BCF    0A.3
0E92:  BCF    03.6
0E93:  CALL   774
0E94:  BSF    0A.3
0E95:  BTFSS  03.0
0E96:  GOTO   6A0
....................             nuevaLinea(50); 
0E97:  BSF    03.6
0E98:  CLRF   68
0E99:  CLRF   67
0E9A:  MOVLW  48
0E9B:  MOVWF  66
0E9C:  MOVLW  84
0E9D:  MOVWF  65
0E9E:  BCF    03.6
0E9F:  CALL   30C
....................          registro[pos]=0; 
0EA0:  MOVLW  A0
0EA1:  BSF    03.6
0EA2:  ADDWF  5F,W
0EA3:  MOVWF  04
0EA4:  BCF    03.7
0EA5:  CLRF   00
0EA6:  INCF   5F,F
0EA7:  GOTO   5B6
....................       } 
....................       glcd_text57(128/2-30, 0, (char*)"Guardando", 1, ON); 
0EA8:  CLRF   78
0EA9:  MOVLW  0A
0EAA:  MOVWF  77
0EAB:  MOVLW  54
0EAC:  MOVWF  04
0EAD:  BSF    03.7
0EAE:  MOVF   78,W
0EAF:  BCF    0A.3
0EB0:  BCF    03.6
0EB1:  CALL   24E
0EB2:  BSF    0A.3
0EB3:  MOVWF  00
0EB4:  INCF   78,F
0EB5:  INCF   04,F
0EB6:  DECFSZ 77,F
0EB7:  GOTO   6B9
0EB8:  GOTO   6BB
0EB9:  BSF    03.6
0EBA:  GOTO   6AE
0EBB:  MOVLW  22
0EBC:  BSF    03.6
0EBD:  MOVWF  67
0EBE:  CLRF   68
0EBF:  MOVLW  01
0EC0:  MOVWF  6A
0EC1:  MOVLW  54
0EC2:  MOVWF  69
0EC3:  MOVLW  01
0EC4:  MOVWF  6B
0EC5:  MOVWF  6C
0EC6:  BCF    0A.3
0EC7:  BCF    03.6
0EC8:  CALL   417
0EC9:  BSF    0A.3
....................       for(int pos=0; pos<nMediciones; pos++) 
0ECA:  BSF    03.6
0ECB:  CLRF   64
0ECC:  MOVF   64,W
0ECD:  SUBLW  4F
0ECE:  BTFSS  03.0
0ECF:  GOTO   6F1
....................          write_eeprom(pos, registro[pos]); 
0ED0:  MOVLW  A0
0ED1:  ADDWF  64,W
0ED2:  MOVWF  04
0ED3:  BCF    03.7
0ED4:  MOVF   00,W
0ED5:  MOVWF  65
0ED6:  BCF    03.6
0ED7:  MOVF   0B,W
0ED8:  MOVWF  77
0ED9:  BCF    0B.7
0EDA:  BSF    03.6
0EDB:  MOVF   64,W
0EDC:  MOVWF  0D
0EDD:  MOVF   65,W
0EDE:  MOVWF  0C
0EDF:  BSF    03.5
0EE0:  BCF    0C.7
0EE1:  BSF    0C.2
0EE2:  MOVLW  55
0EE3:  MOVWF  0D
0EE4:  MOVLW  AA
0EE5:  MOVWF  0D
0EE6:  BSF    0C.1
0EE7:  BTFSC  0C.1
0EE8:  GOTO   6E7
0EE9:  BCF    0C.2
0EEA:  MOVF   77,W
0EEB:  BCF    03.5
0EEC:  BCF    03.6
0EED:  IORWF  0B,F
0EEE:  BSF    03.6
0EEF:  INCF   64,F
0EF0:  GOTO   6CC
....................       glcd_text57(128/2-30, 0, (char*)"Guardando", 1, OFF); 
0EF1:  CLRF   78
0EF2:  MOVLW  0A
0EF3:  MOVWF  77
0EF4:  MOVLW  54
0EF5:  MOVWF  04
0EF6:  BSF    03.7
0EF7:  MOVF   78,W
0EF8:  BCF    0A.3
0EF9:  BCF    03.6
0EFA:  CALL   24E
0EFB:  BSF    0A.3
0EFC:  MOVWF  00
0EFD:  INCF   78,F
0EFE:  INCF   04,F
0EFF:  DECFSZ 77,F
0F00:  GOTO   702
0F01:  GOTO   704
0F02:  BSF    03.6
0F03:  GOTO   6F7
0F04:  MOVLW  22
0F05:  BSF    03.6
0F06:  MOVWF  67
0F07:  CLRF   68
0F08:  MOVLW  01
0F09:  MOVWF  6A
0F0A:  MOVLW  54
0F0B:  MOVWF  69
0F0C:  MOVLW  01
0F0D:  MOVWF  6B
0F0E:  CLRF   6C
0F0F:  BCF    0A.3
0F10:  BCF    03.6
0F11:  CALL   417
0F12:  BSF    0A.3
....................    } 
.................... } 
....................  
0F13:  BCF    0B.0
0F14:  BCF    0A.3
0F15:  BCF    0A.4
0F16:  GOTO   02B
.................... #INT_RDA 
.................... void serial_interrupt() { 
....................    r_ = getc(); 
0F17:  BTFSS  0C.5
0F18:  GOTO   717
0F19:  MOVF   1A,W
0F1A:  MOVWF  48
....................    toggleBT(r_); 
0F1B:  MOVF   48,W
0F1C:  BSF    03.6
0F1D:  MOVWF  3D
*
0F55:  BCF    03.6
0F56:  BCF    0C.5
0F57:  BCF    0A.3
0F58:  BCF    0A.4
0F59:  GOTO   02B
.................... } 
....................  
.................... ///Fin Interrupciones 
....................  
.................... void main() 
*
1376:  MOVF   03,W
1377:  ANDLW  1F
1378:  MOVWF  03
1379:  MOVLW  19
137A:  BSF    03.5
137B:  MOVWF  19
137C:  MOVLW  A6
137D:  MOVWF  18
137E:  MOVLW  90
137F:  BCF    03.5
1380:  MOVWF  18
1381:  MOVLW  FF
1382:  MOVWF  28
1383:  CLRF   39
1384:  CLRF   38
1385:  CLRF   3A
1386:  BCF    45.0
1387:  MOVLW  0A
1388:  MOVWF  46
1389:  MOVLW  06
138A:  MOVWF  47
138B:  BCF    45.1
138C:  BSF    03.5
138D:  BSF    1F.0
138E:  BSF    1F.1
138F:  BSF    1F.2
1390:  BCF    1F.3
1391:  BCF    03.5
1392:  CLRF   2A
1393:  MOVLW  49
1394:  MOVWF  29
1395:  MOVLW  2B
1396:  MOVWF  49
1397:  MOVLW  01
1398:  MOVWF  4B
1399:  MOVLW  A6
139A:  MOVWF  4A
139B:  MOVLW  47
139C:  BSF    03.5
139D:  BSF    03.6
139E:  MOVWF  26
139F:  CLRF   28
13A0:  CLRF   27
13A1:  BCF    03.5
13A2:  BCF    03.6
13A3:  BCF    03.7
.................... { 
....................    trisb=0b01000000; 
*
13A8:  MOVLW  40
13A9:  BSF    03.5
13AA:  MOVWF  06
....................     
....................    setup_adc_ports(AN0); //seteamos el pin A0 como analogico 
13AB:  BCF    1F.0
13AC:  BSF    1F.1
13AD:  BSF    1F.2
13AE:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); //Establecemos el reloj interno 
13AF:  BCF    03.5
13B0:  BSF    1F.6
13B1:  BSF    1F.7
13B2:  BSF    03.5
13B3:  BSF    1F.7
13B4:  BCF    03.5
13B5:  BSF    1F.0
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); //setup del timer0 
13B6:  BSF    03.5
13B7:  MOVF   01,W
13B8:  ANDLW  C0
13B9:  IORLW  07
13BA:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //setup del timer1 
13BB:  MOVLW  B5
13BC:  BCF    03.5
13BD:  MOVWF  10
....................    set_timer0(TMR0); //seteamos el timer0 
13BE:  MOVLW  40
13BF:  MOVWF  01
....................    set_timer1(TMR1); //setemaos el timer1 
13C0:  CLRF   0E
13C1:  MOVLW  0B
13C2:  MOVWF  0F
13C3:  MOVLW  DC
13C4:  MOVWF  0E
....................     
....................    glcd_init(ON); //Inicializamos el lcd 
13C5:  MOVLW  01
13C6:  BSF    03.6
13C7:  MOVWF  1D
13C8:  BCF    03.6
13C9:  GOTO   000
....................     
....................    enable_interrupts(INT_RB); //Habilitamos las interrupciones del RB4-7 
13CA:  BSF    0B.3
....................    enable_interrupts(INT_RDA);//Habilitamos las interrupciones del RDA 
13CB:  BSF    03.5
13CC:  BSF    0C.5
....................    enable_interrupts(GLOBAL); //Habilitamos las interrupciones globales 
13CD:  MOVLW  C0
13CE:  BCF    03.5
13CF:  IORWF  0B,F
....................  
....................    glcd_text57(0,10,(char*)"Temperatura:",1,ON); //Escribimos el texto "Tempreatura:" en la posicion 0,10 
13D0:  CLRF   78
13D1:  MOVLW  0D
13D2:  MOVWF  77
13D3:  MOVLW  10
13D4:  MOVWF  04
13D5:  BSF    03.7
13D6:  MOVF   78,W
13D7:  BCF    0A.4
13D8:  CALL   25C
13D9:  BSF    0A.4
13DA:  MOVWF  00
13DB:  INCF   78,F
13DC:  INCF   04,F
13DD:  DECFSZ 77,F
13DE:  GOTO   3D6
13DF:  CLRF   27
13E0:  BTFSC  0B.7
13E1:  BSF    27.7
13E2:  BCF    0B.7
13E3:  BSF    03.6
13E4:  CLRF   67
13E5:  MOVLW  0A
13E6:  MOVWF  68
13E7:  MOVLW  01
13E8:  MOVWF  6A
13E9:  MOVLW  10
13EA:  MOVWF  69
13EB:  MOVLW  01
13EC:  MOVWF  6B
13ED:  MOVWF  6C
13EE:  BCF    0A.4
13EF:  BCF    03.6
13F0:  CALL   417
13F1:  BSF    0A.4
13F2:  BTFSC  27.7
13F3:  BSF    0B.7
13F4:  CLRF   27
13F5:  BTFSC  0B.7
13F6:  BSF    27.7
13F7:  BCF    0B.7
....................    glcd_line(0, 8, 128, 8, ON); //Pintamos una linea por debajo del barra de notificaciones 
13F8:  BSF    03.6
13F9:  CLRF   6C
13FA:  MOVLW  08
13FB:  MOVWF  6D
13FC:  MOVLW  80
13FD:  MOVWF  6E
13FE:  MOVLW  08
13FF:  MOVWF  6F
1400:  MOVLW  01
1401:  BSF    03.5
1402:  MOVWF  10
1403:  BCF    0A.4
1404:  BSF    0A.3
1405:  BCF    03.5
1406:  BCF    03.6
1407:  CALL   22E
1408:  BSF    0A.4
1409:  BCF    0A.3
140A:  BTFSC  27.7
140B:  BSF    0B.7
140C:  CLRF   27
140D:  BTFSC  0B.7
140E:  BSF    27.7
140F:  BCF    0B.7
....................    glcd_line(0, 19, 128, 19, ON); //Pintamos una linea por debajo de la temperatura 
1410:  BSF    03.6
1411:  CLRF   6C
1412:  MOVLW  13
1413:  MOVWF  6D
1414:  MOVLW  80
1415:  MOVWF  6E
1416:  MOVLW  13
1417:  MOVWF  6F
1418:  MOVLW  01
1419:  BSF    03.5
141A:  MOVWF  10
141B:  BCF    0A.4
141C:  BSF    0A.3
141D:  BCF    03.5
141E:  BCF    03.6
141F:  CALL   22E
1420:  BSF    0A.4
1421:  BCF    0A.3
1422:  BTFSC  27.7
1423:  BSF    0B.7
....................     
....................    set_adc_channel(0); //Seteamos el canal que vamos a leer 
1424:  MOVLW  00
1425:  MOVWF  78
1426:  MOVF   1F,W
1427:  ANDLW  C7
1428:  IORWF  78,W
1429:  MOVWF  1F
142A:  CLRF   27
142B:  BTFSC  0B.7
142C:  BSF    27.7
142D:  BCF    0B.7
....................    delay_ms(250); //Esperamos 250 ms para tener una captura mas real de la primera temperatura 
142E:  MOVLW  FA
142F:  BSF    03.6
1430:  MOVWF  3D
1431:  BCF    0A.4
1432:  BCF    03.6
1433:  CALL   26D
1434:  BSF    0A.4
1435:  BTFSC  27.7
1436:  BSF    0B.7
....................    iAn=read_adc(); //Levantamos el dato 
1437:  BSF    1F.2
1438:  BTFSC  1F.2
1439:  GOTO   438
143A:  BSF    03.5
143B:  MOVF   1E,W
143C:  BCF    03.5
143D:  MOVWF  43
143E:  MOVF   1E,W
143F:  MOVWF  44
1440:  CLRF   27
1441:  BTFSC  0B.7
1442:  BSF    27.7
1443:  BCF    0B.7
....................    y=(5.0*iAn*100.0)/1024.0; //Lo convertemos a temperatura. Esta es la primera captura 
1444:  MOVF   44,W
1445:  BSF    03.6
1446:  MOVWF  66
1447:  BCF    03.6
1448:  MOVF   43,W
1449:  BSF    03.6
144A:  MOVWF  65
144B:  BCF    0A.4
144C:  BCF    03.6
144D:  CALL   755
144E:  BSF    0A.4
144F:  BTFSC  27.7
1450:  BSF    0B.7
1451:  CLRF   27
1452:  BTFSC  0B.7
1453:  BSF    27.7
1454:  BCF    0B.7
1455:  BSF    03.5
1456:  BSF    03.6
1457:  CLRF   1C
1458:  CLRF   1B
1459:  MOVLW  20
145A:  MOVWF  1A
145B:  MOVLW  81
145C:  MOVWF  19
145D:  MOVF   7A,W
145E:  MOVWF  20
145F:  MOVF   79,W
1460:  MOVWF  1F
1461:  MOVF   78,W
1462:  MOVWF  1E
1463:  MOVF   77,W
1464:  MOVWF  1D
1465:  BCF    0A.4
1466:  BCF    03.5
1467:  BCF    03.6
1468:  CALL   539
1469:  BSF    0A.4
146A:  BTFSC  27.7
146B:  BSF    0B.7
146C:  MOVF   7A,W
146D:  BSF    03.6
146E:  MOVWF  20
146F:  MOVF   79,W
1470:  MOVWF  1F
1471:  MOVF   78,W
1472:  MOVWF  1E
1473:  MOVF   77,W
1474:  MOVWF  1D
1475:  BCF    03.6
1476:  CLRF   27
1477:  BTFSC  0B.7
1478:  BSF    27.7
1479:  BCF    0B.7
147A:  BSF    03.6
147B:  MOVF   20,W
147C:  BSF    03.5
147D:  MOVWF  1C
147E:  BCF    03.5
147F:  MOVF   1F,W
1480:  BSF    03.5
1481:  MOVWF  1B
1482:  BCF    03.5
1483:  MOVF   1E,W
1484:  BSF    03.5
1485:  MOVWF  1A
1486:  BCF    03.5
1487:  MOVF   1D,W
1488:  BSF    03.5
1489:  MOVWF  19
148A:  CLRF   20
148B:  CLRF   1F
148C:  MOVLW  48
148D:  MOVWF  1E
148E:  MOVLW  85
148F:  MOVWF  1D
1490:  BCF    0A.4
1491:  BCF    03.5
1492:  BCF    03.6
1493:  CALL   539
1494:  BSF    0A.4
1495:  BTFSC  27.7
1496:  BSF    0B.7
1497:  MOVF   7A,W
1498:  BSF    03.6
1499:  MOVWF  20
149A:  MOVF   79,W
149B:  MOVWF  1F
149C:  MOVF   78,W
149D:  MOVWF  1E
149E:  MOVF   77,W
149F:  MOVWF  1D
14A0:  BCF    03.6
14A1:  CLRF   27
14A2:  BTFSC  0B.7
14A3:  BSF    27.7
14A4:  BCF    0B.7
14A5:  BSF    03.6
14A6:  MOVF   20,W
14A7:  MOVWF  6C
14A8:  MOVF   1F,W
14A9:  MOVWF  6B
14AA:  MOVF   1E,W
14AB:  MOVWF  6A
14AC:  MOVF   1D,W
14AD:  MOVWF  69
14AE:  BSF    03.5
14AF:  CLRF   13
14B0:  CLRF   12
14B1:  CLRF   11
14B2:  MOVLW  89
14B3:  MOVWF  10
14B4:  BCF    0A.4
14B5:  BSF    0A.3
14B6:  BCF    03.5
14B7:  BCF    03.6
14B8:  CALL   000
14B9:  BSF    0A.4
14BA:  BCF    0A.3
14BB:  BTFSC  27.7
14BC:  BSF    0B.7
14BD:  MOVF   7A,W
14BE:  MOVWF  3E
14BF:  MOVF   79,W
14C0:  MOVWF  3D
14C1:  MOVF   78,W
14C2:  MOVWF  3C
14C3:  MOVF   77,W
14C4:  MOVWF  3B
14C5:  CLRF   27
14C6:  BTFSC  0B.7
14C7:  BSF    27.7
14C8:  BCF    0B.7
....................    delay_ms(250); 
14C9:  MOVLW  FA
14CA:  BSF    03.6
14CB:  MOVWF  3D
14CC:  BCF    0A.4
14CD:  BCF    03.6
14CE:  CALL   26D
14CF:  BSF    0A.4
14D0:  BTFSC  27.7
14D1:  BSF    0B.7
....................     
....................    set_SERIALsr(); 
14D2:  GOTO   185
....................     
....................    while(TRUE) { 
....................       if(habilitarLectura){ 
14D3:  BTFSS  45.0
14D4:  GOTO   7FD
....................          set_adc_channel(0); //Seteamos el canal que vamos a leer 
14D5:  MOVLW  00
14D6:  MOVWF  78
14D7:  MOVF   1F,W
14D8:  ANDLW  C7
14D9:  IORWF  78,W
14DA:  MOVWF  1F
....................          delay_us(10); //Esperamos 10 us 
14DB:  MOVLW  03
14DC:  MOVWF  77
14DD:  DECFSZ 77,F
14DE:  GOTO   4DD
....................          iAn=read_adc(); //Levantamos el dato 
14DF:  BSF    1F.2
14E0:  BTFSC  1F.2
14E1:  GOTO   4E0
14E2:  BSF    03.5
14E3:  MOVF   1E,W
14E4:  BCF    03.5
14E5:  MOVWF  43
14E6:  MOVF   1E,W
14E7:  MOVWF  44
14E8:  CLRF   27
14E9:  BTFSC  0B.7
14EA:  BSF    27.7
14EB:  BCF    0B.7
....................          t=(5.0*iAn*100.0)/1024.0; //Lo convertemos a temperatura 
14EC:  MOVF   44,W
14ED:  BSF    03.6
14EE:  MOVWF  66
14EF:  BCF    03.6
14F0:  MOVF   43,W
14F1:  BSF    03.6
14F2:  MOVWF  65
14F3:  BCF    0A.4
14F4:  BCF    03.6
14F5:  CALL   755
14F6:  BSF    0A.4
14F7:  BTFSC  27.7
14F8:  BSF    0B.7
14F9:  CLRF   27
14FA:  BTFSC  0B.7
14FB:  BSF    27.7
14FC:  BCF    0B.7
14FD:  BSF    03.5
14FE:  BSF    03.6
14FF:  CLRF   1C
1500:  CLRF   1B
1501:  MOVLW  20
1502:  MOVWF  1A
1503:  MOVLW  81
1504:  MOVWF  19
1505:  MOVF   7A,W
1506:  MOVWF  20
1507:  MOVF   79,W
1508:  MOVWF  1F
1509:  MOVF   78,W
150A:  MOVWF  1E
150B:  MOVF   77,W
150C:  MOVWF  1D
150D:  BCF    0A.4
150E:  BCF    03.5
150F:  BCF    03.6
1510:  CALL   539
1511:  BSF    0A.4
1512:  BTFSC  27.7
1513:  BSF    0B.7
1514:  MOVF   7A,W
1515:  BSF    03.6
1516:  MOVWF  20
1517:  MOVF   79,W
1518:  MOVWF  1F
1519:  MOVF   78,W
151A:  MOVWF  1E
151B:  MOVF   77,W
151C:  MOVWF  1D
151D:  BCF    03.6
151E:  CLRF   27
151F:  BTFSC  0B.7
1520:  BSF    27.7
1521:  BCF    0B.7
1522:  BSF    03.6
1523:  MOVF   20,W
1524:  BSF    03.5
1525:  MOVWF  1C
1526:  BCF    03.5
1527:  MOVF   1F,W
1528:  BSF    03.5
1529:  MOVWF  1B
152A:  BCF    03.5
152B:  MOVF   1E,W
152C:  BSF    03.5
152D:  MOVWF  1A
152E:  BCF    03.5
152F:  MOVF   1D,W
1530:  BSF    03.5
1531:  MOVWF  19
1532:  CLRF   20
1533:  CLRF   1F
1534:  MOVLW  48
1535:  MOVWF  1E
1536:  MOVLW  85
1537:  MOVWF  1D
1538:  BCF    0A.4
1539:  BCF    03.5
153A:  BCF    03.6
153B:  CALL   539
153C:  BSF    0A.4
153D:  BTFSC  27.7
153E:  BSF    0B.7
153F:  MOVF   7A,W
1540:  BSF    03.6
1541:  MOVWF  20
1542:  MOVF   79,W
1543:  MOVWF  1F
1544:  MOVF   78,W
1545:  MOVWF  1E
1546:  MOVF   77,W
1547:  MOVWF  1D
1548:  BCF    03.6
1549:  CLRF   27
154A:  BTFSC  0B.7
154B:  BSF    27.7
154C:  BCF    0B.7
154D:  BSF    03.6
154E:  MOVF   20,W
154F:  MOVWF  6C
1550:  MOVF   1F,W
1551:  MOVWF  6B
1552:  MOVF   1E,W
1553:  MOVWF  6A
1554:  MOVF   1D,W
1555:  MOVWF  69
1556:  BSF    03.5
1557:  CLRF   13
1558:  CLRF   12
1559:  CLRF   11
155A:  MOVLW  89
155B:  MOVWF  10
155C:  BCF    0A.4
155D:  BSF    0A.3
155E:  BCF    03.5
155F:  BCF    03.6
1560:  CALL   000
1561:  BSF    0A.4
1562:  BCF    0A.3
1563:  BTFSC  27.7
1564:  BSF    0B.7
1565:  MOVF   7A,W
1566:  MOVWF  42
1567:  MOVF   79,W
1568:  MOVWF  41
1569:  MOVF   78,W
156A:  MOVWF  40
156B:  MOVF   77,W
156C:  MOVWF  3F
....................           
....................          if(!btST) 
156D:  BTFSC  45.1
156E:  GOTO   57A
....................             sendINT('t', iAn, SEP); 
156F:  MOVLW  74
1570:  BSF    03.6
1571:  MOVWF  1D
1572:  BCF    03.6
1573:  MOVF   43,W
1574:  BSF    03.6
1575:  MOVWF  1E
1576:  MOVLW  0A
1577:  MOVWF  1F
1578:  BCF    03.6
1579:  GOTO   29C
157A:  CLRF   27
157B:  BTFSC  0B.7
157C:  BSF    27.7
157D:  BCF    0B.7
....................           
....................          if(t!=y){ //Si t es != al dato anterior refrescamos la temperatura y la enviamos al bluetooth 
157E:  MOVF   42,W
157F:  BSF    03.6
1580:  MOVWF  68
1581:  BCF    03.6
1582:  MOVF   41,W
1583:  BSF    03.6
1584:  MOVWF  67
1585:  BCF    03.6
1586:  MOVF   40,W
1587:  BSF    03.6
1588:  MOVWF  66
1589:  BCF    03.6
158A:  MOVF   3F,W
158B:  BSF    03.6
158C:  MOVWF  65
158D:  BCF    03.6
158E:  MOVF   3E,W
158F:  BSF    03.6
1590:  MOVWF  6C
1591:  BCF    03.6
1592:  MOVF   3D,W
1593:  BSF    03.6
1594:  MOVWF  6B
1595:  BCF    03.6
1596:  MOVF   3C,W
1597:  BSF    03.6
1598:  MOVWF  6A
1599:  BCF    03.6
159A:  MOVF   3B,W
159B:  BSF    03.6
159C:  MOVWF  69
159D:  BCF    0A.4
159E:  BCF    03.6
159F:  CALL   774
15A0:  BSF    0A.4
15A1:  BTFSC  27.7
15A2:  BSF    0B.7
15A3:  BTFSC  03.2
15A4:  GOTO   62D
....................             sprintf(str, "%3.2fC", y); //Convertimos la temperatura float en un char* 
15A5:  CLRF   39
15A6:  MOVLW  2F
15A7:  MOVWF  38
15A8:  MOVLW  02
15A9:  MOVWF  04
15AA:  CLRF   27
15AB:  BTFSC  0B.7
15AC:  BSF    27.7
15AD:  BCF    0B.7
15AE:  MOVF   3E,W
15AF:  BSF    03.6
15B0:  MOVWF  68
15B1:  BCF    03.6
15B2:  MOVF   3D,W
15B3:  BSF    03.6
15B4:  MOVWF  67
15B5:  BCF    03.6
15B6:  MOVF   3C,W
15B7:  BSF    03.6
15B8:  MOVWF  66
15B9:  BCF    03.6
15BA:  MOVF   3B,W
15BB:  BSF    03.6
15BC:  MOVWF  65
15BD:  MOVLW  02
15BE:  MOVWF  69
15BF:  BCF    0A.4
15C0:  BCF    03.6
15C1:  CALL   639
15C2:  BSF    0A.4
15C3:  BTFSC  27.7
15C4:  BSF    0B.7
15C5:  CLRF   27
15C6:  BTFSC  0B.7
15C7:  BSF    27.7
15C8:  BCF    0B.7
15C9:  MOVLW  43
15CA:  BSF    03.5
15CB:  BSF    03.6
15CC:  MOVWF  19
15CD:  BCF    0A.4
15CE:  BCF    03.5
15CF:  BCF    03.6
15D0:  CALL   628
15D1:  BSF    0A.4
15D2:  BTFSC  27.7
15D3:  BSF    0B.7
15D4:  CLRF   27
15D5:  BTFSC  0B.7
15D6:  BSF    27.7
15D7:  BCF    0B.7
....................             glcd_text57(12*6, 10, str, 1, OFF); //borramos del lcd la temperatura anterior 
15D8:  MOVLW  48
15D9:  BSF    03.6
15DA:  MOVWF  67
15DB:  MOVLW  0A
15DC:  MOVWF  68
15DD:  CLRF   6A
15DE:  MOVLW  2F
15DF:  MOVWF  69
15E0:  MOVLW  01
15E1:  MOVWF  6B
15E2:  CLRF   6C
15E3:  BCF    0A.4
15E4:  BCF    03.6
15E5:  CALL   417
15E6:  BSF    0A.4
15E7:  BTFSC  27.7
15E8:  BSF    0B.7
....................             sprintf(str, "%3.2fC", t); //Convertimos la temperatura float en un char* 
15E9:  CLRF   39
15EA:  MOVLW  2F
15EB:  MOVWF  38
15EC:  MOVLW  02
15ED:  MOVWF  04
15EE:  CLRF   27
15EF:  BTFSC  0B.7
15F0:  BSF    27.7
15F1:  BCF    0B.7
15F2:  MOVF   42,W
15F3:  BSF    03.6
15F4:  MOVWF  68
15F5:  BCF    03.6
15F6:  MOVF   41,W
15F7:  BSF    03.6
15F8:  MOVWF  67
15F9:  BCF    03.6
15FA:  MOVF   40,W
15FB:  BSF    03.6
15FC:  MOVWF  66
15FD:  BCF    03.6
15FE:  MOVF   3F,W
15FF:  BSF    03.6
1600:  MOVWF  65
1601:  MOVLW  02
1602:  MOVWF  69
1603:  BCF    0A.4
1604:  BCF    03.6
1605:  CALL   639
1606:  BSF    0A.4
1607:  BTFSC  27.7
1608:  BSF    0B.7
1609:  CLRF   27
160A:  BTFSC  0B.7
160B:  BSF    27.7
160C:  BCF    0B.7
160D:  MOVLW  43
160E:  BSF    03.5
160F:  BSF    03.6
1610:  MOVWF  19
1611:  BCF    0A.4
1612:  BCF    03.5
1613:  BCF    03.6
1614:  CALL   628
1615:  BSF    0A.4
1616:  BTFSC  27.7
1617:  BSF    0B.7
1618:  CLRF   27
1619:  BTFSC  0B.7
161A:  BSF    27.7
161B:  BCF    0B.7
....................             glcd_text57(12*6, 10, str, 1, ON); //Escribimos la temperatura. 
161C:  MOVLW  48
161D:  BSF    03.6
161E:  MOVWF  67
161F:  MOVLW  0A
1620:  MOVWF  68
1621:  CLRF   6A
1622:  MOVLW  2F
1623:  MOVWF  69
1624:  MOVLW  01
1625:  MOVWF  6B
1626:  MOVWF  6C
1627:  BCF    0A.4
1628:  BCF    03.6
1629:  CALL   417
162A:  BSF    0A.4
162B:  BTFSC  27.7
162C:  BSF    0B.7
162D:  CLRF   27
162E:  BTFSC  0B.7
162F:  BSF    27.7
1630:  BCF    0B.7
....................          } 
....................          if(t<=40 && t>=35) 
1631:  MOVF   42,W
1632:  BSF    03.6
1633:  MOVWF  68
1634:  BCF    03.6
1635:  MOVF   41,W
1636:  BSF    03.6
1637:  MOVWF  67
1638:  BCF    03.6
1639:  MOVF   40,W
163A:  BSF    03.6
163B:  MOVWF  66
163C:  BCF    03.6
163D:  MOVF   3F,W
163E:  BSF    03.6
163F:  MOVWF  65
1640:  CLRF   6C
1641:  CLRF   6B
1642:  MOVLW  20
1643:  MOVWF  6A
1644:  MOVLW  84
1645:  MOVWF  69
1646:  BCF    0A.4
1647:  BCF    03.6
1648:  CALL   774
1649:  BSF    0A.4
164A:  BTFSC  27.7
164B:  BSF    0B.7
164C:  BTFSC  03.0
164D:  GOTO   650
164E:  BTFSS  03.2
164F:  GOTO   675
1650:  CLRF   27
1651:  BTFSC  0B.7
1652:  BSF    27.7
1653:  BCF    0B.7
1654:  BSF    03.6
1655:  CLRF   68
1656:  CLRF   67
1657:  MOVLW  0C
1658:  MOVWF  66
1659:  MOVLW  84
165A:  MOVWF  65
165B:  BCF    03.6
165C:  MOVF   42,W
165D:  BSF    03.6
165E:  MOVWF  6C
165F:  BCF    03.6
1660:  MOVF   41,W
1661:  BSF    03.6
1662:  MOVWF  6B
1663:  BCF    03.6
1664:  MOVF   40,W
1665:  BSF    03.6
1666:  MOVWF  6A
1667:  BCF    03.6
1668:  MOVF   3F,W
1669:  BSF    03.6
166A:  MOVWF  69
166B:  BCF    0A.4
166C:  BCF    03.6
166D:  CALL   774
166E:  BSF    0A.4
166F:  BTFSC  27.7
1670:  BSF    0B.7
1671:  BTFSC  03.0
1672:  GOTO   674
1673:  BTFSC  03.2
....................             disable_interrupts(INT_TIMER0); 
1674:  BCF    0B.5
1675:  CLRF   27
1676:  BTFSC  0B.7
1677:  BSF    27.7
1678:  BCF    0B.7
....................          if(t>40 || t<35) 
1679:  BSF    03.6
167A:  CLRF   68
167B:  CLRF   67
167C:  MOVLW  20
167D:  MOVWF  66
167E:  MOVLW  84
167F:  MOVWF  65
1680:  BCF    03.6
1681:  MOVF   42,W
1682:  BSF    03.6
1683:  MOVWF  6C
1684:  BCF    03.6
1685:  MOVF   41,W
1686:  BSF    03.6
1687:  MOVWF  6B
1688:  BCF    03.6
1689:  MOVF   40,W
168A:  BSF    03.6
168B:  MOVWF  6A
168C:  BCF    03.6
168D:  MOVF   3F,W
168E:  BSF    03.6
168F:  MOVWF  69
1690:  BCF    0A.4
1691:  BCF    03.6
1692:  CALL   774
1693:  BSF    0A.4
1694:  BTFSC  27.7
1695:  BSF    0B.7
1696:  BTFSC  03.0
1697:  GOTO   6B8
1698:  CLRF   27
1699:  BTFSC  0B.7
169A:  BSF    27.7
169B:  BCF    0B.7
169C:  MOVF   42,W
169D:  BSF    03.6
169E:  MOVWF  68
169F:  BCF    03.6
16A0:  MOVF   41,W
16A1:  BSF    03.6
16A2:  MOVWF  67
16A3:  BCF    03.6
16A4:  MOVF   40,W
16A5:  BSF    03.6
16A6:  MOVWF  66
16A7:  BCF    03.6
16A8:  MOVF   3F,W
16A9:  BSF    03.6
16AA:  MOVWF  65
16AB:  CLRF   6C
16AC:  CLRF   6B
16AD:  MOVLW  0C
16AE:  MOVWF  6A
16AF:  MOVLW  84
16B0:  MOVWF  69
16B1:  BCF    0A.4
16B2:  BCF    03.6
16B3:  CALL   774
16B4:  BSF    0A.4
16B5:  BTFSC  27.7
16B6:  BSF    0B.7
16B7:  BTFSC  03.0
....................             enable_interrupts(INT_TIMER0); 
16B8:  BSF    0B.5
16B9:  CLRF   27
16BA:  BTFSC  0B.7
16BB:  BSF    27.7
16BC:  BCF    0B.7
....................          if(t<=50 && t>=28){ //Si t es menor o igual a 50 la agregamos al grafico 
16BD:  MOVF   42,W
16BE:  BSF    03.6
16BF:  MOVWF  68
16C0:  BCF    03.6
16C1:  MOVF   41,W
16C2:  BSF    03.6
16C3:  MOVWF  67
16C4:  BCF    03.6
16C5:  MOVF   40,W
16C6:  BSF    03.6
16C7:  MOVWF  66
16C8:  BCF    03.6
16C9:  MOVF   3F,W
16CA:  BSF    03.6
16CB:  MOVWF  65
16CC:  CLRF   6C
16CD:  CLRF   6B
16CE:  MOVLW  48
16CF:  MOVWF  6A
16D0:  MOVLW  84
16D1:  MOVWF  69
16D2:  BCF    0A.4
16D3:  BCF    03.6
16D4:  CALL   774
16D5:  BSF    0A.4
16D6:  BTFSC  27.7
16D7:  BSF    0B.7
16D8:  BTFSC  03.0
16D9:  GOTO   6DC
16DA:  BTFSS  03.2
16DB:  GOTO   75C
16DC:  CLRF   27
16DD:  BTFSC  0B.7
16DE:  BSF    27.7
16DF:  BCF    0B.7
16E0:  BSF    03.6
16E1:  CLRF   68
16E2:  CLRF   67
16E3:  MOVLW  60
16E4:  MOVWF  66
16E5:  MOVLW  83
16E6:  MOVWF  65
16E7:  BCF    03.6
16E8:  MOVF   42,W
16E9:  BSF    03.6
16EA:  MOVWF  6C
16EB:  BCF    03.6
16EC:  MOVF   41,W
16ED:  BSF    03.6
16EE:  MOVWF  6B
16EF:  BCF    03.6
16F0:  MOVF   40,W
16F1:  BSF    03.6
16F2:  MOVWF  6A
16F3:  BCF    03.6
16F4:  MOVF   3F,W
16F5:  BSF    03.6
16F6:  MOVWF  69
16F7:  BCF    0A.4
16F8:  BCF    03.6
16F9:  CALL   774
16FA:  BSF    0A.4
16FB:  BTFSC  27.7
16FC:  BSF    0B.7
16FD:  BTFSC  03.0
16FE:  GOTO   701
16FF:  BTFSS  03.2
1700:  GOTO   75C
1701:  CLRF   27
1702:  BTFSC  0B.7
1703:  BSF    27.7
1704:  BCF    0B.7
....................             nuevaLinea(t); //Dibujamos la nueva linea en el grafico. 
1705:  MOVF   42,W
1706:  BSF    03.6
1707:  MOVWF  68
1708:  BCF    03.6
1709:  MOVF   41,W
170A:  BSF    03.6
170B:  MOVWF  67
170C:  BCF    03.6
170D:  MOVF   40,W
170E:  BSF    03.6
170F:  MOVWF  66
1710:  BCF    03.6
1711:  MOVF   3F,W
1712:  BSF    03.6
1713:  MOVWF  65
1714:  BCF    0A.4
1715:  BSF    0A.3
1716:  BCF    03.6
1717:  CALL   30C
1718:  BSF    0A.4
1719:  BCF    0A.3
171A:  BTFSC  27.7
171B:  BSF    0B.7
....................             glcd_text57(3, 0, (char*)"T>50", 1, OFF); //ocultamos la notificacion de t>50 
171C:  MOVLW  54
171D:  BSF    03.6
171E:  MOVWF  10
171F:  MOVLW  3E
1720:  MOVWF  11
1721:  MOVLW  35
1722:  MOVWF  12
1723:  MOVLW  30
1724:  MOVWF  13
1725:  CLRF   14
1726:  BCF    03.6
1727:  CLRF   27
1728:  BTFSC  0B.7
1729:  BSF    27.7
172A:  BCF    0B.7
172B:  MOVLW  03
172C:  BSF    03.6
172D:  MOVWF  67
172E:  CLRF   68
172F:  MOVLW  01
1730:  MOVWF  6A
1731:  MOVLW  10
1732:  MOVWF  69
1733:  MOVLW  01
1734:  MOVWF  6B
1735:  CLRF   6C
1736:  BCF    0A.4
1737:  BCF    03.6
1738:  CALL   417
1739:  BSF    0A.4
173A:  BTFSC  27.7
173B:  BSF    0B.7
....................             glcd_text57(3, 0, (char*)"T<28", 1, OFF); //ocultamos la notificacion de t>50 
173C:  MOVLW  54
173D:  BSF    03.6
173E:  MOVWF  10
173F:  MOVLW  3C
1740:  MOVWF  11
1741:  MOVLW  32
1742:  MOVWF  12
1743:  MOVLW  38
1744:  MOVWF  13
1745:  CLRF   14
1746:  BCF    03.6
1747:  CLRF   27
1748:  BTFSC  0B.7
1749:  BSF    27.7
174A:  BCF    0B.7
174B:  MOVLW  03
174C:  BSF    03.6
174D:  MOVWF  67
174E:  CLRF   68
174F:  MOVLW  01
1750:  MOVWF  6A
1751:  MOVLW  10
1752:  MOVWF  69
1753:  MOVLW  01
1754:  MOVWF  6B
1755:  CLRF   6C
1756:  BCF    0A.4
1757:  BCF    03.6
1758:  CALL   417
1759:  BSF    0A.4
175A:  BTFSC  27.7
175B:  BSF    0B.7
175C:  CLRF   27
175D:  BTFSC  0B.7
175E:  BSF    27.7
175F:  BCF    0B.7
....................          } 
....................          if(t>50){ 
1760:  BSF    03.6
1761:  CLRF   68
1762:  CLRF   67
1763:  MOVLW  48
1764:  MOVWF  66
1765:  MOVLW  84
1766:  MOVWF  65
1767:  BCF    03.6
1768:  MOVF   42,W
1769:  BSF    03.6
176A:  MOVWF  6C
176B:  BCF    03.6
176C:  MOVF   41,W
176D:  BSF    03.6
176E:  MOVWF  6B
176F:  BCF    03.6
1770:  MOVF   40,W
1771:  BSF    03.6
1772:  MOVWF  6A
1773:  BCF    03.6
1774:  MOVF   3F,W
1775:  BSF    03.6
1776:  MOVWF  69
1777:  BCF    0A.4
1778:  BCF    03.6
1779:  CALL   774
177A:  BSF    0A.4
177B:  BTFSC  27.7
177C:  BSF    0B.7
177D:  BTFSS  03.0
177E:  GOTO   7A7
....................             glcd_text57(3, 0, (char*)"T>50", 1, ON); //Esto significa que no graficamos temperaturas superiores a 50 
177F:  MOVLW  54
1780:  BSF    03.6
1781:  MOVWF  10
1782:  MOVLW  3E
1783:  MOVWF  11
1784:  MOVLW  35
1785:  MOVWF  12
1786:  MOVLW  30
1787:  MOVWF  13
1788:  CLRF   14
1789:  BCF    03.6
178A:  CLRF   27
178B:  BTFSC  0B.7
178C:  BSF    27.7
178D:  BCF    0B.7
178E:  MOVLW  03
178F:  BSF    03.6
1790:  MOVWF  67
1791:  CLRF   68
1792:  MOVLW  01
1793:  MOVWF  6A
1794:  MOVLW  10
1795:  MOVWF  69
1796:  MOVLW  01
1797:  MOVWF  6B
1798:  MOVWF  6C
1799:  BCF    0A.4
179A:  BCF    03.6
179B:  CALL   417
179C:  BSF    0A.4
179D:  BTFSC  27.7
179E:  BSF    0B.7
....................             y=t; //igualamos el dato anterior al valor de temperatura para no refrescar otra vez el valor de la temperatura 
179F:  MOVF   42,W
17A0:  MOVWF  3E
17A1:  MOVF   41,W
17A2:  MOVWF  3D
17A3:  MOVF   40,W
17A4:  MOVWF  3C
17A5:  MOVF   3F,W
17A6:  MOVWF  3B
17A7:  CLRF   27
17A8:  BTFSC  0B.7
17A9:  BSF    27.7
17AA:  BCF    0B.7
....................          } 
....................          if(t<28){ 
17AB:  MOVF   42,W
17AC:  BSF    03.6
17AD:  MOVWF  68
17AE:  BCF    03.6
17AF:  MOVF   41,W
17B0:  BSF    03.6
17B1:  MOVWF  67
17B2:  BCF    03.6
17B3:  MOVF   40,W
17B4:  BSF    03.6
17B5:  MOVWF  66
17B6:  BCF    03.6
17B7:  MOVF   3F,W
17B8:  BSF    03.6
17B9:  MOVWF  65
17BA:  CLRF   6C
17BB:  CLRF   6B
17BC:  MOVLW  60
17BD:  MOVWF  6A
17BE:  MOVLW  83
17BF:  MOVWF  69
17C0:  BCF    0A.4
17C1:  BCF    03.6
17C2:  CALL   774
17C3:  BSF    0A.4
17C4:  BTFSC  27.7
17C5:  BSF    0B.7
17C6:  BTFSS  03.0
17C7:  GOTO   7F0
....................             glcd_text57(3, 0, (char*)"T<28", 1, ON); //Esto significa que no graficamos temperaturas superiores a 50 
17C8:  MOVLW  54
17C9:  BSF    03.6
17CA:  MOVWF  10
17CB:  MOVLW  3C
17CC:  MOVWF  11
17CD:  MOVLW  32
17CE:  MOVWF  12
17CF:  MOVLW  38
17D0:  MOVWF  13
17D1:  CLRF   14
17D2:  BCF    03.6
17D3:  CLRF   27
17D4:  BTFSC  0B.7
17D5:  BSF    27.7
17D6:  BCF    0B.7
17D7:  MOVLW  03
17D8:  BSF    03.6
17D9:  MOVWF  67
17DA:  CLRF   68
17DB:  MOVLW  01
17DC:  MOVWF  6A
17DD:  MOVLW  10
17DE:  MOVWF  69
17DF:  MOVLW  01
17E0:  MOVWF  6B
17E1:  MOVWF  6C
17E2:  BCF    0A.4
17E3:  BCF    03.6
17E4:  CALL   417
17E5:  BSF    0A.4
17E6:  BTFSC  27.7
17E7:  BSF    0B.7
....................             y=t; //igualamos el dato anterior al valor de temperatura para no refrescar otra vez el valor de la temperatura 
17E8:  MOVF   42,W
17E9:  MOVWF  3E
17EA:  MOVF   41,W
17EB:  MOVWF  3D
17EC:  MOVF   40,W
17ED:  MOVWF  3C
17EE:  MOVF   3F,W
17EF:  MOVWF  3B
17F0:  CLRF   27
17F1:  BTFSC  0B.7
17F2:  BSF    27.7
17F3:  BCF    0B.7
....................          } 
....................          delay_ms(250); 
17F4:  MOVLW  FA
17F5:  BSF    03.6
17F6:  MOVWF  3D
17F7:  BCF    0A.4
17F8:  BCF    03.6
17F9:  CALL   26D
17FA:  BSF    0A.4
17FB:  BTFSC  27.7
17FC:  BSF    0B.7
....................       } 
17FD:  GOTO   4D3
....................    } 
.................... } 
17FE:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
