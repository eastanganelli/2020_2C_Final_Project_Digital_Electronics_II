CCS PCM C Compiler, Version 5.076, 56587               18-Nov-20 02:36

               Filename:   D:\Ezequiel\My eBooks\Favaloro\ED\II\GIT_TP_FINAL\tp_final_edi2\Codigo\main.lst

               ROM used:   6357 words (78%)
                           Largest free fragment is 942
               RAM used:   143 (39%) at main() level
                           244 (66%) worst case
               Stack used: 9 locations (4 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.3
0018:  GOTO   01B
0019:  BTFSC  0B.0
001A:  GOTO   03C
001B:  MOVLW  8C
001C:  MOVWF  04
001D:  BTFSS  00.5
001E:  GOTO   021
001F:  BTFSC  0C.5
0020:  GOTO   03F
0021:  MOVLW  8C
0022:  MOVWF  04
0023:  BTFSS  00.0
0024:  GOTO   027
0025:  BTFSC  0C.0
0026:  GOTO   042
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   045
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   20,W
0036:  MOVWF  0A
0037:  SWAPF  21,W
0038:  MOVWF  03
0039:  SWAPF  7F,F
003A:  SWAPF  7F,W
003B:  RETFIE
003C:  BCF    0A.3
003D:  BSF    0A.4
003E:  GOTO   000
003F:  BSF    0A.3
0040:  BCF    0A.4
0041:  GOTO   52D
0042:  BCF    0A.3
0043:  BCF    0A.4
0044:  GOTO   299
0045:  BCF    0A.3
0046:  BCF    0A.4
0047:  GOTO   282
.................... #include <main.h> 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0048:  BCF    0A.0
0049:  BCF    0A.1
004A:  BCF    0A.2
004B:  ADDLW  4F
004C:  BTFSC  03.0
004D:  INCF   0A,F
004E:  MOVWF  02
004F:  RETLW  00
0050:  RETLW  00
0051:  RETLW  00
0052:  RETLW  00
0053:  RETLW  00
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  5F
0057:  RETLW  00
0058:  RETLW  00
0059:  RETLW  00
005A:  RETLW  03
005B:  RETLW  00
005C:  RETLW  03
005D:  RETLW  00
005E:  RETLW  14
005F:  RETLW  3E
0060:  RETLW  14
0061:  RETLW  3E
0062:  RETLW  14
0063:  RETLW  24
0064:  RETLW  2A
0065:  RETLW  7F
0066:  RETLW  2A
0067:  RETLW  12
0068:  RETLW  43
0069:  RETLW  33
006A:  RETLW  08
006B:  RETLW  66
006C:  RETLW  61
006D:  RETLW  36
006E:  RETLW  49
006F:  RETLW  55
0070:  RETLW  22
0071:  RETLW  50
0072:  RETLW  00
0073:  RETLW  05
0074:  RETLW  03
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  1C
0079:  RETLW  22
007A:  RETLW  41
007B:  RETLW  00
007C:  RETLW  00
007D:  RETLW  41
007E:  RETLW  22
007F:  RETLW  1C
0080:  RETLW  00
0081:  RETLW  14
0082:  RETLW  08
0083:  RETLW  3E
0084:  RETLW  08
0085:  RETLW  14
0086:  RETLW  08
0087:  RETLW  08
0088:  RETLW  3E
0089:  RETLW  08
008A:  RETLW  08
008B:  RETLW  00
008C:  RETLW  50
008D:  RETLW  30
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  08
0091:  RETLW  08
0092:  RETLW  08
0093:  RETLW  08
0094:  RETLW  08
0095:  RETLW  00
0096:  RETLW  60
0097:  RETLW  60
0098:  RETLW  00
0099:  RETLW  00
009A:  RETLW  20
009B:  RETLW  10
009C:  RETLW  08
009D:  RETLW  04
009E:  RETLW  02
009F:  RETLW  3E
00A0:  RETLW  51
00A1:  RETLW  49
00A2:  RETLW  45
00A3:  RETLW  3E
00A4:  RETLW  00
00A5:  RETLW  04
00A6:  RETLW  02
00A7:  RETLW  7F
00A8:  RETLW  00
00A9:  RETLW  42
00AA:  RETLW  61
00AB:  RETLW  51
00AC:  RETLW  49
00AD:  RETLW  46
00AE:  RETLW  22
00AF:  RETLW  41
00B0:  RETLW  49
00B1:  RETLW  49
00B2:  RETLW  36
00B3:  RETLW  18
00B4:  RETLW  14
00B5:  RETLW  12
00B6:  RETLW  7F
00B7:  RETLW  10
00B8:  RETLW  27
00B9:  RETLW  45
00BA:  RETLW  45
00BB:  RETLW  45
00BC:  RETLW  39
00BD:  RETLW  3E
00BE:  RETLW  49
00BF:  RETLW  49
00C0:  RETLW  49
00C1:  RETLW  32
00C2:  RETLW  01
00C3:  RETLW  01
00C4:  RETLW  71
00C5:  RETLW  09
00C6:  RETLW  07
00C7:  RETLW  36
00C8:  RETLW  49
00C9:  RETLW  49
00CA:  RETLW  49
00CB:  RETLW  36
00CC:  RETLW  26
00CD:  RETLW  49
00CE:  RETLW  49
00CF:  RETLW  49
00D0:  RETLW  3E
00D1:  RETLW  00
00D2:  RETLW  36
00D3:  RETLW  36
00D4:  RETLW  00
00D5:  RETLW  00
00D6:  RETLW  00
00D7:  RETLW  56
00D8:  RETLW  36
00D9:  RETLW  00
00DA:  RETLW  00
00DB:  RETLW  08
00DC:  RETLW  14
00DD:  RETLW  22
00DE:  RETLW  41
00DF:  RETLW  00
00E0:  RETLW  14
00E1:  RETLW  14
00E2:  RETLW  14
00E3:  RETLW  14
00E4:  RETLW  14
00E5:  RETLW  00
00E6:  RETLW  41
00E7:  RETLW  22
00E8:  RETLW  14
00E9:  RETLW  08
00EA:  RETLW  02
00EB:  RETLW  01
00EC:  RETLW  51
00ED:  RETLW  09
00EE:  RETLW  06
00EF:  RETLW  3E
00F0:  RETLW  41
00F1:  RETLW  59
00F2:  RETLW  55
00F3:  RETLW  5E
00F4:  RETLW  7E
00F5:  RETLW  09
00F6:  RETLW  09
00F7:  RETLW  09
00F8:  RETLW  7E
00F9:  RETLW  7F
00FA:  RETLW  49
00FB:  RETLW  49
00FC:  RETLW  49
00FD:  RETLW  36
00FE:  RETLW  3E
00FF:  RETLW  41
0100:  RETLW  41
0101:  RETLW  41
0102:  RETLW  22
0103:  RETLW  7F
0104:  RETLW  41
0105:  RETLW  41
0106:  RETLW  41
0107:  RETLW  3E
0108:  RETLW  7F
0109:  RETLW  49
010A:  RETLW  49
010B:  RETLW  49
010C:  RETLW  41
010D:  RETLW  7F
010E:  RETLW  09
010F:  RETLW  09
0110:  RETLW  09
0111:  RETLW  01
0112:  RETLW  3E
0113:  RETLW  41
0114:  RETLW  41
0115:  RETLW  49
0116:  RETLW  3A
0117:  RETLW  7F
0118:  RETLW  08
0119:  RETLW  08
011A:  RETLW  08
011B:  RETLW  7F
011C:  RETLW  00
011D:  RETLW  41
011E:  RETLW  7F
011F:  RETLW  41
0120:  RETLW  00
0121:  RETLW  30
0122:  RETLW  40
0123:  RETLW  40
0124:  RETLW  40
0125:  RETLW  3F
0126:  RETLW  7F
0127:  RETLW  08
0128:  RETLW  14
0129:  RETLW  22
012A:  RETLW  41
012B:  RETLW  7F
012C:  RETLW  40
012D:  RETLW  40
012E:  RETLW  40
012F:  RETLW  40
0130:  RETLW  7F
0131:  RETLW  02
0132:  RETLW  0C
0133:  RETLW  02
0134:  RETLW  7F
0135:  RETLW  7F
0136:  RETLW  02
0137:  RETLW  04
0138:  RETLW  08
0139:  RETLW  7F
013A:  RETLW  3E
013B:  RETLW  41
013C:  RETLW  41
013D:  RETLW  41
013E:  RETLW  3E
013F:  RETLW  7F
0140:  RETLW  09
0141:  RETLW  09
0142:  RETLW  09
0143:  RETLW  06
0144:  RETLW  1E
0145:  RETLW  21
0146:  RETLW  21
0147:  RETLW  21
0148:  RETLW  5E
0149:  RETLW  7F
014A:  RETLW  09
014B:  RETLW  09
014C:  RETLW  09
014D:  RETLW  76
014E:  BSF    0A.0
014F:  BCF    0A.1
0150:  BCF    0A.2
0151:  ADDLW  55
0152:  BTFSC  03.0
0153:  INCF   0A,F
0154:  MOVWF  02
0155:  RETLW  26
0156:  RETLW  49
0157:  RETLW  49
0158:  RETLW  49
0159:  RETLW  32
015A:  RETLW  01
015B:  RETLW  01
015C:  RETLW  7F
015D:  RETLW  01
015E:  RETLW  01
015F:  RETLW  3F
0160:  RETLW  40
0161:  RETLW  40
0162:  RETLW  40
0163:  RETLW  3F
0164:  RETLW  1F
0165:  RETLW  20
0166:  RETLW  40
0167:  RETLW  20
0168:  RETLW  1F
0169:  RETLW  7F
016A:  RETLW  20
016B:  RETLW  10
016C:  RETLW  20
016D:  RETLW  7F
016E:  RETLW  41
016F:  RETLW  22
0170:  RETLW  1C
0171:  RETLW  22
0172:  RETLW  41
0173:  RETLW  07
0174:  RETLW  08
0175:  RETLW  70
0176:  RETLW  08
0177:  RETLW  07
0178:  RETLW  61
0179:  RETLW  51
017A:  RETLW  49
017B:  RETLW  45
017C:  RETLW  43
017D:  RETLW  00
017E:  RETLW  7F
017F:  RETLW  41
0180:  RETLW  00
0181:  RETLW  00
0182:  RETLW  02
0183:  RETLW  04
0184:  RETLW  08
0185:  RETLW  10
0186:  RETLW  20
0187:  RETLW  00
0188:  RETLW  00
0189:  RETLW  41
018A:  RETLW  7F
018B:  RETLW  00
018C:  RETLW  04
018D:  RETLW  02
018E:  RETLW  01
018F:  RETLW  02
0190:  RETLW  04
0191:  RETLW  40
0192:  RETLW  40
0193:  RETLW  40
0194:  RETLW  40
0195:  RETLW  40
0196:  RETLW  00
0197:  RETLW  01
0198:  RETLW  02
0199:  RETLW  04
019A:  RETLW  00
019B:  RETLW  20
019C:  RETLW  54
019D:  RETLW  54
019E:  RETLW  54
019F:  RETLW  78
01A0:  RETLW  7F
01A1:  RETLW  44
01A2:  RETLW  44
01A3:  RETLW  44
01A4:  RETLW  38
01A5:  RETLW  38
01A6:  RETLW  44
01A7:  RETLW  44
01A8:  RETLW  44
01A9:  RETLW  44
01AA:  RETLW  38
01AB:  RETLW  44
01AC:  RETLW  44
01AD:  RETLW  44
01AE:  RETLW  7F
01AF:  RETLW  38
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  54
01B3:  RETLW  18
01B4:  RETLW  04
01B5:  RETLW  04
01B6:  RETLW  7E
01B7:  RETLW  05
01B8:  RETLW  05
01B9:  RETLW  08
01BA:  RETLW  54
01BB:  RETLW  54
01BC:  RETLW  54
01BD:  RETLW  3C
01BE:  RETLW  7F
01BF:  RETLW  08
01C0:  RETLW  04
01C1:  RETLW  04
01C2:  RETLW  78
01C3:  RETLW  00
01C4:  RETLW  44
01C5:  RETLW  7D
01C6:  RETLW  40
01C7:  RETLW  00
01C8:  RETLW  20
01C9:  RETLW  40
01CA:  RETLW  44
01CB:  RETLW  3D
01CC:  RETLW  00
01CD:  RETLW  7F
01CE:  RETLW  10
01CF:  RETLW  28
01D0:  RETLW  44
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  41
01D4:  RETLW  7F
01D5:  RETLW  40
01D6:  RETLW  00
01D7:  RETLW  7C
01D8:  RETLW  04
01D9:  RETLW  78
01DA:  RETLW  04
01DB:  RETLW  78
01DC:  RETLW  7C
01DD:  RETLW  08
01DE:  RETLW  04
01DF:  RETLW  04
01E0:  RETLW  78
01E1:  RETLW  38
01E2:  RETLW  44
01E3:  RETLW  44
01E4:  RETLW  44
01E5:  RETLW  38
01E6:  RETLW  7C
01E7:  RETLW  14
01E8:  RETLW  14
01E9:  RETLW  14
01EA:  RETLW  08
01EB:  RETLW  08
01EC:  RETLW  14
01ED:  RETLW  14
01EE:  RETLW  14
01EF:  RETLW  7C
01F0:  RETLW  00
01F1:  RETLW  7C
01F2:  RETLW  08
01F3:  RETLW  04
01F4:  RETLW  04
01F5:  RETLW  48
01F6:  RETLW  54
01F7:  RETLW  54
01F8:  RETLW  54
01F9:  RETLW  20
01FA:  RETLW  04
01FB:  RETLW  04
01FC:  RETLW  3F
01FD:  RETLW  44
01FE:  RETLW  44
01FF:  RETLW  3C
0200:  RETLW  40
0201:  RETLW  40
0202:  RETLW  20
0203:  RETLW  7C
0204:  RETLW  1C
0205:  RETLW  20
0206:  RETLW  40
0207:  RETLW  20
0208:  RETLW  1C
0209:  RETLW  3C
020A:  RETLW  40
020B:  RETLW  30
020C:  RETLW  40
020D:  RETLW  3C
020E:  RETLW  44
020F:  RETLW  28
0210:  RETLW  10
0211:  RETLW  28
0212:  RETLW  44
0213:  RETLW  0C
0214:  RETLW  50
0215:  RETLW  50
0216:  RETLW  50
0217:  RETLW  3C
0218:  RETLW  44
0219:  RETLW  64
021A:  RETLW  54
021B:  RETLW  4C
021C:  RETLW  44
021D:  RETLW  00
021E:  RETLW  08
021F:  RETLW  36
0220:  RETLW  41
0221:  RETLW  41
0222:  RETLW  00
0223:  RETLW  00
0224:  RETLW  7F
0225:  RETLW  00
0226:  RETLW  00
0227:  RETLW  41
0228:  RETLW  41
0229:  RETLW  36
022A:  RETLW  08
022B:  RETLW  00
022C:  RETLW  02
022D:  RETLW  01
022E:  RETLW  02
022F:  RETLW  04
0230:  RETLW  02
0231:  BCF    0A.0
0232:  BSF    0A.1
0233:  BCF    0A.2
0234:  ADDWF  02,F
0235:  RETLW  43
0236:  RETLW  61
0237:  RETLW  70
0238:  RETLW  74
0239:  RETLW  75
023A:  RETLW  72
023B:  RETLW  61
023C:  RETLW  6E
023D:  RETLW  64
023E:  RETLW  6F
023F:  RETLW  00
0240:  BCF    0A.0
0241:  BSF    0A.1
0242:  BCF    0A.2
0243:  ADDWF  02,F
0244:  RETLW  4C
0245:  RETLW  69
0246:  RETLW  6D
0247:  RETLW  70
0248:  RETLW  69
0249:  RETLW  61
024A:  RETLW  6E
024B:  RETLW  64
024C:  RETLW  6F
024D:  RETLW  00
024E:  BCF    0A.0
024F:  BSF    0A.1
0250:  BCF    0A.2
0251:  ADDWF  02,F
0252:  RETLW  47
0253:  RETLW  75
0254:  RETLW  61
0255:  RETLW  72
0256:  RETLW  64
0257:  RETLW  61
0258:  RETLW  6E
0259:  RETLW  64
025A:  RETLW  6F
025B:  RETLW  00
025C:  BCF    0A.0
025D:  BSF    0A.1
025E:  BCF    0A.2
025F:  ADDWF  02,F
0260:  RETLW  54
0261:  RETLW  65
0262:  RETLW  6D
0263:  RETLW  70
0264:  RETLW  65
0265:  RETLW  72
0266:  RETLW  61
0267:  RETLW  74
0268:  RETLW  75
0269:  RETLW  72
026A:  RETLW  61
026B:  RETLW  3A
026C:  RETLW  00
*
02CB:  CLRF   77
02CC:  CLRF   78
02CD:  BSF    03.5
02CE:  BSF    03.6
02CF:  MOVF   19,W
02D0:  BCF    03.0
02D1:  BTFSC  1A.0
02D2:  ADDWF  77,F
02D3:  RRF    77,F
02D4:  RRF    78,F
02D5:  BTFSC  1A.1
02D6:  ADDWF  77,F
02D7:  RRF    77,F
02D8:  RRF    78,F
02D9:  BTFSC  1A.2
02DA:  ADDWF  77,F
02DB:  RRF    77,F
02DC:  RRF    78,F
02DD:  BTFSC  1A.3
02DE:  ADDWF  77,F
02DF:  RRF    77,F
02E0:  RRF    78,F
02E1:  BTFSC  1A.4
02E2:  ADDWF  77,F
02E3:  RRF    77,F
02E4:  RRF    78,F
02E5:  BTFSC  1A.5
02E6:  ADDWF  77,F
02E7:  RRF    77,F
02E8:  RRF    78,F
02E9:  BTFSC  1A.6
02EA:  ADDWF  77,F
02EB:  RRF    77,F
02EC:  RRF    78,F
02ED:  BTFSC  1A.7
02EE:  ADDWF  77,F
02EF:  RRF    77,F
02F0:  RRF    78,F
02F1:  BCF    03.5
02F2:  BCF    03.6
02F3:  RETURN
*
0539:  BSF    03.5
053A:  BSF    03.6
053B:  MOVF   19,W
053C:  BTFSC  03.2
053D:  GOTO   5AB
053E:  MOVWF  21
053F:  MOVF   1D,W
0540:  BTFSC  03.2
0541:  GOTO   5AB
0542:  ADDWF  21,F
0543:  BTFSC  03.0
0544:  GOTO   54C
0545:  MOVLW  7F
0546:  SUBWF  21,F
0547:  BTFSS  03.0
0548:  GOTO   5AB
0549:  BTFSC  03.2
054A:  GOTO   5AB
054B:  GOTO   550
054C:  MOVLW  81
054D:  ADDWF  21,F
054E:  BTFSC  03.0
054F:  GOTO   5AB
0550:  MOVF   21,W
0551:  MOVWF  77
0552:  CLRF   78
0553:  CLRF   79
0554:  CLRF   7A
0555:  MOVF   1A,W
0556:  MOVWF  25
0557:  BSF    25.7
0558:  MOVF   1B,W
0559:  MOVWF  24
055A:  MOVF   1C,W
055B:  MOVWF  23
055C:  MOVLW  18
055D:  MOVWF  21
055E:  CLRF   22
055F:  BTFSS  23.0
0560:  GOTO   579
0561:  MOVF   20,W
0562:  ADDWF  7A,F
0563:  BTFSS  03.0
0564:  GOTO   56B
0565:  INCF   79,F
0566:  BTFSS  03.2
0567:  GOTO   56B
0568:  INCF   78,F
0569:  BTFSC  03.2
056A:  BSF    22.7
056B:  MOVF   1F,W
056C:  ADDWF  79,F
056D:  BTFSS  03.0
056E:  GOTO   572
056F:  INCF   78,F
0570:  BTFSC  03.2
0571:  BSF    22.7
0572:  MOVF   1E,W
0573:  MOVWF  1B
0574:  BSF    1B.7
0575:  MOVF   1B,W
0576:  ADDWF  78,F
0577:  BTFSC  03.0
0578:  BSF    22.7
0579:  RLF    22,F
057A:  RRF    78,F
057B:  RRF    79,F
057C:  RRF    7A,F
057D:  RRF    25,F
057E:  RRF    24,F
057F:  RRF    23,F
0580:  BCF    03.0
0581:  DECFSZ 21,F
0582:  GOTO   55E
0583:  MOVLW  01
0584:  ADDWF  77,F
0585:  BTFSC  03.0
0586:  GOTO   5AB
0587:  BTFSC  78.7
0588:  GOTO   590
0589:  RLF    25,F
058A:  RLF    7A,F
058B:  RLF    79,F
058C:  RLF    78,F
058D:  DECF   77,F
058E:  BTFSC  03.2
058F:  GOTO   5AB
0590:  BTFSS  25.7
0591:  GOTO   5A1
0592:  INCF   7A,F
0593:  BTFSS  03.2
0594:  GOTO   5A1
0595:  INCF   79,F
0596:  BTFSS  03.2
0597:  GOTO   5A1
0598:  INCF   78,F
0599:  BTFSS  03.2
059A:  GOTO   5A1
059B:  RRF    78,F
059C:  RRF    79,F
059D:  RRF    7A,F
059E:  INCF   77,F
059F:  BTFSC  03.2
05A0:  GOTO   5AB
05A1:  MOVF   1A,W
05A2:  MOVWF  22
05A3:  MOVF   1E,W
05A4:  XORWF  22,F
05A5:  BTFSS  22.7
05A6:  GOTO   5A9
05A7:  BSF    78.7
05A8:  GOTO   5AF
05A9:  BCF    78.7
05AA:  GOTO   5AF
05AB:  CLRF   77
05AC:  CLRF   78
05AD:  CLRF   79
05AE:  CLRF   7A
05AF:  BCF    03.5
05B0:  BCF    03.6
05B1:  RETURN
05B2:  BSF    03.5
05B3:  BSF    03.6
05B4:  MOVF   19,W
05B5:  SUBLW  B6
05B6:  MOVWF  19
05B7:  CLRF   7A
05B8:  MOVF   1A,W
05B9:  MOVWF  1D
05BA:  BSF    1A.7
05BB:  BCF    03.0
05BC:  RRF    1A,F
05BD:  RRF    1B,F
05BE:  RRF    1C,F
05BF:  RRF    7A,F
05C0:  RRF    79,F
05C1:  RRF    78,F
05C2:  RRF    77,F
05C3:  DECFSZ 19,F
05C4:  GOTO   5BB
05C5:  BTFSS  1D.7
05C6:  GOTO   5D2
05C7:  COMF   77,F
05C8:  COMF   78,F
05C9:  COMF   79,F
05CA:  COMF   7A,F
05CB:  INCF   77,F
05CC:  BTFSC  03.2
05CD:  INCF   78,F
05CE:  BTFSC  03.2
05CF:  INCF   79,F
05D0:  BTFSC  03.2
05D1:  INCF   7A,F
05D2:  BCF    03.5
05D3:  BCF    03.6
05D4:  RETURN
05D5:  BTFSC  03.1
05D6:  GOTO   5DA
05D7:  MOVLW  A1
05D8:  MOVWF  04
05D9:  BSF    03.7
05DA:  CLRF   77
05DB:  CLRF   78
05DC:  CLRF   79
05DD:  CLRF   7A
05DE:  BSF    03.5
05DF:  BSF    03.6
05E0:  CLRF   21
05E1:  CLRF   22
05E2:  CLRF   23
05E3:  CLRF   24
05E4:  MOVF   20,W
05E5:  IORWF  1F,W
05E6:  IORWF  1E,W
05E7:  IORWF  1D,W
05E8:  BTFSC  03.2
05E9:  GOTO   61A
05EA:  MOVLW  20
05EB:  MOVWF  25
05EC:  BCF    03.0
05ED:  RLF    19,F
05EE:  RLF    1A,F
05EF:  RLF    1B,F
05F0:  RLF    1C,F
05F1:  RLF    21,F
05F2:  RLF    22,F
05F3:  RLF    23,F
05F4:  RLF    24,F
05F5:  MOVF   20,W
05F6:  SUBWF  24,W
05F7:  BTFSS  03.2
05F8:  GOTO   603
05F9:  MOVF   1F,W
05FA:  SUBWF  23,W
05FB:  BTFSS  03.2
05FC:  GOTO   603
05FD:  MOVF   1E,W
05FE:  SUBWF  22,W
05FF:  BTFSS  03.2
0600:  GOTO   603
0601:  MOVF   1D,W
0602:  SUBWF  21,W
0603:  BTFSS  03.0
0604:  GOTO   614
0605:  MOVF   1D,W
0606:  SUBWF  21,F
0607:  MOVF   1E,W
0608:  BTFSS  03.0
0609:  INCFSZ 1E,W
060A:  SUBWF  22,F
060B:  MOVF   1F,W
060C:  BTFSS  03.0
060D:  INCFSZ 1F,W
060E:  SUBWF  23,F
060F:  MOVF   20,W
0610:  BTFSS  03.0
0611:  INCFSZ 20,W
0612:  SUBWF  24,F
0613:  BSF    03.0
0614:  RLF    77,F
0615:  RLF    78,F
0616:  RLF    79,F
0617:  RLF    7A,F
0618:  DECFSZ 25,F
0619:  GOTO   5EC
061A:  MOVF   21,W
061B:  MOVWF  00
061C:  INCF   04,F
061D:  MOVF   22,W
061E:  MOVWF  00
061F:  INCF   04,F
0620:  MOVF   23,W
0621:  MOVWF  00
0622:  INCF   04,F
0623:  MOVF   24,W
0624:  MOVWF  00
0625:  BCF    03.5
0626:  BCF    03.6
0627:  RETURN
0628:  MOVF   38,W
0629:  MOVWF  04
062A:  BCF    03.7
062B:  BTFSC  39.0
062C:  BSF    03.7
062D:  BSF    03.5
062E:  BSF    03.6
062F:  MOVF   19,W
0630:  MOVWF  00
0631:  INCF   04,F
0632:  CLRF   00
0633:  BCF    03.5
0634:  BCF    03.6
0635:  INCF   38,F
0636:  BTFSC  03.2
0637:  INCF   39,F
0638:  RETURN
0639:  MOVF   04,W
063A:  BSF    03.5
063B:  BSF    03.6
063C:  MOVWF  10
063D:  BCF    03.5
063E:  MOVF   69,W
063F:  BSF    03.5
0640:  MOVWF  12
0641:  BTFSC  03.2
0642:  GOTO   668
0643:  BCF    03.5
0644:  MOVF   68,W
0645:  BSF    03.5
0646:  MOVWF  1C
0647:  BCF    03.5
0648:  MOVF   67,W
0649:  BSF    03.5
064A:  MOVWF  1B
064B:  BCF    03.5
064C:  MOVF   66,W
064D:  BSF    03.5
064E:  MOVWF  1A
064F:  BCF    03.5
0650:  MOVF   65,W
0651:  BSF    03.5
0652:  MOVWF  19
0653:  CLRF   20
0654:  CLRF   1F
0655:  MOVLW  20
0656:  MOVWF  1E
0657:  MOVLW  82
0658:  MOVWF  1D
0659:  BCF    03.5
065A:  BCF    03.6
065B:  CALL   539
065C:  MOVF   7A,W
065D:  BSF    03.6
065E:  MOVWF  68
065F:  MOVF   79,W
0660:  MOVWF  67
0661:  MOVF   78,W
0662:  MOVWF  66
0663:  MOVF   77,W
0664:  MOVWF  65
0665:  BSF    03.5
0666:  DECFSZ 12,F
0667:  GOTO   643
0668:  BCF    03.5
0669:  MOVF   68,W
066A:  BSF    03.5
066B:  MOVWF  1C
066C:  BCF    03.5
066D:  MOVF   67,W
066E:  BSF    03.5
066F:  MOVWF  1B
0670:  BCF    03.5
0671:  MOVF   66,W
0672:  BSF    03.5
0673:  MOVWF  1A
0674:  BCF    03.5
0675:  MOVF   65,W
0676:  BSF    03.5
0677:  MOVWF  19
0678:  BCF    03.5
0679:  BCF    03.6
067A:  CALL   5B2
067B:  MOVF   7A,W
067C:  BSF    03.6
067D:  MOVWF  68
067E:  MOVF   79,W
067F:  MOVWF  67
0680:  MOVF   78,W
0681:  MOVWF  66
0682:  MOVF   77,W
0683:  MOVWF  65
0684:  BTFSS  68.7
0685:  GOTO   695
0686:  BSF    03.5
0687:  DECF   10,F
0688:  BSF    10.5
0689:  BCF    03.5
068A:  COMF   65,F
068B:  COMF   66,F
068C:  COMF   67,F
068D:  COMF   68,F
068E:  INCF   65,F
068F:  BTFSC  03.2
0690:  INCF   66,F
0691:  BTFSC  03.2
0692:  INCF   67,F
0693:  BTFSC  03.2
0694:  INCF   68,F
0695:  MOVLW  3B
0696:  BSF    03.5
0697:  MOVWF  17
0698:  MOVLW  9A
0699:  MOVWF  16
069A:  MOVLW  CA
069B:  MOVWF  15
069C:  CLRF   14
069D:  MOVLW  0A
069E:  MOVWF  12
069F:  BCF    03.5
06A0:  MOVF   69,W
06A1:  BTFSS  03.2
06A2:  GOTO   6A6
06A3:  BSF    03.5
06A4:  INCF   10,F
06A5:  BCF    03.5
06A6:  BSF    03.1
06A7:  MOVLW  65
06A8:  MOVWF  04
06A9:  BSF    03.7
06AA:  MOVF   68,W
06AB:  BSF    03.5
06AC:  MOVWF  1C
06AD:  BCF    03.5
06AE:  MOVF   67,W
06AF:  BSF    03.5
06B0:  MOVWF  1B
06B1:  BCF    03.5
06B2:  MOVF   66,W
06B3:  BSF    03.5
06B4:  MOVWF  1A
06B5:  BCF    03.5
06B6:  MOVF   65,W
06B7:  BSF    03.5
06B8:  MOVWF  19
06B9:  MOVF   17,W
06BA:  MOVWF  20
06BB:  MOVF   16,W
06BC:  MOVWF  1F
06BD:  MOVF   15,W
06BE:  MOVWF  1E
06BF:  MOVF   14,W
06C0:  MOVWF  1D
06C1:  BCF    03.5
06C2:  BCF    03.6
06C3:  CALL   5D5
06C4:  MOVF   78,W
06C5:  MOVF   77,F
06C6:  BTFSS  03.2
06C7:  GOTO   6E2
06C8:  BSF    03.6
06C9:  INCF   69,W
06CA:  BSF    03.5
06CB:  SUBWF  12,W
06CC:  BTFSS  03.2
06CD:  GOTO   6D1
06CE:  BCF    03.5
06CF:  BCF    03.6
06D0:  GOTO   6E2
06D1:  MOVF   10,W
06D2:  BTFSC  03.2
06D3:  GOTO   6E6
06D4:  ANDLW  0F
06D5:  SUBWF  12,W
06D6:  BTFSC  03.2
06D7:  GOTO   6DA
06D8:  BTFSC  03.0
06D9:  GOTO   732
06DA:  BTFSC  10.7
06DB:  GOTO   732
06DC:  BTFSC  10.6
06DD:  GOTO   6E6
06DE:  MOVLW  20
06DF:  GOTO   72A
06E0:  BCF    03.5
06E1:  BCF    03.6
06E2:  MOVLW  20
06E3:  BSF    03.5
06E4:  BSF    03.6
06E5:  ANDWF  10,F
06E6:  BTFSS  10.5
06E7:  GOTO   6FD
06E8:  BCF    10.5
06E9:  BCF    03.5
06EA:  MOVF   69,W
06EB:  BTFSC  03.2
06EC:  GOTO   6F0
06ED:  BSF    03.5
06EE:  DECF   10,F
06EF:  BCF    03.5
06F0:  MOVF   77,W
06F1:  BSF    03.5
06F2:  MOVWF  10
06F3:  MOVLW  2D
06F4:  MOVWF  19
06F5:  BCF    03.5
06F6:  BCF    03.6
06F7:  CALL   628
06F8:  BSF    03.5
06F9:  BSF    03.6
06FA:  MOVF   10,W
06FB:  MOVWF  77
06FC:  CLRF   10
06FD:  BCF    03.5
06FE:  MOVF   69,W
06FF:  BSF    03.5
0700:  SUBWF  12,W
0701:  BTFSS  03.2
0702:  GOTO   711
0703:  MOVF   77,W
0704:  MOVWF  10
0705:  MOVLW  2E
0706:  MOVWF  19
0707:  BCF    03.5
0708:  BCF    03.6
0709:  CALL   628
070A:  BSF    03.5
070B:  BSF    03.6
070C:  MOVF   10,W
070D:  MOVWF  77
070E:  MOVLW  20
070F:  ANDWF  10,F
0710:  MOVLW  00
0711:  MOVLW  30
0712:  BTFSS  10.5
0713:  GOTO   72A
0714:  BCF    10.5
0715:  BCF    03.5
0716:  MOVF   69,W
0717:  BTFSC  03.2
0718:  GOTO   71C
0719:  BSF    03.5
071A:  DECF   10,F
071B:  BCF    03.5
071C:  MOVF   77,W
071D:  BSF    03.5
071E:  MOVWF  10
071F:  MOVLW  2D
0720:  MOVWF  19
0721:  BCF    03.5
0722:  BCF    03.6
0723:  CALL   628
0724:  BSF    03.5
0725:  BSF    03.6
0726:  MOVF   10,W
0727:  MOVWF  77
0728:  CLRF   10
0729:  MOVLW  30
072A:  ADDWF  77,F
072B:  MOVF   77,W
072C:  MOVWF  19
072D:  BCF    03.5
072E:  BCF    03.6
072F:  CALL   628
0730:  BSF    03.5
0731:  BSF    03.6
0732:  BCF    03.1
0733:  MOVF   17,W
0734:  MOVWF  1C
0735:  MOVF   16,W
0736:  MOVWF  1B
0737:  MOVF   15,W
0738:  MOVWF  1A
0739:  MOVF   14,W
073A:  MOVWF  19
073B:  CLRF   20
073C:  CLRF   1F
073D:  CLRF   1E
073E:  MOVLW  0A
073F:  MOVWF  1D
0740:  BCF    03.5
0741:  BCF    03.6
0742:  CALL   5D5
0743:  MOVF   7A,W
0744:  BSF    03.5
0745:  BSF    03.6
0746:  MOVWF  17
0747:  MOVF   79,W
0748:  MOVWF  16
0749:  MOVF   78,W
074A:  MOVWF  15
074B:  MOVF   77,W
074C:  MOVWF  14
074D:  DECFSZ 12,F
074E:  GOTO   750
074F:  GOTO   752
0750:  BCF    03.5
0751:  GOTO   6A6
0752:  BCF    03.5
0753:  BCF    03.6
0754:  RETURN
0755:  MOVLW  8E
0756:  MOVWF  77
0757:  BSF    03.6
0758:  MOVF   66,W
0759:  MOVWF  78
075A:  MOVF   65,W
075B:  MOVWF  79
075C:  CLRF   7A
075D:  MOVF   78,F
075E:  BTFSS  03.2
075F:  GOTO   76A
0760:  MOVF   79,W
0761:  MOVWF  78
0762:  CLRF   79
0763:  MOVLW  08
0764:  SUBWF  77,F
0765:  MOVF   78,F
0766:  BTFSS  03.2
0767:  GOTO   76A
0768:  CLRF   77
0769:  GOTO   772
076A:  BCF    03.0
076B:  BTFSC  78.7
076C:  GOTO   771
076D:  RLF    79,F
076E:  RLF    78,F
076F:  DECF   77,F
0770:  GOTO   76A
0771:  BCF    78.7
0772:  BCF    03.6
0773:  RETURN
0774:  BSF    03.6
0775:  MOVF   66,W
0776:  MOVWF  6D
0777:  MOVF   6A,W
0778:  XORWF  6D,F
0779:  BTFSS  6D.7
077A:  GOTO   780
077B:  BCF    03.2
077C:  BCF    03.0
077D:  BTFSC  66.7
077E:  BSF    03.0
077F:  GOTO   7B3
0780:  MOVF   66,W
0781:  MOVWF  6D
0782:  MOVF   69,W
0783:  MOVWF  6E
0784:  MOVF   65,W
0785:  SUBWF  6E,F
0786:  BTFSC  03.2
0787:  GOTO   78E
0788:  BTFSS  6D.7
0789:  GOTO   7B3
078A:  MOVF   03,W
078B:  XORLW  01
078C:  MOVWF  03
078D:  GOTO   7B3
078E:  MOVF   6A,W
078F:  MOVWF  6E
0790:  MOVF   66,W
0791:  SUBWF  6E,F
0792:  BTFSC  03.2
0793:  GOTO   79A
0794:  BTFSS  6D.7
0795:  GOTO   7B3
0796:  MOVF   03,W
0797:  XORLW  01
0798:  MOVWF  03
0799:  GOTO   7B3
079A:  MOVF   6B,W
079B:  MOVWF  6E
079C:  MOVF   67,W
079D:  SUBWF  6E,F
079E:  BTFSC  03.2
079F:  GOTO   7A6
07A0:  BTFSS  6D.7
07A1:  GOTO   7B3
07A2:  MOVF   03,W
07A3:  XORLW  01
07A4:  MOVWF  03
07A5:  GOTO   7B3
07A6:  MOVF   6C,W
07A7:  MOVWF  6E
07A8:  MOVF   68,W
07A9:  SUBWF  6E,F
07AA:  BTFSC  03.2
07AB:  GOTO   7B2
07AC:  BTFSS  6D.7
07AD:  GOTO   7B3
07AE:  MOVF   03,W
07AF:  XORLW  01
07B0:  MOVWF  03
07B1:  GOTO   7B3
07B2:  BCF    03.0
07B3:  BCF    03.6
07B4:  RETURN
07B5:  MOVLW  8E
07B6:  MOVWF  77
07B7:  BSF    03.6
07B8:  MOVF   6B,W
07B9:  SUBWF  77,F
07BA:  MOVF   6C,W
07BB:  MOVWF  79
07BC:  MOVF   6D,W
07BD:  MOVWF  78
07BE:  BSF    79.7
07BF:  MOVF   77,F
07C0:  BTFSC  03.2
07C1:  GOTO   7CD
07C2:  BCF    03.0
07C3:  MOVF   79,F
07C4:  BTFSS  03.2
07C5:  GOTO   7C9
07C6:  MOVF   78,F
07C7:  BTFSC  03.2
07C8:  GOTO   7CD
07C9:  RRF    79,F
07CA:  RRF    78,F
07CB:  DECFSZ 77,F
07CC:  GOTO   7C2
07CD:  BTFSS  6C.7
07CE:  GOTO   7D4
07CF:  COMF   78,F
07D0:  COMF   79,F
07D1:  INCF   78,F
07D2:  BTFSC  03.2
07D3:  INCF   79,F
07D4:  BCF    03.6
07D5:  RETURN
*
07E0:  BSF    03.6
07E1:  MOVF   28,W
07E2:  CLRF   78
07E3:  SUBWF  27,W
07E4:  BTFSC  03.0
07E5:  GOTO   7E9
07E6:  MOVF   27,W
07E7:  MOVWF  77
07E8:  GOTO   7F5
07E9:  CLRF   77
07EA:  MOVLW  08
07EB:  MOVWF  29
07EC:  RLF    27,F
07ED:  RLF    77,F
07EE:  MOVF   28,W
07EF:  SUBWF  77,W
07F0:  BTFSC  03.0
07F1:  MOVWF  77
07F2:  RLF    78,F
07F3:  DECFSZ 29,F
07F4:  GOTO   7EC
07F5:  BCF    03.6
07F6:  RETURN
*
0800:  BSF    03.6
0801:  MOVF   69,W
0802:  BTFSC  03.2
0803:  GOTO   0DC
0804:  BSF    03.5
0805:  MOVWF  18
0806:  MOVF   10,W
0807:  BTFSS  03.2
0808:  GOTO   00B
0809:  BCF    03.5
080A:  GOTO   0DC
080B:  SUBWF  18,F
080C:  BTFSC  03.0
080D:  GOTO   00F
080E:  GOTO   016
080F:  MOVLW  7F
0810:  ADDWF  18,F
0811:  BTFSS  03.0
0812:  GOTO   015
0813:  BCF    03.5
0814:  GOTO   0DC
0815:  GOTO   020
0816:  MOVLW  81
0817:  SUBWF  18,F
0818:  BTFSC  03.0
0819:  GOTO   01C
081A:  BCF    03.5
081B:  GOTO   0DC
081C:  BTFSS  03.2
081D:  GOTO   020
081E:  BCF    03.5
081F:  GOTO   0DC
0820:  MOVF   18,W
0821:  MOVWF  77
0822:  CLRF   78
0823:  CLRF   79
0824:  CLRF   7A
0825:  CLRF   17
0826:  BCF    03.5
0827:  MOVF   6A,W
0828:  BSF    03.5
0829:  MOVWF  16
082A:  BSF    16.7
082B:  BCF    03.5
082C:  MOVF   6B,W
082D:  BSF    03.5
082E:  MOVWF  15
082F:  BCF    03.5
0830:  MOVF   6C,W
0831:  BSF    03.5
0832:  MOVWF  14
0833:  MOVLW  19
0834:  MOVWF  18
0835:  MOVF   13,W
0836:  SUBWF  14,F
0837:  BTFSC  03.0
0838:  GOTO   049
0839:  MOVLW  01
083A:  SUBWF  15,F
083B:  BTFSC  03.0
083C:  GOTO   049
083D:  SUBWF  16,F
083E:  BTFSC  03.0
083F:  GOTO   049
0840:  SUBWF  17,F
0841:  BTFSC  03.0
0842:  GOTO   049
0843:  INCF   17,F
0844:  INCF   16,F
0845:  INCF   15,F
0846:  MOVF   13,W
0847:  ADDWF  14,F
0848:  GOTO   07B
0849:  MOVF   12,W
084A:  SUBWF  15,F
084B:  BTFSC  03.0
084C:  GOTO   064
084D:  MOVLW  01
084E:  SUBWF  16,F
084F:  BTFSC  03.0
0850:  GOTO   064
0851:  SUBWF  17,F
0852:  BTFSC  03.0
0853:  GOTO   064
0854:  INCF   17,F
0855:  INCF   16,F
0856:  MOVF   12,W
0857:  ADDWF  15,F
0858:  MOVF   13,W
0859:  ADDWF  14,F
085A:  BTFSS  03.0
085B:  GOTO   07B
085C:  INCF   15,F
085D:  BTFSS  03.2
085E:  GOTO   07B
085F:  INCF   16,F
0860:  BTFSS  03.2
0861:  GOTO   07B
0862:  INCF   17,F
0863:  GOTO   07B
0864:  MOVF   11,W
0865:  IORLW  80
0866:  SUBWF  16,F
0867:  BTFSC  03.0
0868:  GOTO   07A
0869:  MOVLW  01
086A:  SUBWF  17,F
086B:  BTFSC  03.0
086C:  GOTO   07A
086D:  INCF   17,F
086E:  MOVF   11,W
086F:  IORLW  80
0870:  ADDWF  16,F
0871:  MOVF   12,W
0872:  ADDWF  15,F
0873:  BTFSS  03.0
0874:  GOTO   058
0875:  INCF   16,F
0876:  BTFSS  03.2
0877:  GOTO   058
0878:  INCF   17,F
0879:  GOTO   058
087A:  BSF    7A.0
087B:  DECFSZ 18,F
087C:  GOTO   07E
087D:  GOTO   089
087E:  BCF    03.0
087F:  RLF    14,F
0880:  RLF    15,F
0881:  RLF    16,F
0882:  RLF    17,F
0883:  BCF    03.0
0884:  RLF    7A,F
0885:  RLF    79,F
0886:  RLF    78,F
0887:  RLF    19,F
0888:  GOTO   035
0889:  BTFSS  19.0
088A:  GOTO   091
088B:  BCF    03.0
088C:  RRF    78,F
088D:  RRF    79,F
088E:  RRF    7A,F
088F:  RRF    19,F
0890:  GOTO   095
0891:  DECFSZ 77,F
0892:  GOTO   095
0893:  BCF    03.5
0894:  GOTO   0DC
0895:  BTFSC  19.7
0896:  GOTO   0BE
0897:  BCF    03.0
0898:  RLF    14,F
0899:  RLF    15,F
089A:  RLF    16,F
089B:  RLF    17,F
089C:  MOVF   13,W
089D:  SUBWF  14,F
089E:  BTFSC  03.0
089F:  GOTO   0AA
08A0:  MOVLW  01
08A1:  SUBWF  15,F
08A2:  BTFSC  03.0
08A3:  GOTO   0AA
08A4:  SUBWF  16,F
08A5:  BTFSC  03.0
08A6:  GOTO   0AA
08A7:  SUBWF  17,F
08A8:  BTFSS  03.0
08A9:  GOTO   0CF
08AA:  MOVF   12,W
08AB:  SUBWF  15,F
08AC:  BTFSC  03.0
08AD:  GOTO   0B5
08AE:  MOVLW  01
08AF:  SUBWF  16,F
08B0:  BTFSC  03.0
08B1:  GOTO   0B5
08B2:  SUBWF  17,F
08B3:  BTFSS  03.0
08B4:  GOTO   0CF
08B5:  MOVF   11,W
08B6:  IORLW  80
08B7:  SUBWF  16,F
08B8:  BTFSC  03.0
08B9:  GOTO   0BE
08BA:  MOVLW  01
08BB:  SUBWF  17,F
08BC:  BTFSS  03.0
08BD:  GOTO   0CF
08BE:  INCF   7A,F
08BF:  BTFSS  03.2
08C0:  GOTO   0CF
08C1:  INCF   79,F
08C2:  BTFSS  03.2
08C3:  GOTO   0CF
08C4:  INCF   78,F
08C5:  BTFSS  03.2
08C6:  GOTO   0CF
08C7:  INCF   77,F
08C8:  BTFSS  03.2
08C9:  GOTO   0CC
08CA:  BCF    03.5
08CB:  GOTO   0DC
08CC:  RRF    78,F
08CD:  RRF    79,F
08CE:  RRF    7A,F
08CF:  BCF    03.5
08D0:  MOVF   6A,W
08D1:  BSF    03.5
08D2:  MOVWF  18
08D3:  MOVF   11,W
08D4:  XORWF  18,F
08D5:  BTFSS  18.7
08D6:  GOTO   0D9
08D7:  BSF    78.7
08D8:  GOTO   0E1
08D9:  BCF    78.7
08DA:  GOTO   0E1
08DB:  BCF    03.5
08DC:  CLRF   77
08DD:  CLRF   78
08DE:  CLRF   79
08DF:  CLRF   7A
08E0:  BSF    03.5
08E1:  BCF    03.5
08E2:  BCF    03.6
08E3:  RETURN
08E4:  MOVF   04,W
08E5:  BSF    03.5
08E6:  BSF    03.6
08E7:  MOVWF  10
08E8:  BCF    03.5
08E9:  MOVF   69,W
08EA:  BSF    03.5
08EB:  MOVWF  12
08EC:  BTFSC  03.2
08ED:  GOTO   115
08EE:  BCF    03.5
08EF:  MOVF   68,W
08F0:  BSF    03.5
08F1:  MOVWF  1C
08F2:  BCF    03.5
08F3:  MOVF   67,W
08F4:  BSF    03.5
08F5:  MOVWF  1B
08F6:  BCF    03.5
08F7:  MOVF   66,W
08F8:  BSF    03.5
08F9:  MOVWF  1A
08FA:  BCF    03.5
08FB:  MOVF   65,W
08FC:  BSF    03.5
08FD:  MOVWF  19
08FE:  CLRF   20
08FF:  CLRF   1F
0900:  MOVLW  20
0901:  MOVWF  1E
0902:  MOVLW  82
0903:  MOVWF  1D
0904:  BCF    0A.3
0905:  BCF    03.5
0906:  BCF    03.6
0907:  CALL   539
0908:  BSF    0A.3
0909:  MOVF   7A,W
090A:  BSF    03.6
090B:  MOVWF  68
090C:  MOVF   79,W
090D:  MOVWF  67
090E:  MOVF   78,W
090F:  MOVWF  66
0910:  MOVF   77,W
0911:  MOVWF  65
0912:  BSF    03.5
0913:  DECFSZ 12,F
0914:  GOTO   0EE
0915:  BCF    03.5
0916:  MOVF   68,W
0917:  BSF    03.5
0918:  MOVWF  1C
0919:  BCF    03.5
091A:  MOVF   67,W
091B:  BSF    03.5
091C:  MOVWF  1B
091D:  BCF    03.5
091E:  MOVF   66,W
091F:  BSF    03.5
0920:  MOVWF  1A
0921:  BCF    03.5
0922:  MOVF   65,W
0923:  BSF    03.5
0924:  MOVWF  19
0925:  BCF    0A.3
0926:  BCF    03.5
0927:  BCF    03.6
0928:  CALL   5B2
0929:  BSF    0A.3
092A:  MOVF   7A,W
092B:  BSF    03.6
092C:  MOVWF  68
092D:  MOVF   79,W
092E:  MOVWF  67
092F:  MOVF   78,W
0930:  MOVWF  66
0931:  MOVF   77,W
0932:  MOVWF  65
0933:  BTFSS  68.7
0934:  GOTO   144
0935:  BSF    03.5
0936:  DECF   10,F
0937:  BSF    10.5
0938:  BCF    03.5
0939:  COMF   65,F
093A:  COMF   66,F
093B:  COMF   67,F
093C:  COMF   68,F
093D:  INCF   65,F
093E:  BTFSC  03.2
093F:  INCF   66,F
0940:  BTFSC  03.2
0941:  INCF   67,F
0942:  BTFSC  03.2
0943:  INCF   68,F
0944:  MOVLW  3B
0945:  BSF    03.5
0946:  MOVWF  17
0947:  MOVLW  9A
0948:  MOVWF  16
0949:  MOVLW  CA
094A:  MOVWF  15
094B:  CLRF   14
094C:  MOVLW  0A
094D:  MOVWF  12
094E:  BCF    03.5
094F:  MOVF   69,W
0950:  BTFSS  03.2
0951:  GOTO   155
0952:  BSF    03.5
0953:  INCF   10,F
0954:  BCF    03.5
0955:  BSF    03.1
0956:  MOVLW  65
0957:  MOVWF  04
0958:  BSF    03.7
0959:  MOVF   68,W
095A:  BSF    03.5
095B:  MOVWF  1C
095C:  BCF    03.5
095D:  MOVF   67,W
095E:  BSF    03.5
095F:  MOVWF  1B
0960:  BCF    03.5
0961:  MOVF   66,W
0962:  BSF    03.5
0963:  MOVWF  1A
0964:  BCF    03.5
0965:  MOVF   65,W
0966:  BSF    03.5
0967:  MOVWF  19
0968:  MOVF   17,W
0969:  MOVWF  20
096A:  MOVF   16,W
096B:  MOVWF  1F
096C:  MOVF   15,W
096D:  MOVWF  1E
096E:  MOVF   14,W
096F:  MOVWF  1D
0970:  BCF    0A.3
0971:  BCF    03.5
0972:  BCF    03.6
0973:  CALL   5D5
0974:  BSF    0A.3
0975:  MOVF   78,W
0976:  MOVF   77,F
0977:  BTFSS  03.2
0978:  GOTO   193
0979:  BSF    03.6
097A:  INCF   69,W
097B:  BSF    03.5
097C:  SUBWF  12,W
097D:  BTFSS  03.2
097E:  GOTO   182
097F:  BCF    03.5
0980:  BCF    03.6
0981:  GOTO   193
0982:  MOVF   10,W
0983:  BTFSC  03.2
0984:  GOTO   197
0985:  ANDLW  0F
0986:  SUBWF  12,W
0987:  BTFSC  03.2
0988:  GOTO   18B
0989:  BTFSC  03.0
098A:  GOTO   1E7
098B:  BTFSC  10.7
098C:  GOTO   1E7
098D:  BTFSC  10.6
098E:  GOTO   197
098F:  MOVLW  20
0990:  GOTO   1DE
0991:  BCF    03.5
0992:  BCF    03.6
0993:  MOVLW  20
0994:  BSF    03.5
0995:  BSF    03.6
0996:  ANDWF  10,F
0997:  BTFSS  10.5
0998:  GOTO   1AF
0999:  BCF    10.5
099A:  BCF    03.5
099B:  MOVF   69,W
099C:  BTFSC  03.2
099D:  GOTO   1A1
099E:  BSF    03.5
099F:  DECF   10,F
09A0:  BCF    03.5
09A1:  MOVF   77,W
09A2:  BSF    03.5
09A3:  MOVWF  10
09A4:  MOVLW  2D
09A5:  BCF    03.5
09A6:  BCF    03.6
09A7:  BTFSS  0C.4
09A8:  GOTO   1A7
09A9:  MOVWF  19
09AA:  BSF    03.5
09AB:  BSF    03.6
09AC:  MOVF   10,W
09AD:  MOVWF  77
09AE:  CLRF   10
09AF:  BCF    03.5
09B0:  MOVF   69,W
09B1:  BSF    03.5
09B2:  SUBWF  12,W
09B3:  BTFSS  03.2
09B4:  GOTO   1C4
09B5:  MOVF   77,W
09B6:  MOVWF  10
09B7:  MOVLW  2E
09B8:  BCF    03.5
09B9:  BCF    03.6
09BA:  BTFSS  0C.4
09BB:  GOTO   1BA
09BC:  MOVWF  19
09BD:  BSF    03.5
09BE:  BSF    03.6
09BF:  MOVF   10,W
09C0:  MOVWF  77
09C1:  MOVLW  20
09C2:  ANDWF  10,F
09C3:  MOVLW  00
09C4:  MOVLW  30
09C5:  BTFSS  10.5
09C6:  GOTO   1DE
09C7:  BCF    10.5
09C8:  BCF    03.5
09C9:  MOVF   69,W
09CA:  BTFSC  03.2
09CB:  GOTO   1CF
09CC:  BSF    03.5
09CD:  DECF   10,F
09CE:  BCF    03.5
09CF:  MOVF   77,W
09D0:  BSF    03.5
09D1:  MOVWF  10
09D2:  MOVLW  2D
09D3:  BCF    03.5
09D4:  BCF    03.6
09D5:  BTFSS  0C.4
09D6:  GOTO   1D5
09D7:  MOVWF  19
09D8:  BSF    03.5
09D9:  BSF    03.6
09DA:  MOVF   10,W
09DB:  MOVWF  77
09DC:  CLRF   10
09DD:  MOVLW  30
09DE:  ADDWF  77,F
09DF:  MOVF   77,W
09E0:  BCF    03.5
09E1:  BCF    03.6
09E2:  BTFSS  0C.4
09E3:  GOTO   1E2
09E4:  MOVWF  19
09E5:  BSF    03.5
09E6:  BSF    03.6
09E7:  BCF    03.1
09E8:  MOVF   17,W
09E9:  MOVWF  1C
09EA:  MOVF   16,W
09EB:  MOVWF  1B
09EC:  MOVF   15,W
09ED:  MOVWF  1A
09EE:  MOVF   14,W
09EF:  MOVWF  19
09F0:  CLRF   20
09F1:  CLRF   1F
09F2:  CLRF   1E
09F3:  MOVLW  0A
09F4:  MOVWF  1D
09F5:  BCF    0A.3
09F6:  BCF    03.5
09F7:  BCF    03.6
09F8:  CALL   5D5
09F9:  BSF    0A.3
09FA:  MOVF   7A,W
09FB:  BSF    03.5
09FC:  BSF    03.6
09FD:  MOVWF  17
09FE:  MOVF   79,W
09FF:  MOVWF  16
0A00:  MOVF   78,W
0A01:  MOVWF  15
0A02:  MOVF   77,W
0A03:  MOVWF  14
0A04:  DECFSZ 12,F
0A05:  GOTO   207
0A06:  GOTO   209
0A07:  BCF    03.5
0A08:  GOTO   155
0A09:  BCF    03.6
0A0A:  BCF    03.5
0A0B:  BCF    0A.3
0A0C:  BSF    0A.4
0A0D:  GOTO   23D (RETURN)
0A0E:  MOVLW  80
0A0F:  BTFSS  03.1
0A10:  GOTO   216
0A11:  BSF    03.5
0A12:  BSF    03.6
0A13:  XORWF  15,F
0A14:  BCF    03.5
0A15:  BCF    03.6
0A16:  BSF    03.5
0A17:  BSF    03.6
0A18:  CLRF   1A
0A19:  CLRF   1B
0A1A:  MOVF   11,W
0A1B:  MOVWF  19
0A1C:  MOVF   15,W
0A1D:  XORWF  19,F
0A1E:  MOVF   10,W
0A1F:  BTFSC  03.2
0A20:  GOTO   305
0A21:  MOVWF  18
0A22:  MOVWF  77
0A23:  MOVF   14,W
0A24:  BTFSC  03.2
0A25:  GOTO   30E
0A26:  SUBWF  18,F
0A27:  BTFSC  03.2
0A28:  GOTO   2AA
0A29:  BTFSS  03.0
0A2A:  GOTO   268
0A2B:  MOVF   15,W
0A2C:  MOVWF  1E
0A2D:  BSF    1E.7
0A2E:  MOVF   16,W
0A2F:  MOVWF  1D
0A30:  MOVF   17,W
0A31:  MOVWF  1C
0A32:  CLRF   1B
0A33:  BCF    03.0
0A34:  RRF    1E,F
0A35:  RRF    1D,F
0A36:  RRF    1C,F
0A37:  RRF    1B,F
0A38:  DECFSZ 18,F
0A39:  GOTO   232
0A3A:  BTFSS  19.7
0A3B:  GOTO   23F
0A3C:  BSF    1A.0
0A3D:  GOTO   322
0A3E:  BCF    1A.0
0A3F:  BCF    18.0
0A40:  BSF    1A.4
0A41:  MOVLW  93
0A42:  MOVWF  04
0A43:  BSF    03.7
0A44:  GOTO   337
0A45:  BCF    1A.4
0A46:  BTFSC  19.7
0A47:  GOTO   252
0A48:  BTFSS  18.0
0A49:  GOTO   25D
0A4A:  RRF    1E,F
0A4B:  RRF    1D,F
0A4C:  RRF    1C,F
0A4D:  RRF    1B,F
0A4E:  INCF   77,F
0A4F:  BTFSC  03.2
0A50:  GOTO   31D
0A51:  GOTO   25D
0A52:  BTFSC  1E.7
0A53:  GOTO   260
0A54:  BCF    03.0
0A55:  RLF    1B,F
0A56:  RLF    1C,F
0A57:  RLF    1D,F
0A58:  RLF    1E,F
0A59:  DECF   77,F
0A5A:  BTFSC  03.2
0A5B:  GOTO   31D
0A5C:  GOTO   252
0A5D:  BSF    1A.6
0A5E:  GOTO   2CA
0A5F:  BCF    1A.6
0A60:  MOVF   11,W
0A61:  MOVWF  19
0A62:  BTFSS  19.7
0A63:  GOTO   266
0A64:  BSF    1E.7
0A65:  GOTO   316
0A66:  BCF    1E.7
0A67:  GOTO   316
0A68:  MOVF   14,W
0A69:  MOVWF  18
0A6A:  MOVWF  77
0A6B:  MOVF   10,W
0A6C:  SUBWF  18,F
0A6D:  MOVF   11,W
0A6E:  MOVWF  1E
0A6F:  BSF    1E.7
0A70:  MOVF   12,W
0A71:  MOVWF  1D
0A72:  MOVF   13,W
0A73:  MOVWF  1C
0A74:  CLRF   1B
0A75:  BCF    03.0
0A76:  RRF    1E,F
0A77:  RRF    1D,F
0A78:  RRF    1C,F
0A79:  RRF    1B,F
0A7A:  DECFSZ 18,F
0A7B:  GOTO   274
0A7C:  BTFSS  19.7
0A7D:  GOTO   281
0A7E:  BSF    1A.1
0A7F:  GOTO   322
0A80:  BCF    1A.1
0A81:  BCF    18.0
0A82:  BSF    1A.5
0A83:  MOVLW  97
0A84:  MOVWF  04
0A85:  BSF    03.7
0A86:  GOTO   337
0A87:  BCF    1A.5
0A88:  BTFSC  19.7
0A89:  GOTO   294
0A8A:  BTFSS  18.0
0A8B:  GOTO   29F
0A8C:  RRF    1E,F
0A8D:  RRF    1D,F
0A8E:  RRF    1C,F
0A8F:  RRF    1B,F
0A90:  INCF   77,F
0A91:  BTFSC  03.2
0A92:  GOTO   31D
0A93:  GOTO   29F
0A94:  BTFSC  1E.7
0A95:  GOTO   2A2
0A96:  BCF    03.0
0A97:  RLF    1B,F
0A98:  RLF    1C,F
0A99:  RLF    1D,F
0A9A:  RLF    1E,F
0A9B:  DECF   77,F
0A9C:  BTFSC  03.2
0A9D:  GOTO   31D
0A9E:  GOTO   294
0A9F:  BSF    1A.7
0AA0:  GOTO   2CA
0AA1:  BCF    1A.7
0AA2:  MOVF   15,W
0AA3:  MOVWF  19
0AA4:  BTFSS  19.7
0AA5:  GOTO   2A8
0AA6:  BSF    1E.7
0AA7:  GOTO   316
0AA8:  BCF    1E.7
0AA9:  GOTO   316
0AAA:  MOVF   15,W
0AAB:  MOVWF  1E
0AAC:  BSF    1E.7
0AAD:  MOVF   16,W
0AAE:  MOVWF  1D
0AAF:  MOVF   17,W
0AB0:  MOVWF  1C
0AB1:  BTFSS  19.7
0AB2:  GOTO   2B7
0AB3:  BCF    1E.7
0AB4:  BSF    1A.2
0AB5:  GOTO   322
0AB6:  BCF    1A.2
0AB7:  CLRF   1B
0AB8:  BCF    18.0
0AB9:  MOVLW  93
0ABA:  MOVWF  04
0ABB:  BSF    03.7
0ABC:  GOTO   337
0ABD:  BTFSC  19.7
0ABE:  GOTO   2E0
0ABF:  MOVF   11,W
0AC0:  MOVWF  19
0AC1:  BTFSS  18.0
0AC2:  GOTO   2CA
0AC3:  RRF    1E,F
0AC4:  RRF    1D,F
0AC5:  RRF    1C,F
0AC6:  RRF    1B,F
0AC7:  INCF   77,F
0AC8:  BTFSC  03.2
0AC9:  GOTO   31D
0ACA:  BTFSS  1B.7
0ACB:  GOTO   2DB
0ACC:  INCF   1C,F
0ACD:  BTFSS  03.2
0ACE:  GOTO   2DB
0ACF:  INCF   1D,F
0AD0:  BTFSS  03.2
0AD1:  GOTO   2DB
0AD2:  INCF   1E,F
0AD3:  BTFSS  03.2
0AD4:  GOTO   2DB
0AD5:  RRF    1E,F
0AD6:  RRF    1D,F
0AD7:  RRF    1C,F
0AD8:  INCF   77,F
0AD9:  BTFSC  03.2
0ADA:  GOTO   31D
0ADB:  BTFSC  1A.6
0ADC:  GOTO   25F
0ADD:  BTFSC  1A.7
0ADE:  GOTO   2A1
0ADF:  GOTO   2FF
0AE0:  MOVLW  80
0AE1:  XORWF  1E,F
0AE2:  BTFSS  1E.7
0AE3:  GOTO   2E8
0AE4:  GOTO   322
0AE5:  MOVF   15,W
0AE6:  MOVWF  19
0AE7:  GOTO   2F5
0AE8:  MOVF   11,W
0AE9:  MOVWF  19
0AEA:  MOVF   1E,F
0AEB:  BTFSS  03.2
0AEC:  GOTO   2F5
0AED:  MOVF   1D,F
0AEE:  BTFSS  03.2
0AEF:  GOTO   2F5
0AF0:  MOVF   1C,F
0AF1:  BTFSS  03.2
0AF2:  GOTO   2F5
0AF3:  CLRF   77
0AF4:  GOTO   316
0AF5:  BTFSC  1E.7
0AF6:  GOTO   2FF
0AF7:  BCF    03.0
0AF8:  RLF    1B,F
0AF9:  RLF    1C,F
0AFA:  RLF    1D,F
0AFB:  RLF    1E,F
0AFC:  DECFSZ 77,F
0AFD:  GOTO   2F5
0AFE:  GOTO   31D
0AFF:  BTFSS  19.7
0B00:  GOTO   303
0B01:  BSF    1E.7
0B02:  GOTO   316
0B03:  BCF    1E.7
0B04:  GOTO   316
0B05:  MOVF   14,W
0B06:  MOVWF  77
0B07:  MOVF   15,W
0B08:  MOVWF  1E
0B09:  MOVF   16,W
0B0A:  MOVWF  1D
0B0B:  MOVF   17,W
0B0C:  MOVWF  1C
0B0D:  GOTO   316
0B0E:  MOVF   10,W
0B0F:  MOVWF  77
0B10:  MOVF   11,W
0B11:  MOVWF  1E
0B12:  MOVF   12,W
0B13:  MOVWF  1D
0B14:  MOVF   13,W
0B15:  MOVWF  1C
0B16:  MOVF   1E,W
0B17:  MOVWF  78
0B18:  MOVF   1D,W
0B19:  MOVWF  79
0B1A:  MOVF   1C,W
0B1B:  MOVWF  7A
0B1C:  GOTO   355
0B1D:  CLRF   77
0B1E:  CLRF   78
0B1F:  CLRF   79
0B20:  CLRF   7A
0B21:  GOTO   355
0B22:  CLRF   1B
0B23:  COMF   1C,F
0B24:  COMF   1D,F
0B25:  COMF   1E,F
0B26:  COMF   1B,F
0B27:  INCF   1B,F
0B28:  BTFSS  03.2
0B29:  GOTO   330
0B2A:  INCF   1C,F
0B2B:  BTFSS  03.2
0B2C:  GOTO   330
0B2D:  INCF   1D,F
0B2E:  BTFSC  03.2
0B2F:  INCF   1E,F
0B30:  BTFSC  1A.0
0B31:  GOTO   23E
0B32:  BTFSC  1A.1
0B33:  GOTO   280
0B34:  BTFSC  1A.2
0B35:  GOTO   2B6
0B36:  GOTO   2E5
0B37:  MOVF   00,W
0B38:  ADDWF  1C,F
0B39:  BTFSS  03.0
0B3A:  GOTO   341
0B3B:  INCF   1D,F
0B3C:  BTFSS  03.2
0B3D:  GOTO   341
0B3E:  INCF   1E,F
0B3F:  BTFSC  03.2
0B40:  BSF    18.0
0B41:  DECF   04,F
0B42:  MOVF   00,W
0B43:  ADDWF  1D,F
0B44:  BTFSS  03.0
0B45:  GOTO   349
0B46:  INCF   1E,F
0B47:  BTFSC  03.2
0B48:  BSF    18.0
0B49:  DECF   04,F
0B4A:  MOVF   00,W
0B4B:  BTFSS  00.7
0B4C:  XORLW  80
0B4D:  ADDWF  1E,F
0B4E:  BTFSC  03.0
0B4F:  BSF    18.0
0B50:  BTFSC  1A.4
0B51:  GOTO   245
0B52:  BTFSC  1A.5
0B53:  GOTO   287
0B54:  GOTO   2BD
0B55:  BCF    03.5
0B56:  BCF    03.6
0B57:  RETURN
*
0F06:  MOVLW  20
0F07:  BTFSS  22.4
0F08:  MOVLW  30
0F09:  MOVWF  23
0F0A:  MOVF   21,W
0F0B:  MOVWF  77
0F0C:  BTFSS  21.7
0F0D:  GOTO   716
0F0E:  COMF   77,F
0F0F:  INCF   77,F
0F10:  MOVF   77,W
0F11:  MOVWF  21
0F12:  MOVLW  2D
0F13:  MOVWF  23
0F14:  BSF    22.7
0F15:  BSF    22.0
0F16:  MOVF   21,W
0F17:  MOVWF  27
0F18:  MOVLW  64
0F19:  MOVWF  28
0F1A:  BCF    0A.3
0F1B:  BCF    03.6
0F1C:  CALL   7E0
0F1D:  BSF    0A.3
0F1E:  MOVF   77,W
0F1F:  BSF    03.6
0F20:  MOVWF  21
0F21:  MOVLW  30
0F22:  ADDWF  78,W
0F23:  MOVWF  24
0F24:  MOVF   21,W
0F25:  MOVWF  27
0F26:  MOVLW  0A
0F27:  MOVWF  28
0F28:  BCF    0A.3
0F29:  BCF    03.6
0F2A:  CALL   7E0
0F2B:  BSF    0A.3
0F2C:  MOVLW  30
0F2D:  ADDWF  77,W
0F2E:  BSF    03.6
0F2F:  MOVWF  26
0F30:  MOVLW  30
0F31:  ADDWF  78,W
0F32:  MOVWF  25
0F33:  MOVF   23,W
0F34:  MOVWF  77
0F35:  MOVLW  30
0F36:  SUBWF  24,W
0F37:  BTFSC  03.2
0F38:  GOTO   73D
0F39:  BSF    22.1
0F3A:  BTFSC  22.7
0F3B:  BSF    22.2
0F3C:  GOTO   751
0F3D:  MOVF   23,W
0F3E:  MOVWF  24
0F3F:  MOVLW  20
0F40:  MOVWF  23
0F41:  MOVLW  30
0F42:  SUBWF  25,W
0F43:  BTFSC  03.2
0F44:  GOTO   749
0F45:  BSF    22.0
0F46:  BTFSC  22.7
0F47:  BSF    22.1
0F48:  GOTO   751
0F49:  BTFSS  03.2
0F4A:  BSF    22.0
0F4B:  BTFSS  03.2
0F4C:  GOTO   751
0F4D:  MOVF   24,W
0F4E:  MOVWF  25
0F4F:  MOVLW  20
0F50:  MOVWF  24
0F51:  BTFSC  22.2
0F52:  GOTO   758
0F53:  BTFSC  22.1
0F54:  GOTO   769
0F55:  BTFSC  22.0
0F56:  GOTO   77A
0F57:  GOTO   78B
0F58:  BCF    03.6
0F59:  CLRF   27
0F5A:  BTFSC  0B.7
0F5B:  BSF    27.7
0F5C:  BCF    0B.7
0F5D:  BSF    03.6
0F5E:  MOVF   23,W
0F5F:  BSF    03.5
0F60:  MOVWF  19
0F61:  BCF    0A.3
0F62:  BCF    03.5
0F63:  BCF    03.6
0F64:  CALL   628
0F65:  BSF    0A.3
0F66:  BTFSC  27.7
0F67:  BSF    0B.7
0F68:  BSF    03.6
0F69:  BCF    03.6
0F6A:  CLRF   27
0F6B:  BTFSC  0B.7
0F6C:  BSF    27.7
0F6D:  BCF    0B.7
0F6E:  BSF    03.6
0F6F:  MOVF   24,W
0F70:  BSF    03.5
0F71:  MOVWF  19
0F72:  BCF    0A.3
0F73:  BCF    03.5
0F74:  BCF    03.6
0F75:  CALL   628
0F76:  BSF    0A.3
0F77:  BTFSC  27.7
0F78:  BSF    0B.7
0F79:  BSF    03.6
0F7A:  BCF    03.6
0F7B:  CLRF   27
0F7C:  BTFSC  0B.7
0F7D:  BSF    27.7
0F7E:  BCF    0B.7
0F7F:  BSF    03.6
0F80:  MOVF   25,W
0F81:  BSF    03.5
0F82:  MOVWF  19
0F83:  BCF    0A.3
0F84:  BCF    03.5
0F85:  BCF    03.6
0F86:  CALL   628
0F87:  BSF    0A.3
0F88:  BTFSC  27.7
0F89:  BSF    0B.7
0F8A:  BSF    03.6
0F8B:  BCF    03.6
0F8C:  CLRF   27
0F8D:  BTFSC  0B.7
0F8E:  BSF    27.7
0F8F:  BCF    0B.7
0F90:  BSF    03.6
0F91:  MOVF   26,W
0F92:  BSF    03.5
0F93:  MOVWF  19
0F94:  BCF    0A.3
0F95:  BCF    03.5
0F96:  BCF    03.6
0F97:  CALL   628
0F98:  BSF    0A.3
0F99:  BTFSC  27.7
0F9A:  BSF    0B.7
0F9B:  CLRF   27
0F9C:  BTFSC  0B.7
0F9D:  BSF    27.7
0F9E:  BCF    0B.7
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=4000000) 
*
026D:  MOVLW  3D
026E:  MOVWF  04
026F:  BSF    03.7
0270:  MOVF   00,W
0271:  BTFSC  03.2
0272:  GOTO   281
0273:  MOVLW  01
0274:  MOVWF  78
0275:  CLRF   77
0276:  DECFSZ 77,F
0277:  GOTO   276
0278:  DECFSZ 78,F
0279:  GOTO   275
027A:  MOVLW  4A
027B:  MOVWF  77
027C:  DECFSZ 77,F
027D:  GOTO   27C
027E:  GOTO   27F
027F:  DECFSZ 00,F
0280:  GOTO   273
0281:  RETURN
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, bits=8, parity=N) 
....................  
.................... #fuses XT, NOWDT,NOPROTECT,NOLVP 
.................... #include <HDM64GS12.c> //Manejo del display gráfico 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
0D6A:  BCF    28.0
0D6B:  MOVF   28,W
0D6C:  BSF    03.5
0D6D:  MOVWF  07
0D6E:  BCF    03.5
0D6F:  BSF    07.0
....................    output_low(GLCD_E); 
0D70:  BSF    03.5
0D71:  BCF    06.5
0D72:  BCF    03.5
0D73:  BCF    06.5
....................    output_low(GLCD_CS1); 
0D74:  BSF    03.5
0D75:  BCF    06.0
0D76:  BCF    03.5
0D77:  BCF    06.0
....................    output_low(GLCD_CS2); 
0D78:  BSF    03.5
0D79:  BCF    06.1
0D7A:  BCF    03.5
0D7B:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
0D7C:  BSF    03.5
0D7D:  BCF    06.2
0D7E:  BCF    03.5
0D7F:  BCF    06.2
0D80:  CLRF   27
0D81:  BTFSC  0B.7
0D82:  BSF    27.7
0D83:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
0D84:  BSF    03.5
0D85:  BSF    03.6
0D86:  CLRF   24
0D87:  MOVLW  C0
0D88:  MOVWF  25
0D89:  BCF    0A.3
0D8A:  BCF    03.5
0D8B:  BCF    03.6
0D8C:  CALL   2F4
0D8D:  BSF    0A.3
0D8E:  BTFSC  27.7
0D8F:  BSF    0B.7
0D90:  CLRF   27
0D91:  BTFSC  0B.7
0D92:  BSF    27.7
0D93:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
0D94:  MOVLW  01
0D95:  BSF    03.5
0D96:  BSF    03.6
0D97:  MOVWF  24
0D98:  MOVLW  C0
0D99:  MOVWF  25
0D9A:  BCF    0A.3
0D9B:  BCF    03.5
0D9C:  BCF    03.6
0D9D:  CALL   2F4
0D9E:  BSF    0A.3
0D9F:  BTFSC  27.7
0DA0:  BSF    0B.7
0DA1:  CLRF   27
0DA2:  BTFSC  0B.7
0DA3:  BSF    27.7
0DA4:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
0DA5:  BSF    03.5
0DA6:  BSF    03.6
0DA7:  CLRF   24
0DA8:  MOVLW  40
0DA9:  MOVWF  25
0DAA:  BCF    0A.3
0DAB:  BCF    03.5
0DAC:  BCF    03.6
0DAD:  CALL   2F4
0DAE:  BSF    0A.3
0DAF:  BTFSC  27.7
0DB0:  BSF    0B.7
0DB1:  CLRF   27
0DB2:  BTFSC  0B.7
0DB3:  BSF    27.7
0DB4:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
0DB5:  MOVLW  01
0DB6:  BSF    03.5
0DB7:  BSF    03.6
0DB8:  MOVWF  24
0DB9:  MOVLW  40
0DBA:  MOVWF  25
0DBB:  BCF    0A.3
0DBC:  BCF    03.5
0DBD:  BCF    03.6
0DBE:  CALL   2F4
0DBF:  BSF    0A.3
0DC0:  BTFSC  27.7
0DC1:  BSF    0B.7
0DC2:  CLRF   27
0DC3:  BTFSC  0B.7
0DC4:  BSF    27.7
0DC5:  BCF    0B.7
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
0DC6:  BSF    03.5
0DC7:  BSF    03.6
0DC8:  CLRF   24
0DC9:  MOVLW  B8
0DCA:  MOVWF  25
0DCB:  BCF    0A.3
0DCC:  BCF    03.5
0DCD:  BCF    03.6
0DCE:  CALL   2F4
0DCF:  BSF    0A.3
0DD0:  BTFSC  27.7
0DD1:  BSF    0B.7
0DD2:  CLRF   27
0DD3:  BTFSC  0B.7
0DD4:  BSF    27.7
0DD5:  BCF    0B.7
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
0DD6:  MOVLW  01
0DD7:  BSF    03.5
0DD8:  BSF    03.6
0DD9:  MOVWF  24
0DDA:  MOVLW  B8
0DDB:  MOVWF  25
0DDC:  BCF    0A.3
0DDD:  BCF    03.5
0DDE:  BCF    03.6
0DDF:  CALL   2F4
0DE0:  BSF    0A.3
0DE1:  BTFSC  27.7
0DE2:  BSF    0B.7
....................  
....................    if(mode == ON) 
0DE3:  BSF    03.6
0DE4:  DECFSZ 1D,W
0DE5:  GOTO   60A
0DE6:  BCF    03.6
0DE7:  CLRF   27
0DE8:  BTFSC  0B.7
0DE9:  BSF    27.7
0DEA:  BCF    0B.7
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
0DEB:  BSF    03.5
0DEC:  BSF    03.6
0DED:  CLRF   24
0DEE:  MOVLW  3F
0DEF:  MOVWF  25
0DF0:  BCF    0A.3
0DF1:  BCF    03.5
0DF2:  BCF    03.6
0DF3:  CALL   2F4
0DF4:  BSF    0A.3
0DF5:  BTFSC  27.7
0DF6:  BSF    0B.7
0DF7:  CLRF   27
0DF8:  BTFSC  0B.7
0DF9:  BSF    27.7
0DFA:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0DFB:  MOVLW  01
0DFC:  BSF    03.5
0DFD:  BSF    03.6
0DFE:  MOVWF  24
0DFF:  MOVLW  3F
0E00:  MOVWF  25
0E01:  BCF    0A.3
0E02:  BCF    03.5
0E03:  BCF    03.6
0E04:  CALL   2F4
0E05:  BSF    0A.3
0E06:  BTFSC  27.7
0E07:  BSF    0B.7
....................    } 
0E08:  GOTO   62C
0E09:  BSF    03.6
0E0A:  BCF    03.6
0E0B:  CLRF   27
0E0C:  BTFSC  0B.7
0E0D:  BSF    27.7
0E0E:  BCF    0B.7
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
0E0F:  BSF    03.5
0E10:  BSF    03.6
0E11:  CLRF   24
0E12:  MOVLW  3E
0E13:  MOVWF  25
0E14:  BCF    0A.3
0E15:  BCF    03.5
0E16:  BCF    03.6
0E17:  CALL   2F4
0E18:  BSF    0A.3
0E19:  BTFSC  27.7
0E1A:  BSF    0B.7
0E1B:  CLRF   27
0E1C:  BTFSC  0B.7
0E1D:  BSF    27.7
0E1E:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
0E1F:  MOVLW  01
0E20:  BSF    03.5
0E21:  BSF    03.6
0E22:  MOVWF  24
0E23:  MOVLW  3E
0E24:  MOVWF  25
0E25:  BCF    0A.3
0E26:  BCF    03.5
0E27:  BCF    03.6
0E28:  CALL   2F4
0E29:  BSF    0A.3
0E2A:  BTFSC  27.7
0E2B:  BSF    0B.7
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
0E2C:  BSF    03.6
0E2D:  CLRF   1E
....................  
....................    #ifdef FAST_GLCD 
*
0EEB:  BCF    03.6
0EEC:  BSF    0A.3
0EED:  BSF    0A.4
0EEE:  GOTO   055 (RETURN)
....................    glcd_update(); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
*
0325:  BSF    03.5
0326:  BSF    03.6
0327:  BCF    21.0
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
0328:  MOVF   1D,W
0329:  SUBLW  3F
032A:  BTFSC  03.0
032B:  GOTO   32F
....................    { 
....................       x -= 64; 
032C:  MOVLW  40
032D:  SUBWF  1D,F
....................       side = GLCD_RIGHT; 
032E:  BSF    21.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
032F:  BCF    03.6
0330:  BCF    06.2
0331:  BCF    03.5
0332:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0333:  BSF    03.5
0334:  BSF    03.6
0335:  BCF    1D.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0336:  BSF    1D.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
0337:  MOVLW  00
0338:  BTFSC  21.0
0339:  MOVLW  01
033A:  MOVWF  22
033B:  MOVWF  24
033C:  MOVF   1D,W
033D:  MOVWF  25
033E:  BCF    03.5
033F:  BCF    03.6
0340:  CALL   2F4
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
0341:  MOVLW  00
0342:  BSF    03.5
0343:  BSF    03.6
0344:  BTFSC  21.0
0345:  MOVLW  01
0346:  MOVWF  22
0347:  RRF    1E,W
0348:  MOVWF  77
0349:  RRF    77,F
034A:  RRF    77,F
034B:  MOVLW  1F
034C:  ANDWF  77,F
034D:  MOVF   77,W
034E:  ANDLW  BF
034F:  IORLW  B8
0350:  MOVWF  23
0351:  MOVF   22,W
0352:  MOVWF  24
0353:  MOVF   23,W
0354:  MOVWF  25
0355:  BCF    03.5
0356:  BCF    03.6
0357:  CALL   2F4
....................    output_high(GLCD_DI);                        // Set for data 
0358:  BSF    03.5
0359:  BCF    06.2
035A:  BCF    03.5
035B:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
035C:  MOVLW  00
035D:  BSF    03.5
035E:  BSF    03.6
035F:  BTFSC  21.0
0360:  MOVLW  01
0361:  MOVWF  22
0362:  MOVF   22,W
0363:  MOVWF  23
....................    data = glcd_readByte(side);                  //  at new address 
*
0398:  MOVLW  00
0399:  BTFSC  21.0
039A:  MOVLW  01
039B:  MOVWF  22
039C:  MOVF   22,W
039D:  MOVWF  23
*
03D2:  MOVF   78,W
03D3:  MOVWF  20
....................  
....................    if(color == ON) 
03D4:  DECFSZ 1F,W
03D5:  GOTO   3E6
....................       bit_set(data, y%8);        // Turn the pixel on 
03D6:  MOVF   1E,W
03D7:  ANDLW  07
03D8:  MOVWF  22
03D9:  MOVLW  01
03DA:  MOVWF  77
03DB:  MOVF   22,W
03DC:  MOVWF  78
03DD:  BTFSC  03.2
03DE:  GOTO   3E3
03DF:  BCF    03.0
03E0:  RLF    77,F
03E1:  DECFSZ 78,F
03E2:  GOTO   3DF
03E3:  MOVF   77,W
03E4:  IORWF  20,F
03E5:  GOTO   3F6
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
03E6:  MOVF   1E,W
03E7:  ANDLW  07
03E8:  MOVWF  22
03E9:  MOVLW  01
03EA:  MOVWF  77
03EB:  MOVF   22,W
03EC:  MOVWF  78
03ED:  BTFSC  03.2
03EE:  GOTO   3F3
03EF:  BCF    03.0
03F0:  RLF    77,F
03F1:  DECFSZ 78,F
03F2:  GOTO   3EF
03F3:  MOVF   77,W
03F4:  XORLW  FF
03F5:  ANDWF  20,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
03F6:  BCF    03.6
03F7:  BCF    06.2
03F8:  BCF    03.5
03F9:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
03FA:  MOVLW  00
03FB:  BSF    03.5
03FC:  BSF    03.6
03FD:  BTFSC  21.0
03FE:  MOVLW  01
03FF:  MOVWF  22
0400:  MOVWF  24
0401:  MOVF   1D,W
0402:  MOVWF  25
0403:  BCF    03.5
0404:  BCF    03.6
0405:  CALL   2F4
....................    output_high(GLCD_DI);         // Set for data 
0406:  BSF    03.5
0407:  BCF    06.2
0408:  BCF    03.5
0409:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
040A:  MOVLW  00
040B:  BSF    03.5
040C:  BSF    03.6
040D:  BTFSC  21.0
040E:  MOVLW  01
040F:  MOVWF  22
0410:  MOVWF  24
0411:  MOVF   20,W
0412:  MOVWF  25
0413:  BCF    03.5
0414:  BCF    03.6
0415:  CALL   2F4
0416:  RETURN
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0E2E:  CLRF   1F
0E2F:  MOVF   1F,W
0E30:  SUBLW  07
0E31:  BTFSS  03.0
0E32:  GOTO   6EB
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0E33:  BSF    03.5
0E34:  BCF    03.6
0E35:  BCF    06.2
0E36:  BCF    03.5
0E37:  BCF    06.2
0E38:  CLRF   27
0E39:  BTFSC  0B.7
0E3A:  BSF    27.7
0E3B:  BCF    0B.7
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
0E3C:  BSF    03.5
0E3D:  BSF    03.6
0E3E:  CLRF   24
0E3F:  MOVLW  40
0E40:  MOVWF  25
0E41:  BCF    0A.3
0E42:  BCF    03.5
0E43:  BCF    03.6
0E44:  CALL   2F4
0E45:  BSF    0A.3
0E46:  BTFSC  27.7
0E47:  BSF    0B.7
0E48:  CLRF   27
0E49:  BTFSC  0B.7
0E4A:  BSF    27.7
0E4B:  BCF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
0E4C:  MOVLW  01
0E4D:  BSF    03.5
0E4E:  BSF    03.6
0E4F:  MOVWF  24
0E50:  MOVLW  40
0E51:  MOVWF  25
0E52:  BCF    0A.3
0E53:  BCF    03.5
0E54:  BCF    03.6
0E55:  CALL   2F4
0E56:  BSF    0A.3
0E57:  BTFSC  27.7
0E58:  BSF    0B.7
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
0E59:  BSF    03.6
0E5A:  MOVF   1F,W
0E5B:  IORLW  B8
0E5C:  MOVWF  21
0E5D:  BCF    03.6
0E5E:  CLRF   27
0E5F:  BTFSC  0B.7
0E60:  BSF    27.7
0E61:  BCF    0B.7
0E62:  BSF    03.5
0E63:  BSF    03.6
0E64:  CLRF   24
0E65:  BCF    03.5
0E66:  MOVF   21,W
0E67:  BSF    03.5
0E68:  MOVWF  25
0E69:  BCF    0A.3
0E6A:  BCF    03.5
0E6B:  BCF    03.6
0E6C:  CALL   2F4
0E6D:  BSF    0A.3
0E6E:  BTFSC  27.7
0E6F:  BSF    0B.7
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
0E70:  BSF    03.6
0E71:  MOVF   1F,W
0E72:  IORLW  B8
0E73:  MOVWF  21
0E74:  BCF    03.6
0E75:  CLRF   27
0E76:  BTFSC  0B.7
0E77:  BSF    27.7
0E78:  BCF    0B.7
0E79:  MOVLW  01
0E7A:  BSF    03.5
0E7B:  BSF    03.6
0E7C:  MOVWF  24
0E7D:  BCF    03.5
0E7E:  MOVF   21,W
0E7F:  BSF    03.5
0E80:  MOVWF  25
0E81:  BCF    0A.3
0E82:  BCF    03.5
0E83:  BCF    03.6
0E84:  CALL   2F4
0E85:  BSF    0A.3
0E86:  BTFSC  27.7
0E87:  BSF    0B.7
....................       output_high(GLCD_DI);                     // Set for data 
0E88:  BSF    03.5
0E89:  BCF    06.2
0E8A:  BCF    03.5
0E8B:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0E8C:  BSF    03.6
0E8D:  CLRF   20
0E8E:  MOVF   20,W
0E8F:  SUBLW  3F
0E90:  BTFSS  03.0
0E91:  GOTO   6E9
0E92:  BCF    03.6
0E93:  CLRF   27
0E94:  BTFSC  0B.7
0E95:  BSF    27.7
0E96:  BCF    0B.7
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
0E97:  MOVLW  FF
0E98:  BSF    03.5
0E99:  BSF    03.6
0E9A:  MOVWF  19
0E9B:  BCF    03.5
0E9C:  MOVF   1E,W
0E9D:  BSF    03.5
0E9E:  MOVWF  1A
0E9F:  BCF    0A.3
0EA0:  BCF    03.5
0EA1:  BCF    03.6
0EA2:  CALL   2CB
0EA3:  BSF    0A.3
0EA4:  BTFSC  27.7
0EA5:  BSF    0B.7
0EA6:  MOVF   78,W
0EA7:  BSF    03.6
0EA8:  MOVWF  21
0EA9:  BCF    03.6
0EAA:  CLRF   27
0EAB:  BTFSC  0B.7
0EAC:  BSF    27.7
0EAD:  BCF    0B.7
0EAE:  BSF    03.5
0EAF:  BSF    03.6
0EB0:  CLRF   24
0EB1:  BCF    03.5
0EB2:  MOVF   21,W
0EB3:  BSF    03.5
0EB4:  MOVWF  25
0EB5:  BCF    0A.3
0EB6:  BCF    03.5
0EB7:  BCF    03.6
0EB8:  CALL   2F4
0EB9:  BSF    0A.3
0EBA:  BTFSC  27.7
0EBB:  BSF    0B.7
0EBC:  CLRF   27
0EBD:  BTFSC  0B.7
0EBE:  BSF    27.7
0EBF:  BCF    0B.7
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
0EC0:  MOVLW  FF
0EC1:  BSF    03.5
0EC2:  BSF    03.6
0EC3:  MOVWF  19
0EC4:  BCF    03.5
0EC5:  MOVF   1E,W
0EC6:  BSF    03.5
0EC7:  MOVWF  1A
0EC8:  BCF    0A.3
0EC9:  BCF    03.5
0ECA:  BCF    03.6
0ECB:  CALL   2CB
0ECC:  BSF    0A.3
0ECD:  BTFSC  27.7
0ECE:  BSF    0B.7
0ECF:  MOVF   78,W
0ED0:  BSF    03.6
0ED1:  MOVWF  21
0ED2:  BCF    03.6
0ED3:  CLRF   27
0ED4:  BTFSC  0B.7
0ED5:  BSF    27.7
0ED6:  BCF    0B.7
0ED7:  MOVLW  01
0ED8:  BSF    03.5
0ED9:  BSF    03.6
0EDA:  MOVWF  24
0EDB:  BCF    03.5
0EDC:  MOVF   21,W
0EDD:  BSF    03.5
0EDE:  MOVWF  25
0EDF:  BCF    0A.3
0EE0:  BCF    03.5
0EE1:  BCF    03.6
0EE2:  CALL   2F4
0EE3:  BSF    0A.3
0EE4:  BTFSC  27.7
0EE5:  BSF    0B.7
0EE6:  BSF    03.6
0EE7:  INCF   20,F
0EE8:  GOTO   68E
....................       } 
0EE9:  INCF   1F,F
0EEA:  GOTO   62F
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    set_tris_d(0x00); 
*
02F4:  MOVLW  00
02F5:  BSF    03.5
02F6:  MOVWF  08
....................     
....................    output_low(GLCD_RW);       // Set for writing 
02F7:  BCF    06.4
02F8:  BCF    03.5
02F9:  BCF    06.4
....................  
.................... 	 if(side)                   // Choose which side to write to 
02FA:  BSF    03.5
02FB:  BSF    03.6
02FC:  MOVF   24,F
02FD:  BTFSC  03.2
02FE:  GOTO   306
....................       output_high(GLCD_CS2); 
02FF:  BCF    03.6
0300:  BCF    06.1
0301:  BCF    03.5
0302:  BSF    06.1
0303:  GOTO   30A
0304:  BSF    03.5
0305:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS1); 
0306:  BCF    03.6
0307:  BCF    06.0
0308:  BCF    03.5
0309:  BSF    06.0
....................  
.................... 	 delay_us(1); 
030A:  NOP
....................  
....................    output_d(data);            // Put the data on the port 
030B:  BSF    03.5
030C:  CLRF   08
030D:  BSF    03.6
030E:  MOVF   25,W
030F:  BCF    03.5
0310:  BCF    03.6
0311:  MOVWF  08
....................    delay_us(1); 
0312:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0313:  BSF    03.5
0314:  BCF    06.5
0315:  BCF    03.5
0316:  BSF    06.5
....................    delay_us(1); 
0317:  NOP
....................    output_low(GLCD_E); 
0318:  BSF    03.5
0319:  BCF    06.5
031A:  BCF    03.5
031B:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
031C:  BSF    03.5
031D:  BCF    06.0
031E:  BCF    03.5
031F:  BCF    06.0
....................    output_low(GLCD_CS2); 
0320:  BSF    03.5
0321:  BCF    06.1
0322:  BCF    03.5
0323:  BCF    06.1
0324:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
0364:  MOVLW  FF
0365:  BCF    03.6
0366:  MOVWF  08
*
039E:  MOVLW  FF
039F:  BCF    03.6
03A0:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
*
0367:  BCF    06.4
0368:  BCF    03.5
0369:  BSF    06.4
*
03A1:  BCF    06.4
03A2:  BCF    03.5
03A3:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
*
036A:  BSF    03.5
036B:  BSF    03.6
036C:  MOVF   23,F
036D:  BTFSC  03.2
036E:  GOTO   376
*
03A4:  BSF    03.5
03A5:  BSF    03.6
03A6:  MOVF   23,F
03A7:  BTFSC  03.2
03A8:  GOTO   3B0
....................       output_high(GLCD_CS2); 
*
036F:  BCF    03.6
0370:  BCF    06.1
0371:  BCF    03.5
0372:  BSF    06.1
0373:  GOTO   37A
0374:  BSF    03.5
0375:  BSF    03.6
*
03A9:  BCF    03.6
03AA:  BCF    06.1
03AB:  BCF    03.5
03AC:  BSF    06.1
03AD:  GOTO   3B4
03AE:  BSF    03.5
03AF:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS1); 
*
0376:  BCF    03.6
0377:  BCF    06.0
0378:  BCF    03.5
0379:  BSF    06.0
*
03B0:  BCF    03.6
03B1:  BCF    06.0
03B2:  BCF    03.5
03B3:  BSF    06.0
....................  
....................    delay_us(1); 
*
037A:  NOP
*
03B4:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
*
037B:  BSF    03.5
037C:  BCF    06.5
037D:  BCF    03.5
037E:  BSF    06.5
*
03B5:  BSF    03.5
03B6:  BCF    06.5
03B7:  BCF    03.5
03B8:  BSF    06.5
....................    delay_us(1); 
*
037F:  NOP
*
03B9:  NOP
....................    data = input_d();          // Get the data from the display's output register 
*
0380:  MOVLW  FF
0381:  BSF    03.5
0382:  MOVWF  08
0383:  BCF    03.5
0384:  MOVF   08,W
0385:  BSF    03.5
0386:  BSF    03.6
0387:  MOVWF  24
*
03BA:  MOVLW  FF
03BB:  BSF    03.5
03BC:  MOVWF  08
03BD:  BCF    03.5
03BE:  MOVF   08,W
03BF:  BSF    03.5
03C0:  BSF    03.6
03C1:  MOVWF  24
....................    output_low(GLCD_E); 
*
0388:  BCF    03.6
0389:  BCF    06.5
038A:  BCF    03.5
038B:  BCF    06.5
*
03C2:  BCF    03.6
03C3:  BCF    06.5
03C4:  BCF    03.5
03C5:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
*
038C:  BSF    03.5
038D:  BCF    06.0
038E:  BCF    03.5
038F:  BCF    06.0
*
03C6:  BSF    03.5
03C7:  BCF    06.0
03C8:  BCF    03.5
03C9:  BCF    06.0
....................    output_low(GLCD_CS2); 
*
0390:  BSF    03.5
0391:  BCF    06.1
0392:  BCF    03.5
0393:  BCF    06.1
*
03CA:  BSF    03.5
03CB:  BCF    06.1
03CC:  BCF    03.5
03CD:  BCF    06.1
....................    return data;               // Return the read data 
*
0394:  BSF    03.5
0395:  BSF    03.6
0396:  MOVF   24,W
0397:  MOVWF  78
*
03CE:  BSF    03.5
03CF:  BSF    03.6
03D0:  MOVF   24,W
03D1:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <graphics.c> //Funciones para dibujar y escribir en el display 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
*
0B58:  MOVLW  01
0B59:  BSF    03.5
0B5A:  BSF    03.6
0B5B:  MOVWF  15
0B5C:  MOVWF  16
0B5D:  CLRF   1B
.................... { 
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
0B5E:  BCF    03.5
0B5F:  MOVF   6C,W
0B60:  SUBWF  6E,W
0B61:  BSF    03.5
0B62:  MOVWF  1C
0B63:  MOVF   1C,W
0B64:  BTFSS  1C.7
0B65:  GOTO   368
0B66:  MOVF   1C,W
0B67:  SUBLW  00
0B68:  CLRF   7A
0B69:  MOVWF  13
0B6A:  MOVF   7A,W
0B6B:  MOVWF  14
....................    dy = abs((signed int8)(y2 - y1)); 
0B6C:  BCF    03.5
0B6D:  MOVF   6D,W
0B6E:  SUBWF  6F,W
0B6F:  BSF    03.5
0B70:  MOVWF  1C
0B71:  MOVF   1C,W
0B72:  BTFSS  1C.7
0B73:  GOTO   376
0B74:  MOVF   1C,W
0B75:  SUBLW  00
0B76:  CLRF   7A
0B77:  MOVWF  11
0B78:  MOVF   7A,W
0B79:  MOVWF  12
....................    #endif 
....................  
....................    if(x1 > x2) 
0B7A:  BCF    03.5
0B7B:  MOVF   6C,W
0B7C:  SUBWF  6E,W
0B7D:  BTFSC  03.0
0B7E:  GOTO   383
....................       addx = -1; 
0B7F:  MOVLW  FF
0B80:  BSF    03.5
0B81:  MOVWF  15
0B82:  BCF    03.5
....................    if(y1 > y2) 
0B83:  MOVF   6D,W
0B84:  SUBWF  6F,W
0B85:  BTFSC  03.0
0B86:  GOTO   38B
....................       addy = -1; 
0B87:  MOVLW  FF
0B88:  BSF    03.5
0B89:  MOVWF  16
0B8A:  BCF    03.5
....................  
....................    if(dx >= dy) 
0B8B:  BSF    03.5
0B8C:  MOVF   12,W
0B8D:  SUBWF  14,W
0B8E:  BTFSS  03.0
0B8F:  GOTO   3E5
0B90:  BTFSS  03.2
0B91:  GOTO   396
0B92:  MOVF   11,W
0B93:  SUBWF  13,W
0B94:  BTFSS  03.0
0B95:  GOTO   3E5
....................    { 
....................       dy *= 2; 
0B96:  BCF    03.0
0B97:  RLF    11,F
0B98:  RLF    12,F
....................       P = dy - dx; 
0B99:  MOVF   13,W
0B9A:  SUBWF  11,W
0B9B:  MOVWF  77
0B9C:  MOVF   12,W
0B9D:  MOVWF  7A
0B9E:  MOVF   14,W
0B9F:  BTFSS  03.0
0BA0:  INCFSZ 14,W
0BA1:  SUBWF  7A,F
0BA2:  MOVF   77,W
0BA3:  MOVWF  17
0BA4:  MOVF   7A,W
0BA5:  MOVWF  18
....................       diff = P - dx; 
0BA6:  MOVF   13,W
0BA7:  SUBWF  17,W
0BA8:  MOVWF  19
0BA9:  MOVF   18,W
0BAA:  MOVWF  1A
0BAB:  MOVF   14,W
0BAC:  BTFSS  03.0
0BAD:  INCFSZ 14,W
0BAE:  SUBWF  1A,F
....................  
....................       for(; i<=dx; ++i) 
0BAF:  MOVF   14,F
0BB0:  BTFSS  03.2
0BB1:  GOTO   3B6
0BB2:  MOVF   1B,W
0BB3:  SUBWF  13,W
0BB4:  BTFSS  03.0
0BB5:  GOTO   3E4
....................       { 
....................          glcd_pixel(x1, y1, color); 
0BB6:  BCF    03.5
0BB7:  MOVF   6C,W
0BB8:  BSF    03.5
0BB9:  MOVWF  1D
0BBA:  BCF    03.5
0BBB:  MOVF   6D,W
0BBC:  BSF    03.5
0BBD:  MOVWF  1E
0BBE:  MOVF   10,W
0BBF:  MOVWF  1F
0BC0:  BCF    0A.3
0BC1:  BCF    03.5
0BC2:  BCF    03.6
0BC3:  CALL   325
0BC4:  BSF    0A.3
....................  
....................          if(P < 0) 
0BC5:  BSF    03.5
0BC6:  BSF    03.6
0BC7:  BTFSS  18.7
0BC8:  GOTO   3D4
....................          { 
....................             P  += dy; 
0BC9:  MOVF   11,W
0BCA:  ADDWF  17,F
0BCB:  MOVF   12,W
0BCC:  BTFSC  03.0
0BCD:  INCFSZ 12,W
0BCE:  ADDWF  18,F
....................             x1 += addx; 
0BCF:  MOVF   15,W
0BD0:  BCF    03.5
0BD1:  ADDWF  6C,F
....................          } 
0BD2:  GOTO   3E1
0BD3:  BSF    03.5
....................          else 
....................          { 
....................             P  += diff; 
0BD4:  MOVF   19,W
0BD5:  ADDWF  17,F
0BD6:  MOVF   1A,W
0BD7:  BTFSC  03.0
0BD8:  INCFSZ 1A,W
0BD9:  ADDWF  18,F
....................             x1 += addx; 
0BDA:  MOVF   15,W
0BDB:  BCF    03.5
0BDC:  ADDWF  6C,F
....................             y1 += addy; 
0BDD:  BSF    03.5
0BDE:  MOVF   16,W
0BDF:  BCF    03.5
0BE0:  ADDWF  6D,F
....................          } 
0BE1:  BSF    03.5
0BE2:  INCF   1B,F
0BE3:  GOTO   3AF
....................       } 
....................    } 
0BE4:  GOTO   433
....................    else 
....................    { 
....................       dx *= 2; 
0BE5:  BCF    03.0
0BE6:  RLF    13,F
0BE7:  RLF    14,F
....................       P = dx - dy; 
0BE8:  MOVF   11,W
0BE9:  SUBWF  13,W
0BEA:  MOVWF  77
0BEB:  MOVF   14,W
0BEC:  MOVWF  7A
0BED:  MOVF   12,W
0BEE:  BTFSS  03.0
0BEF:  INCFSZ 12,W
0BF0:  SUBWF  7A,F
0BF1:  MOVF   77,W
0BF2:  MOVWF  17
0BF3:  MOVF   7A,W
0BF4:  MOVWF  18
....................       diff = P - dy; 
0BF5:  MOVF   11,W
0BF6:  SUBWF  17,W
0BF7:  MOVWF  19
0BF8:  MOVF   18,W
0BF9:  MOVWF  1A
0BFA:  MOVF   12,W
0BFB:  BTFSS  03.0
0BFC:  INCFSZ 12,W
0BFD:  SUBWF  1A,F
....................  
....................       for(; i<=dy; ++i) 
0BFE:  MOVF   12,F
0BFF:  BTFSS  03.2
0C00:  GOTO   405
0C01:  MOVF   1B,W
0C02:  SUBWF  11,W
0C03:  BTFSS  03.0
0C04:  GOTO   433
....................       { 
....................          glcd_pixel(x1, y1, color); 
0C05:  BCF    03.5
0C06:  MOVF   6C,W
0C07:  BSF    03.5
0C08:  MOVWF  1D
0C09:  BCF    03.5
0C0A:  MOVF   6D,W
0C0B:  BSF    03.5
0C0C:  MOVWF  1E
0C0D:  MOVF   10,W
0C0E:  MOVWF  1F
0C0F:  BCF    0A.3
0C10:  BCF    03.5
0C11:  BCF    03.6
0C12:  CALL   325
0C13:  BSF    0A.3
....................  
....................          if(P < 0) 
0C14:  BSF    03.5
0C15:  BSF    03.6
0C16:  BTFSS  18.7
0C17:  GOTO   423
....................          { 
....................             P  += dx; 
0C18:  MOVF   13,W
0C19:  ADDWF  17,F
0C1A:  MOVF   14,W
0C1B:  BTFSC  03.0
0C1C:  INCFSZ 14,W
0C1D:  ADDWF  18,F
....................             y1 += addy; 
0C1E:  MOVF   16,W
0C1F:  BCF    03.5
0C20:  ADDWF  6D,F
....................          } 
0C21:  GOTO   430
0C22:  BSF    03.5
....................          else 
....................          { 
....................             P  += diff; 
0C23:  MOVF   19,W
0C24:  ADDWF  17,F
0C25:  MOVF   1A,W
0C26:  BTFSC  03.0
0C27:  INCFSZ 1A,W
0C28:  ADDWF  18,F
....................             x1 += addx; 
0C29:  MOVF   15,W
0C2A:  BCF    03.5
0C2B:  ADDWF  6C,F
....................             y1 += addy; 
0C2C:  BSF    03.5
0C2D:  MOVF   16,W
0C2E:  BCF    03.5
0C2F:  ADDWF  6D,F
....................          } 
0C30:  BSF    03.5
0C31:  INCF   1B,F
0C32:  GOTO   3FE
....................       } 
....................    } 
0C33:  BCF    03.5
0C34:  BCF    03.6
0C35:  RETURN
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
....................       { 
....................          xmin = x1; 
....................          xmax = x2; 
....................       } 
....................       else 
....................       { 
....................          xmin = x2; 
....................          xmax = x1; 
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
....................       { 
....................          ymin = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          ymin = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
....................          { 
....................             glcd_pixel(xmin, i, color); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
0417:  BSF    03.6
0418:  MOVF   6A,W
0419:  MOVWF  7A
041A:  MOVF   69,W
041B:  MOVWF  04
041C:  BCF    03.7
041D:  BTFSC  7A.0
041E:  BSF    03.7
041F:  MOVF   00,F
0420:  BTFSC  03.2
0421:  GOTO   537
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0422:  MOVF   6A,W
0423:  MOVWF  7A
0424:  MOVF   69,W
0425:  MOVWF  04
0426:  BCF    03.7
0427:  BTFSC  7A.0
0428:  BSF    03.7
0429:  MOVF   00,W
042A:  SUBLW  52
042B:  BTFSS  03.0
042C:  GOTO   457
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
042D:  MOVF   6A,W
042E:  MOVWF  7A
042F:  MOVF   69,W
0430:  MOVWF  04
0431:  BCF    03.7
0432:  BTFSC  7A.0
0433:  BSF    03.7
0434:  MOVLW  20
0435:  SUBWF  00,W
0436:  BSF    03.5
0437:  MOVWF  17
0438:  MOVWF  19
0439:  MOVLW  05
043A:  MOVWF  1A
043B:  BCF    03.5
043C:  BCF    03.6
043D:  CALL   2CB
043E:  MOVF   78,W
043F:  BSF    03.5
0440:  BSF    03.6
0441:  MOVWF  16
0442:  MOVWF  78
0443:  MOVLW  05
0444:  MOVWF  77
0445:  MOVLW  91
0446:  MOVWF  04
0447:  BSF    03.7
0448:  MOVF   78,W
0449:  BCF    03.5
044A:  BCF    03.6
044B:  CALL   048
044C:  MOVWF  00
044D:  INCF   78,F
044E:  INCF   04,F
044F:  DECFSZ 77,F
0450:  GOTO   452
0451:  GOTO   455
0452:  BSF    03.5
0453:  BSF    03.6
0454:  GOTO   448
0455:  GOTO   494
0456:  BSF    03.6
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
0457:  MOVF   6A,W
0458:  MOVWF  7A
0459:  MOVF   69,W
045A:  MOVWF  04
045B:  BCF    03.7
045C:  BTFSC  7A.0
045D:  BSF    03.7
045E:  MOVF   00,W
045F:  SUBLW  7E
0460:  BTFSS  03.0
0461:  GOTO   48C
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
0462:  MOVF   6A,W
0463:  MOVWF  7A
0464:  MOVF   69,W
0465:  MOVWF  04
0466:  BCF    03.7
0467:  BTFSC  7A.0
0468:  BSF    03.7
0469:  MOVLW  53
046A:  SUBWF  00,W
046B:  BSF    03.5
046C:  MOVWF  17
046D:  MOVWF  19
046E:  MOVLW  05
046F:  MOVWF  1A
0470:  BCF    03.5
0471:  BCF    03.6
0472:  CALL   2CB
0473:  MOVF   78,W
0474:  BSF    03.5
0475:  BSF    03.6
0476:  MOVWF  16
0477:  MOVWF  78
0478:  MOVLW  05
0479:  MOVWF  77
047A:  MOVLW  91
047B:  MOVWF  04
047C:  BSF    03.7
047D:  MOVF   78,W
047E:  BCF    03.5
047F:  BCF    03.6
0480:  CALL   14E
0481:  MOVWF  00
0482:  INCF   78,F
0483:  INCF   04,F
0484:  DECFSZ 77,F
0485:  GOTO   487
0486:  GOTO   48A
0487:  BSF    03.5
0488:  BSF    03.6
0489:  GOTO   47D
048A:  GOTO   494
048B:  BSF    03.6
....................       else 
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
048C:  BSF    03.5
048D:  CLRF   11
048E:  CLRF   12
048F:  CLRF   13
0490:  CLRF   14
0491:  CLRF   15
0492:  BCF    03.5
0493:  BCF    03.6
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
0494:  BSF    03.6
0495:  MOVF   6A,W
0496:  MOVWF  7A
0497:  MOVF   69,W
0498:  MOVWF  04
0499:  BCF    03.7
049A:  BTFSC  7A.0
049B:  BSF    03.7
049C:  MOVF   00,W
049D:  XORLW  0A
049E:  BCF    03.6
049F:  BTFSC  03.2
04A0:  GOTO   4A5
04A1:  XORLW  07
04A2:  BTFSC  03.2
04A3:  GOTO   4B6
04A4:  GOTO   4BA
....................       { 
....................          case '\n': 
....................             y += 7*size + 1; 
04A5:  MOVLW  07
04A6:  BSF    03.5
04A7:  BSF    03.6
04A8:  MOVWF  19
04A9:  BCF    03.5
04AA:  MOVF   6B,W
04AB:  BSF    03.5
04AC:  MOVWF  1A
04AD:  BCF    03.5
04AE:  BCF    03.6
04AF:  CALL   2CB
04B0:  MOVLW  01
04B1:  ADDWF  78,W
04B2:  BSF    03.6
04B3:  ADDWF  68,F
....................             continue; 
04B4:  GOTO   532
04B5:  BCF    03.6
....................          case '\r': 
....................             x = 0; 
04B6:  BSF    03.6
04B7:  CLRF   67
....................             continue; 
04B8:  GOTO   532
04B9:  BCF    03.6
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
04BA:  MOVLW  05
04BB:  BSF    03.5
04BC:  BSF    03.6
04BD:  MOVWF  19
04BE:  BCF    03.5
04BF:  MOVF   6B,W
04C0:  BSF    03.5
04C1:  MOVWF  1A
04C2:  BCF    03.5
04C3:  BCF    03.6
04C4:  CALL   2CB
04C5:  MOVF   78,W
04C6:  BSF    03.6
04C7:  ADDWF  67,W
04C8:  SUBLW  7F
04C9:  BTFSC  03.0
04CA:  GOTO   4DA
....................       { 
....................          x = 0;                           // Set x at far left position 
04CB:  CLRF   67
....................          y += 7*size + 1;                 // Set y at next position down 
04CC:  MOVLW  07
04CD:  BSF    03.5
04CE:  MOVWF  19
04CF:  BCF    03.5
04D0:  MOVF   6B,W
04D1:  BSF    03.5
04D2:  MOVWF  1A
04D3:  BCF    03.5
04D4:  BCF    03.6
04D5:  CALL   2CB
04D6:  MOVLW  01
04D7:  ADDWF  78,W
04D8:  BSF    03.6
04D9:  ADDWF  68,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
04DA:  CLRF   6D
04DB:  MOVF   6D,W
04DC:  SUBLW  04
04DD:  BTFSS  03.0
04DE:  GOTO   532
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
04DF:  CLRF   6E
04E0:  MOVF   6E,W
04E1:  SUBLW  06
04E2:  BTFSS  03.0
04E3:  GOTO   52E
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
04E4:  MOVLW  91
04E5:  ADDWF  6D,W
04E6:  MOVWF  04
04E7:  BSF    03.7
04E8:  MOVF   00,W
04E9:  BSF    03.5
04EA:  MOVWF  16
04EB:  MOVWF  77
04EC:  BCF    03.5
04ED:  MOVF   6E,W
04EE:  MOVWF  78
04EF:  BTFSC  03.2
04F0:  GOTO   4F5
04F1:  BCF    03.0
04F2:  RRF    77,F
04F3:  DECFSZ 78,F
04F4:  GOTO   4F1
04F5:  BTFSS  77.0
04F6:  GOTO   52C
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
04F7:  CLRF   6F
04F8:  MOVF   6B,W
04F9:  SUBWF  6F,W
04FA:  BTFSC  03.0
04FB:  GOTO   52C
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
04FC:  BSF    03.5
04FD:  CLRF   10
04FE:  BCF    03.5
04FF:  MOVF   6B,W
0500:  BSF    03.5
0501:  SUBWF  10,W
0502:  BTFSC  03.0
0503:  GOTO   529
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0504:  MOVF   10,W
0505:  BCF    03.5
0506:  ADDWF  67,W
0507:  BSF    03.5
0508:  MOVWF  16
0509:  BCF    03.5
050A:  MOVF   6E,W
050B:  BSF    03.5
050C:  MOVWF  19
050D:  BCF    03.5
050E:  MOVF   6B,W
050F:  BSF    03.5
0510:  MOVWF  1A
0511:  BCF    03.5
0512:  BCF    03.6
0513:  CALL   2CB
0514:  MOVF   78,W
0515:  BSF    03.6
0516:  ADDWF  68,W
0517:  ADDWF  6F,W
0518:  BSF    03.5
0519:  MOVWF  17
051A:  MOVF   16,W
051B:  MOVWF  1D
051C:  MOVF   17,W
051D:  MOVWF  1E
051E:  BCF    03.5
051F:  MOVF   6C,W
0520:  BSF    03.5
0521:  MOVWF  1F
0522:  BCF    03.5
0523:  BCF    03.6
0524:  CALL   325
0525:  BSF    03.5
0526:  BSF    03.6
0527:  INCF   10,F
0528:  GOTO   4FE
....................                   } 
0529:  BCF    03.5
052A:  INCF   6F,F
052B:  GOTO   4F8
....................                } 
....................             } 
052C:  INCF   6E,F
052D:  GOTO   4E0
....................          } 
052E:  INCF   6D,F
052F:  MOVF   6B,W
0530:  ADDWF  67,F
0531:  GOTO   4DB
....................       } 
0532:  INCF   69,F
0533:  BTFSC  03.2
0534:  INCF   6A,F
0535:  INCF   67,F
0536:  GOTO   418
....................    } 
0537:  BCF    03.6
0538:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <compof.c> 
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
*
1392:  MOVF   2B,W
1393:  MOVWF  2D
1394:  MOVF   2A,W
1395:  MOVWF  2C
....................    result->size=size; 
1396:  MOVF   2C,W
1397:  MOVWF  04
1398:  BCF    03.7
1399:  BTFSC  2D.0
139A:  BSF    03.7
139B:  MOVF   28,W
139C:  MOVWF  00
....................    result->next = NULL; 
139D:  MOVLW  01
139E:  ADDWF  2C,W
139F:  MOVWF  04
13A0:  BCF    03.7
13A1:  BTFSC  2D.0
13A2:  BSF    03.7
13A3:  INCF   04,F
13A4:  CLRF   00
13A5:  DECF   04,F
13A6:  CLRF   00
....................    return result; 
13A7:  MOVF   2C,W
13A8:  MOVWF  78
13A9:  MOVF   2D,W
13AA:  MOVWF  79
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
*
07D6:  BSF    03.6
07D7:  MOVF   26,W
07D8:  MOVWF  04
07D9:  BCF    03.7
07DA:  BTFSC  27.0
07DB:  BSF    03.7
07DC:  MOVF   28,W
07DD:  MOVWF  00
07DE:  BCF    03.6
07DF:  RETURN
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
*
13B7:  MOVLW  01
13B8:  ADDWF  24,W
13B9:  MOVWF  04
13BA:  BCF    03.7
13BB:  BTFSC  25.0
13BC:  BSF    03.7
13BD:  INCF   04,F
13BE:  MOVF   00,W
13BF:  MOVWF  29
13C0:  DECF   04,F
13C1:  MOVF   00,W
13C2:  MOVWF  28
13C3:  MOVF   28,F
13C4:  BTFSS  03.2
13C5:  GOTO   3D4
13C6:  MOVF   29,F
13C7:  BTFSS  03.2
13C8:  GOTO   3D4
....................        node->next= NULL; 
13C9:  MOVLW  01
13CA:  ADDWF  26,W
13CB:  MOVWF  04
13CC:  BCF    03.7
13CD:  BTFSC  27.0
13CE:  BSF    03.7
13CF:  INCF   04,F
13D0:  CLRF   00
13D1:  DECF   04,F
13D2:  CLRF   00
13D3:  GOTO   3F8
....................     else 
....................        node->next=place->next; 
13D4:  MOVLW  01
13D5:  ADDWF  26,W
13D6:  MOVWF  78
13D7:  MOVF   27,W
13D8:  MOVWF  7A
13D9:  BTFSC  03.0
13DA:  INCF   7A,F
13DB:  MOVF   78,W
13DC:  MOVWF  28
13DD:  MOVF   7A,W
13DE:  MOVWF  29
13DF:  MOVLW  01
13E0:  ADDWF  24,W
13E1:  MOVWF  04
13E2:  BCF    03.7
13E3:  BTFSC  25.0
13E4:  BSF    03.7
13E5:  INCF   04,F
13E6:  MOVF   00,W
13E7:  MOVWF  7A
13E8:  DECF   04,F
13E9:  MOVF   00,W
13EA:  MOVWF  2A
13EB:  MOVF   7A,W
13EC:  MOVWF  2B
13ED:  MOVF   28,W
13EE:  MOVWF  04
13EF:  BCF    03.7
13F0:  BTFSC  29.0
13F1:  BSF    03.7
13F2:  INCF   04,F
13F3:  MOVF   2B,W
13F4:  MOVWF  00
13F5:  DECF   04,F
13F6:  MOVF   2A,W
13F7:  MOVWF  00
....................     place->next=node; 
13F8:  MOVLW  01
13F9:  ADDWF  24,W
13FA:  MOVWF  04
13FB:  BCF    03.7
13FC:  BTFSC  25.0
13FD:  BSF    03.7
13FE:  INCF   04,F
13FF:  MOVF   27,W
1400:  MOVWF  00
1401:  DECF   04,F
1402:  MOVF   26,W
1403:  MOVWF  00
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
*
133E:  BCF    03.6
133F:  MOVF   2A,W
1340:  BSF    03.6
1341:  MOVWF  1F
1342:  BCF    03.6
1343:  MOVF   29,W
1344:  BSF    03.6
1345:  MOVWF  1E
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
1346:  MOVF   1E,F
1347:  BTFSS  03.2
1348:  GOTO   34C
1349:  MOVF   1F,F
134A:  BTFSC  03.2
134B:  GOTO   436
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
134C:  MOVF   1E,W
134D:  MOVWF  04
134E:  BCF    03.7
134F:  BTFSC  1F.0
1350:  BSF    03.7
1351:  MOVF   00,W
1352:  MOVWF  24
1353:  BTFSC  24.7
1354:  GOTO   429
1355:  MOVF   1E,W
1356:  MOVWF  04
1357:  BCF    03.7
1358:  BTFSC  1F.0
1359:  BSF    03.7
135A:  MOVF   1D,W
135B:  SUBWF  00,W
135C:  BTFSS  03.0
135D:  GOTO   429
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
135E:  MOVF   1E,W
135F:  MOVWF  04
1360:  BCF    03.7
1361:  BTFSC  1F.0
1362:  BSF    03.7
1363:  CLRF   23
1364:  MOVF   00,W
1365:  MOVWF  22
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
1366:  MOVLW  03
1367:  ADDWF  1D,W
1368:  MOVF   23,F
1369:  BTFSS  03.2
136A:  GOTO   370
136B:  SUBWF  22,W
136C:  BTFSC  03.2
136D:  GOTO   414
136E:  BTFSS  03.0
136F:  GOTO   414
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
1370:  MOVF   1D,W
1371:  SUBWF  22,W
1372:  MOVWF  24
1373:  MOVF   23,W
1374:  MOVWF  25
1375:  MOVLW  00
1376:  BTFSS  03.0
1377:  MOVLW  01
1378:  SUBWF  25,F
1379:  MOVLW  03
137A:  SUBWF  24,F
137B:  MOVLW  00
137C:  BTFSS  03.0
137D:  MOVLW  01
137E:  SUBWF  25,F
137F:  MOVLW  03
1380:  ADDWF  1E,W
1381:  MOVWF  26
1382:  MOVF   1F,W
1383:  MOVWF  27
1384:  BTFSC  03.0
1385:  INCF   27,F
1386:  MOVF   1D,W
1387:  ADDWF  26,F
1388:  BTFSC  03.0
1389:  INCF   27,F
138A:  MOVF   25,W
138B:  MOVWF  29
138C:  MOVF   24,W
138D:  MOVWF  28
138E:  MOVF   27,W
138F:  MOVWF  2B
1390:  MOVF   26,W
1391:  MOVWF  2A
*
13AB:  MOVF   79,W
13AC:  MOVWF  21
13AD:  MOVF   78,W
13AE:  MOVWF  20
....................             insert_node_after(node,new); 
13AF:  MOVF   1F,W
13B0:  MOVWF  25
13B1:  MOVF   1E,W
13B2:  MOVWF  24
13B3:  MOVF   21,W
13B4:  MOVWF  27
13B5:  MOVF   20,W
13B6:  MOVWF  26
....................             update_node(node,size+_MEMMGMT_CSIZE); 
*
1404:  MOVLW  7F
1405:  ADDWF  1D,W
1406:  MOVWF  24
1407:  MOVF   1F,W
1408:  MOVWF  27
1409:  MOVF   1E,W
140A:  MOVWF  26
140B:  CLRF   29
140C:  MOVF   24,W
140D:  MOVWF  28
140E:  BCF    0A.4
140F:  BCF    03.6
1410:  CALL   7D6
1411:  BSF    0A.4
....................          } 
1412:  GOTO   427
1413:  BSF    03.6
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
1414:  MOVLW  7F
1415:  ADDWF  22,W
1416:  MOVWF  24
1417:  MOVF   23,W
1418:  MOVWF  25
1419:  BTFSC  03.0
141A:  INCF   25,F
141B:  MOVF   1F,W
141C:  MOVWF  27
141D:  MOVF   1E,W
141E:  MOVWF  26
141F:  MOVF   25,W
1420:  MOVWF  29
1421:  MOVF   24,W
1422:  MOVWF  28
1423:  BCF    0A.4
1424:  BCF    03.6
1425:  CALL   7D6
1426:  BSF    0A.4
....................          //end if 
....................          break; 
1427:  BSF    03.6
1428:  GOTO   436
....................       }//end if 
....................       node=node->next; 
1429:  MOVLW  01
142A:  ADDWF  1E,W
142B:  MOVWF  04
142C:  BCF    03.7
142D:  BTFSC  1F.0
142E:  BSF    03.7
142F:  INCF   04,F
1430:  MOVF   00,W
1431:  MOVWF  1F
1432:  DECF   04,F
1433:  MOVF   00,W
1434:  MOVWF  1E
1435:  GOTO   346
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
1436:  MOVF   1E,F
1437:  BTFSS  03.2
1438:  GOTO   441
1439:  MOVF   1F,F
143A:  BTFSS  03.2
143B:  GOTO   441
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
143C:  MOVLW  00
143D:  MOVWF  78
143E:  MOVWF  79
143F:  GOTO   44A
....................    } 
1440:  GOTO   44A
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
1441:  MOVLW  03
1442:  ADDWF  1E,W
1443:  MOVWF  78
1444:  MOVF   1F,W
1445:  MOVWF  7A
1446:  BTFSC  03.0
1447:  INCF   7A,F
1448:  MOVF   7A,W
1449:  MOVWF  79
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
182E:  CLRF   2B
182F:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define SEP '\n' 
.................... #define END '\0' 
....................  
.................... struct SERIAL_LIB { 
....................     char* sSerial; 
.................... }; typedef struct SERIAL_LIB SERIALsr; 
....................  
.................... SERIALsr serialData; 
.................... char str[9] = "\0"; 
1830:  CLRF   2F
1831:  CLRF   30
....................  
.................... // SEND SYSTEM 
.................... void set_SERIALsr() { 
....................     serialData.sSerial = malloc(sizeof(char)); 
*
133B:  MOVLW  01
133C:  BSF    03.6
133D:  MOVWF  1D
*
144A:  MOVF   79,W
144B:  BCF    03.6
144C:  MOVWF  2E
144D:  MOVF   78,W
144E:  MOVWF  2D
144F:  BSF    0A.3
1450:  BSF    0A.4
1451:  GOTO   168 (RETURN)
.................... } 
.................... void sendFT(char t , float v, char a) { 
....................     sprintf(str, "%c%f%c", t, v, a); 
....................     for(int i = 0; str[i] != a; i++) 
....................         printf("%c", str[i]); 
....................     printf("%c", a); 
.................... } 
.................... void sendINT(char t , int v, char a) { 
....................     sprintf(str, "%c%d%c", t, v, a); 
*
0EEF:  CLRF   39
0EF0:  MOVLW  2F
0EF1:  MOVWF  38
0EF2:  CLRF   27
0EF3:  BTFSC  0B.7
0EF4:  BSF    27.7
0EF5:  BCF    0B.7
0EF6:  BSF    03.6
0EF7:  MOVF   1D,W
0EF8:  BSF    03.5
0EF9:  MOVWF  19
0EFA:  BCF    0A.3
0EFB:  BCF    03.5
0EFC:  BCF    03.6
0EFD:  CALL   628
0EFE:  BSF    0A.3
0EFF:  BTFSC  27.7
0F00:  BSF    0B.7
0F01:  BSF    03.6
0F02:  MOVF   1E,W
0F03:  MOVWF  21
0F04:  MOVLW  18
0F05:  MOVWF  22
*
0F9F:  BSF    03.6
0FA0:  MOVF   1F,W
0FA1:  BSF    03.5
0FA2:  MOVWF  19
0FA3:  BCF    0A.3
0FA4:  BCF    03.5
0FA5:  BCF    03.6
0FA6:  CALL   628
0FA7:  BSF    0A.3
0FA8:  BTFSC  27.7
0FA9:  BSF    0B.7
....................     for(int i = 0; str[i] != a; i++) 
0FAA:  BSF    03.6
0FAB:  CLRF   20
0FAC:  MOVLW  2F
0FAD:  ADDWF  20,W
0FAE:  MOVWF  04
0FAF:  BCF    03.7
0FB0:  MOVF   1F,W
0FB1:  SUBWF  00,W
0FB2:  BTFSC  03.2
0FB3:  GOTO   7C1
....................         printf("%c", str[i]); 
0FB4:  MOVLW  2F
0FB5:  ADDWF  20,W
0FB6:  MOVWF  04
0FB7:  BCF    03.7
0FB8:  MOVF   00,W
0FB9:  MOVWF  21
0FBA:  BCF    03.6
0FBB:  BTFSS  0C.4
0FBC:  GOTO   7BB
0FBD:  MOVWF  19
0FBE:  BSF    03.6
0FBF:  INCF   20,F
0FC0:  GOTO   7AC
....................     printf("%c", a); 
0FC1:  MOVF   1F,W
0FC2:  BCF    03.6
0FC3:  BTFSS  0C.4
0FC4:  GOTO   7C3
0FC5:  MOVWF  19
0FC6:  BSF    0A.3
0FC7:  BSF    0A.4
0FC8:  GOTO   215 (RETURN)
.................... } 
.................... void sendSTR(char t , char v[], char a) { 
....................     sprintf(str, "%c%s%c", t, v, a); 
....................         for(int i = 0; str[i] != a; i++) 
....................             printf("%c", str[i]); 
....................     printf("%c", a); 
.................... } 
.................... void sendDATA(char s_[], char a) { 
....................      for(int i = 0; s_[i] != a; i++) 
....................          printf("%c", s_[i]); 
....................     printf("%c", a); 
.................... } 
.................... // END SEND SYSTEM 
.................... // READ SERIAL 
.................... int getArrSize() { return strlen(serialData.sSerial); } 
.................... int insert(char c_) { 
....................     int i = 0; 
....................     serialData.sSerial = realloc(serialData.sSerial, sizeof(char)*(i + 1)); 
....................     if(serialData.sSerial != NULL) { 
....................         i++; 
....................         *(serialData.sSerial + getArrSize() - 1) = c_; 
....................         return TRUE; 
....................     } return FALSE; 
.................... } 
.................... char* getSTR() { return serialData.sSerial; } 
.................... // END READ SERIAL 
....................  
....................  
.................... #byte trisb=0x86 
....................  
.................... ///Defines 
....................  
.................... #define escala -2 //Escala negativa para que crezca hacia arriba. 
.................... #define limpiarGrafico limpiarPorcion(0,20,128,44) //Limpia el area del grafico 
.................... #define offset 120 //es el offset para la altura de la grafica 
.................... #define TMR1 0x0BDC //Este es el valor para 500ms en el timer1 (0,5s=(4/4000000)8(65536-TMR1))=>TMR1=3036 
.................... #define TMR0 0x40 //Este es el valor para 50ms en el timer0 
.................... #define nMediciones 80 //Numero de mediciones 
....................  
.................... ///Fin Defines 
....................  
.................... ///Variables Globales 
....................  
.................... int x=0; //Posicion inicial de x para graficar la temperatura 
.................... float y; //Temperatura anterior 
.................... float t; //Temperatura actual 
.................... int16 iAn; //Lectura del sensor de temperatura 
.................... int registro[nMediciones]; //registro de las ultimas nMediciones mediciones 
.................... int1 habilitarLectura=0; //Variable para habilitar o deshabilitar la captura de datos del sensor 
.................... int ciclos=10; //Variable que cuenta los ciclos que debe hacer el timer0 antes de ejecutar su codigo 
.................... int ciclosT1=6; //Variable que cuenta los ciclos que debe hacer el timer1 antes de ejecutar su codigo 
.................... short int btST = 1; 
.................... char r_; 
.................... ///Fin Variables Globales 
....................  
.................... ///Funciones 
....................  
.................... void limpiarPorcion(int x1, int y1, int x2, int y2){ //(x1, y1) = posición del primer pixel. (x2, y2) = cantididad de pixeles hacia la derecha y hacia abajo 
....................    for(int i=x1;i<x1+x2;i++) 
*
0C45:  MOVF   6A,W
0C46:  MOVWF  6E
0C47:  MOVF   6C,W
0C48:  ADDWF  6A,W
0C49:  SUBWF  6E,W
0C4A:  BTFSC  03.0
0C4B:  GOTO   465
*
10A7:  MOVF   6A,W
10A8:  MOVWF  6E
10A9:  MOVF   6C,W
10AA:  ADDWF  6A,W
10AB:  SUBWF  6E,W
10AC:  BTFSC  03.0
10AD:  GOTO   0C7
....................       for(int j=y1;j<y1+y2;j++) 
*
0C4C:  MOVF   6B,W
0C4D:  MOVWF  6F
0C4E:  MOVF   6D,W
0C4F:  ADDWF  6B,W
0C50:  SUBWF  6F,W
0C51:  BTFSC  03.0
0C52:  GOTO   463
*
10AE:  MOVF   6B,W
10AF:  MOVWF  6F
10B0:  MOVF   6D,W
10B1:  ADDWF  6B,W
10B2:  SUBWF  6F,W
10B3:  BTFSC  03.0
10B4:  GOTO   0C5
....................          glcd_pixel(i, j, OFF); //Apagamos el pixel. 
*
0C53:  MOVF   6E,W
0C54:  BSF    03.5
0C55:  MOVWF  1D
0C56:  BCF    03.5
0C57:  MOVF   6F,W
0C58:  BSF    03.5
0C59:  MOVWF  1E
0C5A:  CLRF   1F
0C5B:  BCF    0A.3
0C5C:  BCF    03.5
0C5D:  BCF    03.6
0C5E:  CALL   325
0C5F:  BSF    0A.3
0C60:  BSF    03.6
0C61:  INCF   6F,F
0C62:  GOTO   44E
0C63:  INCF   6E,F
0C64:  GOTO   447
*
10B5:  MOVF   6E,W
10B6:  BSF    03.5
10B7:  MOVWF  1D
10B8:  BCF    03.5
10B9:  MOVF   6F,W
10BA:  BSF    03.5
10BB:  MOVWF  1E
10BC:  CLRF   1F
10BD:  BCF    0A.4
10BE:  BCF    03.5
10BF:  BCF    03.6
10C0:  CALL   325
10C1:  BSF    0A.4
10C2:  BSF    03.6
10C3:  INCF   6F,F
10C4:  GOTO   0B0
10C5:  INCF   6E,F
10C6:  GOTO   0A9
.................... } 
....................  
.................... void nuevaLinea(float temp){ //Funcion para graficar las nuevas lineas de temperatura 
*
0C36:  MOVLW  01
0C37:  ADDWF  3A,W
0C38:  BSF    03.6
0C39:  MOVWF  69
....................    int x1=x+1; 
....................    if(x1>=128){ //Revisamos si sobrepasamos el tamaño de la pantalla 
0C3A:  MOVF   69,W
0C3B:  SUBLW  7F
0C3C:  BTFSC  03.0
0C3D:  GOTO   46A
....................       limpiarGrafico; //Limpiamos el area del grafico 
0C3E:  CLRF   6A
0C3F:  MOVLW  14
0C40:  MOVWF  6B
0C41:  MOVLW  80
0C42:  MOVWF  6C
0C43:  MOVLW  2C
0C44:  MOVWF  6D
....................       x=0; 
*
0C65:  BCF    03.6
0C66:  CLRF   3A
....................       x1=1; 
0C67:  MOVLW  01
0C68:  BSF    03.6
0C69:  MOVWF  69
....................    } 
....................    glcd_line(x, (y*escala)+offset, x1, (temp*escala)+offset, ON);   //multiplicamos por la escala para que la grafica entre en el area del grafico. El offset esta explicado arriba 
0C6A:  BCF    03.6
0C6B:  MOVF   3E,W
0C6C:  BSF    03.5
0C6D:  BSF    03.6
0C6E:  MOVWF  1C
0C6F:  BCF    03.5
0C70:  BCF    03.6
0C71:  MOVF   3D,W
0C72:  BSF    03.5
0C73:  BSF    03.6
0C74:  MOVWF  1B
0C75:  BCF    03.5
0C76:  BCF    03.6
0C77:  MOVF   3C,W
0C78:  BSF    03.5
0C79:  BSF    03.6
0C7A:  MOVWF  1A
0C7B:  BCF    03.5
0C7C:  BCF    03.6
0C7D:  MOVF   3B,W
0C7E:  BSF    03.5
0C7F:  BSF    03.6
0C80:  MOVWF  19
0C81:  CLRF   20
0C82:  CLRF   1F
0C83:  MOVLW  80
0C84:  MOVWF  1E
0C85:  MOVWF  1D
0C86:  BCF    0A.3
0C87:  BCF    03.5
0C88:  BCF    03.6
0C89:  CALL   539
0C8A:  BSF    0A.3
0C8B:  MOVF   7A,W
0C8C:  BSF    03.6
0C8D:  MOVWF  6D
0C8E:  MOVF   79,W
0C8F:  MOVWF  6C
0C90:  MOVF   78,W
0C91:  MOVWF  6B
0C92:  MOVF   77,W
0C93:  MOVWF  6A
0C94:  BCF    03.1
0C95:  MOVF   6D,W
0C96:  BSF    03.5
0C97:  MOVWF  13
0C98:  BCF    03.5
0C99:  MOVF   6C,W
0C9A:  BSF    03.5
0C9B:  MOVWF  12
0C9C:  BCF    03.5
0C9D:  MOVF   6B,W
0C9E:  BSF    03.5
0C9F:  MOVWF  11
0CA0:  BCF    03.5
0CA1:  MOVF   6A,W
0CA2:  BSF    03.5
0CA3:  MOVWF  10
0CA4:  CLRF   17
0CA5:  CLRF   16
0CA6:  MOVLW  70
0CA7:  MOVWF  15
0CA8:  MOVLW  85
0CA9:  MOVWF  14
0CAA:  BCF    03.5
0CAB:  BCF    03.6
0CAC:  CALL   20E
0CAD:  MOVF   7A,W
0CAE:  BSF    03.6
0CAF:  MOVWF  6E
0CB0:  MOVF   79,W
0CB1:  MOVWF  6D
0CB2:  MOVF   78,W
0CB3:  MOVWF  6C
0CB4:  MOVF   77,W
0CB5:  MOVWF  6B
0CB6:  BCF    0A.3
0CB7:  BCF    03.6
0CB8:  CALL   7B5
0CB9:  BSF    0A.3
0CBA:  MOVF   78,W
0CBB:  BSF    03.6
0CBC:  MOVWF  6A
0CBD:  MOVF   68,W
0CBE:  BSF    03.5
0CBF:  MOVWF  1C
0CC0:  BCF    03.5
0CC1:  MOVF   67,W
0CC2:  BSF    03.5
0CC3:  MOVWF  1B
0CC4:  BCF    03.5
0CC5:  MOVF   66,W
0CC6:  BSF    03.5
0CC7:  MOVWF  1A
0CC8:  BCF    03.5
0CC9:  MOVF   65,W
0CCA:  BSF    03.5
0CCB:  MOVWF  19
0CCC:  CLRF   20
0CCD:  CLRF   1F
0CCE:  MOVLW  80
0CCF:  MOVWF  1E
0CD0:  MOVWF  1D
0CD1:  BCF    0A.3
0CD2:  BCF    03.5
0CD3:  BCF    03.6
0CD4:  CALL   539
0CD5:  BSF    0A.3
0CD6:  MOVF   7A,W
0CD7:  BSF    03.6
0CD8:  MOVWF  6E
0CD9:  MOVF   79,W
0CDA:  MOVWF  6D
0CDB:  MOVF   78,W
0CDC:  MOVWF  6C
0CDD:  MOVF   77,W
0CDE:  MOVWF  6B
0CDF:  BCF    03.1
0CE0:  MOVF   6E,W
0CE1:  BSF    03.5
0CE2:  MOVWF  13
0CE3:  BCF    03.5
0CE4:  MOVF   6D,W
0CE5:  BSF    03.5
0CE6:  MOVWF  12
0CE7:  BCF    03.5
0CE8:  MOVF   6C,W
0CE9:  BSF    03.5
0CEA:  MOVWF  11
0CEB:  BCF    03.5
0CEC:  MOVF   6B,W
0CED:  BSF    03.5
0CEE:  MOVWF  10
0CEF:  CLRF   17
0CF0:  CLRF   16
0CF1:  MOVLW  70
0CF2:  MOVWF  15
0CF3:  MOVLW  85
0CF4:  MOVWF  14
0CF5:  BCF    03.5
0CF6:  BCF    03.6
0CF7:  CALL   20E
0CF8:  MOVF   7A,W
0CF9:  BSF    03.6
0CFA:  MOVWF  6E
0CFB:  MOVF   79,W
0CFC:  MOVWF  6D
0CFD:  MOVF   78,W
0CFE:  MOVWF  6C
0CFF:  MOVF   77,W
0D00:  MOVWF  6B
0D01:  BCF    0A.3
0D02:  BCF    03.6
0D03:  CALL   7B5
0D04:  BSF    0A.3
0D05:  MOVF   78,W
0D06:  BSF    03.6
0D07:  MOVWF  6B
0D08:  BCF    03.6
0D09:  MOVF   3A,W
0D0A:  BSF    03.6
0D0B:  MOVWF  6C
0D0C:  MOVF   6A,W
0D0D:  MOVWF  6D
0D0E:  MOVF   69,W
0D0F:  MOVWF  6E
0D10:  MOVF   6B,W
0D11:  MOVWF  6F
0D12:  MOVLW  01
0D13:  BSF    03.5
0D14:  MOVWF  10
0D15:  BCF    03.5
0D16:  BCF    03.6
0D17:  CALL   358
....................    y=temp; 
0D18:  BSF    03.6
0D19:  MOVF   68,W
0D1A:  BCF    03.6
0D1B:  MOVWF  3E
0D1C:  BSF    03.6
0D1D:  MOVF   67,W
0D1E:  BCF    03.6
0D1F:  MOVWF  3D
0D20:  BSF    03.6
0D21:  MOVF   66,W
0D22:  BCF    03.6
0D23:  MOVWF  3C
0D24:  BSF    03.6
0D25:  MOVF   65,W
0D26:  BCF    03.6
0D27:  MOVWF  3B
....................    x=x1; 
0D28:  BSF    03.6
0D29:  MOVF   69,W
0D2A:  BCF    03.6
0D2B:  MOVWF  3A
0D2C:  RETURN
.................... } 
.................... void toggleBT(char c_) { 
....................    if(c_ == 'a') { 
*
0D34:  MOVF   3D,W
0D35:  SUBLW  61
0D36:  BTFSS  03.2
0D37:  GOTO   550
....................       btST = !ON; 
0D38:  BCF    03.6
0D39:  BCF    45.1
....................       glcd_text57(110,0,(char*)"BT",1,ON); //Mostramos BT 
0D3A:  MOVLW  42
0D3B:  BSF    03.6
0D3C:  MOVWF  3E
0D3D:  MOVLW  54
0D3E:  MOVWF  3F
0D3F:  CLRF   40
0D40:  MOVLW  6E
0D41:  MOVWF  67
0D42:  CLRF   68
0D43:  MOVLW  01
0D44:  MOVWF  6A
0D45:  MOVLW  3E
0D46:  MOVWF  69
0D47:  MOVLW  01
0D48:  MOVWF  6B
0D49:  MOVWF  6C
0D4A:  BCF    0A.3
0D4B:  BCF    03.6
0D4C:  CALL   417
0D4D:  BSF    0A.3
....................    } 
0D4E:  GOTO   566
0D4F:  BSF    03.6
....................    else { 
....................       btST = !OFF; 
0D50:  BCF    03.6
0D51:  BSF    45.1
....................       glcd_text57(110,0,(char*)"BT",1, OFF); //Apagamos BT 
0D52:  MOVLW  42
0D53:  BSF    03.6
0D54:  MOVWF  41
0D55:  MOVLW  54
0D56:  MOVWF  42
0D57:  CLRF   43
0D58:  MOVLW  6E
0D59:  MOVWF  67
0D5A:  CLRF   68
0D5B:  MOVLW  01
0D5C:  MOVWF  6A
0D5D:  MOVLW  41
0D5E:  MOVWF  69
0D5F:  MOVLW  01
0D60:  MOVWF  6B
0D61:  CLRF   6C
0D62:  BCF    0A.3
0D63:  BCF    03.6
0D64:  CALL   417
0D65:  BSF    0A.3
....................    } 
.................... } 
.................... ///Fin Funciones 
....................  
.................... ///Interrupciones 
....................  
.................... #INT_TIMER0 
.................... void TIMER0_isr(){ //Timer para hacer sonar el buzzer cada 500ms 
....................    ciclos--; 
*
0282:  DECFSZ 46,F
....................    if(ciclos==0){ 
0283:  GOTO   293
....................       ciclos=10; 
0284:  MOVLW  0A
0285:  MOVWF  46
....................       output_low(PIN_B3); 
0286:  BSF    03.5
0287:  BCF    06.3
0288:  BCF    03.5
0289:  BCF    06.3
....................       delay_ms(50); 
028A:  MOVLW  32
028B:  BSF    03.6
028C:  MOVWF  3D
028D:  BCF    03.6
028E:  CALL   26D
....................       output_high(PIN_B3); 
028F:  BSF    03.5
0290:  BCF    06.3
0291:  BCF    03.5
0292:  BSF    06.3
....................    } 
....................    set_timer0(TMR0); 
0293:  MOVLW  40
0294:  MOVWF  01
.................... } 
....................  
0295:  BCF    0B.2
0296:  BCF    0A.3
0297:  BCF    0A.4
0298:  GOTO   02B
.................... #INT_TIMER1 
.................... void TIMER1_isr(){ //Timer para almacenar, en un array, la temepratura actual cada 3 segundos 
....................    ciclosT1--; 
0299:  DECFSZ 47,F
....................    if(ciclosT1==0){ 
029A:  GOTO   2C2
....................       ciclosT1=6; 
029B:  MOVLW  06
029C:  MOVWF  47
....................       //Aca hay que hacer el guardado en sd 
....................       //Con este bloque de codigo guardamos en un array las ultimas N mediciones 
....................       //Las cuales podemos guardar despues donde querramos 
....................       for(int i=0; i<nMediciones-1;i++) 
029D:  BSF    03.6
029E:  CLRF   3D
029F:  MOVF   3D,W
02A0:  SUBLW  4E
02A1:  BTFSS  03.0
02A2:  GOTO   2BD
....................          registro[i]=registro[i+1]; 
02A3:  MOVLW  A0
02A4:  ADDWF  3D,W
02A5:  MOVWF  78
02A6:  CLRF   7A
02A7:  BTFSC  03.0
02A8:  INCF   7A,F
02A9:  MOVF   78,W
02AA:  MOVWF  3E
02AB:  MOVF   7A,W
02AC:  MOVWF  3F
02AD:  MOVLW  01
02AE:  ADDWF  3D,W
02AF:  ADDLW  A0
02B0:  MOVWF  04
02B1:  BCF    03.7
02B2:  MOVF   00,W
02B3:  MOVWF  40
02B4:  MOVF   3E,W
02B5:  MOVWF  04
02B6:  BCF    03.7
02B7:  BTFSC  3F.0
02B8:  BSF    03.7
02B9:  MOVF   40,W
02BA:  MOVWF  00
02BB:  INCF   3D,F
02BC:  GOTO   29F
....................       registro[nMediciones-1]=iAn; 
02BD:  BCF    03.6
02BE:  MOVF   43,W
02BF:  BSF    03.5
02C0:  MOVWF  6F
02C1:  BCF    03.5
....................    } 
....................    set_timer1(TMR1); 
02C2:  CLRF   0E
02C3:  MOVLW  0B
02C4:  MOVWF  0F
02C5:  MOVLW  DC
02C6:  MOVWF  0E
.................... } 
....................  
02C7:  BCF    0C.0
02C8:  BCF    0A.3
02C9:  BCF    0A.4
02CA:  GOTO   02B
.................... #INT_RB 
.................... void RB_isr(){ //Prueba de interrupciones 
....................    if(input(PIN_B6)){ //Habilita o deshabilita la captura de datos 
*
1000:  BSF    03.5
1001:  BSF    06.6
1002:  BCF    03.5
1003:  BTFSS  06.6
1004:  GOTO   189
....................       habilitarLectura=~habilitarLectura; 
1005:  MOVLW  01
1006:  XORWF  45,F
....................       disable_interrupts(INT_TIMER0); 
1007:  BCF    0B.5
....................       if(habilitarLectura){ 
1008:  BTFSS  45.0
1009:  GOTO   063
....................          glcd_text57(128/2-30, 0, (char*)"Capturando", 1, ON); 
100A:  CLRF   78
100B:  MOVLW  0B
100C:  MOVWF  77
100D:  MOVLW  3D
100E:  MOVWF  04
100F:  BSF    03.7
1010:  MOVF   78,W
1011:  BCF    0A.4
1012:  CALL   231
1013:  BSF    0A.4
1014:  MOVWF  00
1015:  INCF   78,F
1016:  INCF   04,F
1017:  DECFSZ 77,F
1018:  GOTO   010
1019:  MOVLW  22
101A:  BSF    03.6
101B:  MOVWF  67
101C:  CLRF   68
101D:  MOVLW  01
101E:  MOVWF  6A
101F:  MOVLW  3D
1020:  MOVWF  69
1021:  MOVLW  01
1022:  MOVWF  6B
1023:  MOVWF  6C
1024:  BCF    0A.4
1025:  BCF    03.6
1026:  CALL   417
1027:  BSF    0A.4
....................          sprintf(str, "%3.2fC", y); 
1028:  CLRF   39
1029:  MOVLW  2F
102A:  MOVWF  38
102B:  MOVLW  02
102C:  MOVWF  04
102D:  MOVF   3E,W
102E:  BSF    03.6
102F:  MOVWF  68
1030:  BCF    03.6
1031:  MOVF   3D,W
1032:  BSF    03.6
1033:  MOVWF  67
1034:  BCF    03.6
1035:  MOVF   3C,W
1036:  BSF    03.6
1037:  MOVWF  66
1038:  BCF    03.6
1039:  MOVF   3B,W
103A:  BSF    03.6
103B:  MOVWF  65
103C:  MOVLW  02
103D:  MOVWF  69
103E:  BCF    0A.4
103F:  BCF    03.6
1040:  CALL   639
1041:  BSF    0A.4
1042:  MOVLW  43
1043:  BSF    03.5
1044:  BSF    03.6
1045:  MOVWF  19
1046:  BCF    0A.4
1047:  BCF    03.5
1048:  BCF    03.6
1049:  CALL   628
104A:  BSF    0A.4
....................          glcd_text57(12*6, 10, str, 1, ON); //Escribimos la temperatura. 
104B:  MOVLW  48
104C:  BSF    03.6
104D:  MOVWF  67
104E:  MOVLW  0A
104F:  MOVWF  68
1050:  CLRF   6A
1051:  MOVLW  2F
1052:  MOVWF  69
1053:  MOVLW  01
1054:  MOVWF  6B
1055:  MOVWF  6C
1056:  BCF    0A.4
1057:  BCF    03.6
1058:  CALL   417
1059:  BSF    0A.4
....................          enable_interrupts(INT_TIMER1); 
105A:  BSF    03.5
105B:  BSF    0C.0
....................          set_timer1(TMR1); 
105C:  BCF    03.5
105D:  CLRF   0E
105E:  MOVLW  0B
105F:  MOVWF  0F
1060:  MOVLW  DC
1061:  MOVWF  0E
....................       } 
1062:  GOTO   189
....................       else { 
....................          glcd_text57(128/2-30, 0, (char*)"Capturando", 1, OFF); 
1063:  CLRF   78
1064:  MOVLW  0B
1065:  MOVWF  77
1066:  MOVLW  48
1067:  MOVWF  04
1068:  BSF    03.7
1069:  MOVF   78,W
106A:  BCF    0A.4
106B:  CALL   231
106C:  BSF    0A.4
106D:  MOVWF  00
106E:  INCF   78,F
106F:  INCF   04,F
1070:  DECFSZ 77,F
1071:  GOTO   069
1072:  MOVLW  22
1073:  BSF    03.6
1074:  MOVWF  67
1075:  CLRF   68
1076:  MOVLW  01
1077:  MOVWF  6A
1078:  MOVLW  48
1079:  MOVWF  69
107A:  MOVLW  01
107B:  MOVWF  6B
107C:  CLRF   6C
107D:  BCF    0A.4
107E:  BCF    03.6
107F:  CALL   417
1080:  BSF    0A.4
....................          glcd_text57(128/2-30, 0, (char*)"Limpiando", 1, ON); 
1081:  CLRF   78
1082:  MOVLW  0A
1083:  MOVWF  77
1084:  MOVLW  48
1085:  MOVWF  04
1086:  BSF    03.7
1087:  MOVF   78,W
1088:  BCF    0A.4
1089:  CALL   240
108A:  BSF    0A.4
108B:  MOVWF  00
108C:  INCF   78,F
108D:  INCF   04,F
108E:  DECFSZ 77,F
108F:  GOTO   087
1090:  MOVLW  22
1091:  BSF    03.6
1092:  MOVWF  67
1093:  CLRF   68
1094:  MOVLW  01
1095:  MOVWF  6A
1096:  MOVLW  48
1097:  MOVWF  69
1098:  MOVLW  01
1099:  MOVWF  6B
109A:  MOVWF  6C
109B:  BCF    0A.4
109C:  BCF    03.6
109D:  CALL   417
109E:  BSF    0A.4
....................          limpiarGrafico; 
109F:  BSF    03.6
10A0:  CLRF   6A
10A1:  MOVLW  14
10A2:  MOVWF  6B
10A3:  MOVLW  80
10A4:  MOVWF  6C
10A5:  MOVLW  2C
10A6:  MOVWF  6D
....................          glcd_text57(128/2-30, 0, (char*)"Limpiando", 1, OFF); 
*
10C7:  CLRF   78
10C8:  MOVLW  0A
10C9:  MOVWF  77
10CA:  MOVLW  48
10CB:  MOVWF  04
10CC:  BSF    03.7
10CD:  MOVF   78,W
10CE:  BCF    0A.4
10CF:  BCF    03.6
10D0:  CALL   240
10D1:  BSF    0A.4
10D2:  MOVWF  00
10D3:  INCF   78,F
10D4:  INCF   04,F
10D5:  DECFSZ 77,F
10D6:  GOTO   0D8
10D7:  GOTO   0DA
10D8:  BSF    03.6
10D9:  GOTO   0CD
10DA:  MOVLW  22
10DB:  BSF    03.6
10DC:  MOVWF  67
10DD:  CLRF   68
10DE:  MOVLW  01
10DF:  MOVWF  6A
10E0:  MOVLW  48
10E1:  MOVWF  69
10E2:  MOVLW  01
10E3:  MOVWF  6B
10E4:  CLRF   6C
10E5:  BCF    0A.4
10E6:  BCF    03.6
10E7:  CALL   417
10E8:  BSF    0A.4
....................          sprintf(str, "%3.2fC", t); 
10E9:  CLRF   39
10EA:  MOVLW  2F
10EB:  MOVWF  38
10EC:  MOVLW  02
10ED:  MOVWF  04
10EE:  MOVF   42,W
10EF:  BSF    03.6
10F0:  MOVWF  68
10F1:  BCF    03.6
10F2:  MOVF   41,W
10F3:  BSF    03.6
10F4:  MOVWF  67
10F5:  BCF    03.6
10F6:  MOVF   40,W
10F7:  BSF    03.6
10F8:  MOVWF  66
10F9:  BCF    03.6
10FA:  MOVF   3F,W
10FB:  BSF    03.6
10FC:  MOVWF  65
10FD:  MOVLW  02
10FE:  MOVWF  69
10FF:  BCF    0A.4
1100:  BCF    03.6
1101:  CALL   639
1102:  BSF    0A.4
1103:  MOVLW  43
1104:  BSF    03.5
1105:  BSF    03.6
1106:  MOVWF  19
1107:  BCF    0A.4
1108:  BCF    03.5
1109:  BCF    03.6
110A:  CALL   628
110B:  BSF    0A.4
....................          glcd_text57(12*6, 10, str, 1, OFF); 
110C:  MOVLW  48
110D:  BSF    03.6
110E:  MOVWF  67
110F:  MOVLW  0A
1110:  MOVWF  68
1111:  CLRF   6A
1112:  MOVLW  2F
1113:  MOVWF  69
1114:  MOVLW  01
1115:  MOVWF  6B
1116:  CLRF   6C
1117:  BCF    0A.4
1118:  BCF    03.6
1119:  CALL   417
111A:  BSF    0A.4
....................          x=0; 
111B:  CLRF   3A
....................          disable_interrupts(INT_TIMER1); 
111C:  BSF    03.5
111D:  BCF    0C.0
....................          glcd_text57(128/2-30, 0, (char*)"Guardando", 1, ON); 
111E:  CLRF   78
111F:  MOVLW  0A
1120:  MOVWF  77
1121:  MOVLW  48
1122:  MOVWF  04
1123:  BSF    03.7
1124:  MOVF   78,W
1125:  BCF    0A.4
1126:  BCF    03.5
1127:  CALL   24E
1128:  BSF    0A.4
1129:  MOVWF  00
112A:  INCF   78,F
112B:  INCF   04,F
112C:  DECFSZ 77,F
112D:  GOTO   12F
112E:  GOTO   131
112F:  BSF    03.5
1130:  GOTO   124
1131:  MOVLW  22
1132:  BSF    03.6
1133:  MOVWF  67
1134:  CLRF   68
1135:  MOVLW  01
1136:  MOVWF  6A
1137:  MOVLW  48
1138:  MOVWF  69
1139:  MOVLW  01
113A:  MOVWF  6B
113B:  MOVWF  6C
113C:  BCF    0A.4
113D:  BCF    03.6
113E:  CALL   417
113F:  BSF    0A.4
....................          for(int pos=0; pos<nMediciones; pos++){ 
1140:  BSF    03.6
1141:  CLRF   53
1142:  MOVF   53,W
1143:  SUBLW  4F
1144:  BTFSS  03.0
1145:  GOTO   167
....................             write_eeprom(pos, registro[pos]); 
1146:  MOVLW  A0
1147:  ADDWF  53,W
1148:  MOVWF  04
1149:  BCF    03.7
114A:  MOVF   00,W
114B:  MOVWF  65
114C:  BCF    03.6
114D:  MOVF   0B,W
114E:  MOVWF  77
114F:  BCF    0B.7
1150:  BSF    03.6
1151:  MOVF   53,W
1152:  MOVWF  0D
1153:  MOVF   65,W
1154:  MOVWF  0C
1155:  BSF    03.5
1156:  BCF    0C.7
1157:  BSF    0C.2
1158:  MOVLW  55
1159:  MOVWF  0D
115A:  MOVLW  AA
115B:  MOVWF  0D
115C:  BSF    0C.1
115D:  BTFSC  0C.1
115E:  GOTO   15D
115F:  BCF    0C.2
1160:  MOVF   77,W
1161:  BCF    03.5
1162:  BCF    03.6
1163:  IORWF  0B,F
1164:  BSF    03.6
1165:  INCF   53,F
1166:  GOTO   142
....................          } 
....................          glcd_text57(128/2-30, 0, (char*)"Guardando", 1, OFF); 
1167:  CLRF   78
1168:  MOVLW  0A
1169:  MOVWF  77
116A:  MOVLW  48
116B:  MOVWF  04
116C:  BSF    03.7
116D:  MOVF   78,W
116E:  BCF    0A.4
116F:  BCF    03.6
1170:  CALL   24E
1171:  BSF    0A.4
1172:  MOVWF  00
1173:  INCF   78,F
1174:  INCF   04,F
1175:  DECFSZ 77,F
1176:  GOTO   178
1177:  GOTO   17A
1178:  BSF    03.6
1179:  GOTO   16D
117A:  MOVLW  22
117B:  BSF    03.6
117C:  MOVWF  67
117D:  CLRF   68
117E:  MOVLW  01
117F:  MOVWF  6A
1180:  MOVLW  48
1181:  MOVWF  69
1182:  MOVLW  01
1183:  MOVWF  6B
1184:  CLRF   6C
1185:  BCF    0A.4
1186:  BCF    03.6
1187:  CALL   417
1188:  BSF    0A.4
....................       } 
....................    } 
....................    if(input(PIN_B7)){ 
1189:  BSF    03.5
118A:  BSF    06.7
118B:  BCF    03.5
118C:  BTFSS  06.7
118D:  GOTO   337
....................       habilitarLectura=0; 
118E:  BCF    45.0
....................       glcd_text57(128/2-30, 0, (char*)"Capturando", 1, OFF); 
118F:  CLRF   78
1190:  MOVLW  0B
1191:  MOVWF  77
1192:  MOVLW  54
1193:  MOVWF  04
1194:  BSF    03.7
1195:  MOVF   78,W
1196:  BCF    0A.4
1197:  CALL   231
1198:  BSF    0A.4
1199:  MOVWF  00
119A:  INCF   78,F
119B:  INCF   04,F
119C:  DECFSZ 77,F
119D:  GOTO   195
119E:  MOVLW  22
119F:  BSF    03.6
11A0:  MOVWF  67
11A1:  CLRF   68
11A2:  MOVLW  01
11A3:  MOVWF  6A
11A4:  MOVLW  54
11A5:  MOVWF  69
11A6:  MOVLW  01
11A7:  MOVWF  6B
11A8:  CLRF   6C
11A9:  BCF    0A.4
11AA:  BCF    03.6
11AB:  CALL   417
11AC:  BSF    0A.4
....................       disable_interrupts(INT_TIMER1); 
11AD:  BSF    03.5
11AE:  BCF    0C.0
....................       disable_interrupts(INT_TIMER0); 
11AF:  BCF    03.5
11B0:  BCF    0B.5
....................       for(int pos=0; pos<nMediciones; pos++){ 
11B1:  BSF    03.6
11B2:  CLRF   5F
11B3:  MOVF   5F,W
11B4:  SUBLW  4F
11B5:  BTFSS  03.0
11B6:  GOTO   2CC
....................          registro[pos]=read_eeprom(pos); 
11B7:  MOVLW  A0
11B8:  ADDWF  5F,W
11B9:  MOVWF  04
11BA:  BCF    03.7
11BB:  MOVF   5F,W
11BC:  MOVWF  0D
11BD:  BSF    03.5
11BE:  BCF    0C.7
11BF:  BSF    0C.0
11C0:  BCF    03.5
11C1:  MOVF   0C,W
11C2:  MOVWF  00
....................          float dato=(5.0*registro[pos]*100.0)/1024.0; 
11C3:  MOVLW  A0
11C4:  ADDWF  5F,W
11C5:  MOVWF  04
11C6:  BCF    03.7
11C7:  MOVF   00,W
11C8:  CLRF   66
11C9:  MOVWF  65
11CA:  BCF    0A.4
11CB:  BCF    03.6
11CC:  CALL   755
11CD:  BSF    0A.4
11CE:  BSF    03.5
11CF:  BSF    03.6
11D0:  CLRF   1C
11D1:  CLRF   1B
11D2:  MOVLW  20
11D3:  MOVWF  1A
11D4:  MOVLW  81
11D5:  MOVWF  19
11D6:  MOVF   7A,W
11D7:  MOVWF  20
11D8:  MOVF   79,W
11D9:  MOVWF  1F
11DA:  MOVF   78,W
11DB:  MOVWF  1E
11DC:  MOVF   77,W
11DD:  MOVWF  1D
11DE:  BCF    0A.4
11DF:  BCF    03.5
11E0:  BCF    03.6
11E1:  CALL   539
11E2:  BSF    0A.4
11E3:  MOVF   7A,W
11E4:  BSF    03.6
11E5:  MOVWF  68
11E6:  MOVF   79,W
11E7:  MOVWF  67
11E8:  MOVF   78,W
11E9:  MOVWF  66
11EA:  MOVF   77,W
11EB:  MOVWF  65
11EC:  MOVF   68,W
11ED:  BSF    03.5
11EE:  MOVWF  1C
11EF:  BCF    03.5
11F0:  MOVF   67,W
11F1:  BSF    03.5
11F2:  MOVWF  1B
11F3:  BCF    03.5
11F4:  MOVF   66,W
11F5:  BSF    03.5
11F6:  MOVWF  1A
11F7:  BCF    03.5
11F8:  MOVF   65,W
11F9:  BSF    03.5
11FA:  MOVWF  19
11FB:  CLRF   20
11FC:  CLRF   1F
11FD:  MOVLW  48
11FE:  MOVWF  1E
11FF:  MOVLW  85
1200:  MOVWF  1D
1201:  BCF    0A.4
1202:  BCF    03.5
1203:  BCF    03.6
1204:  CALL   539
1205:  BSF    0A.4
1206:  MOVF   7A,W
1207:  BSF    03.6
1208:  MOVWF  68
1209:  MOVF   79,W
120A:  MOVWF  67
120B:  MOVF   78,W
120C:  MOVWF  66
120D:  MOVF   77,W
120E:  MOVWF  65
120F:  MOVF   68,W
1210:  MOVWF  6C
1211:  MOVF   67,W
1212:  MOVWF  6B
1213:  MOVF   66,W
1214:  MOVWF  6A
1215:  MOVF   65,W
1216:  MOVWF  69
1217:  BSF    03.5
1218:  CLRF   13
1219:  CLRF   12
121A:  CLRF   11
121B:  MOVLW  89
121C:  MOVWF  10
121D:  BCF    0A.4
121E:  BSF    0A.3
121F:  BCF    03.5
1220:  BCF    03.6
1221:  CALL   000
1222:  BSF    0A.4
1223:  BCF    0A.3
1224:  MOVF   7A,W
1225:  BSF    03.6
1226:  MOVWF  63
1227:  MOVF   79,W
1228:  MOVWF  62
1229:  MOVF   78,W
122A:  MOVWF  61
122B:  MOVF   77,W
122C:  MOVWF  60
....................          printf("%4.2f ",dato); 
122D:  MOVLW  03
122E:  MOVWF  04
122F:  MOVF   63,W
1230:  MOVWF  68
1231:  MOVF   62,W
1232:  MOVWF  67
1233:  MOVF   61,W
1234:  MOVWF  66
1235:  MOVF   60,W
1236:  MOVWF  65
1237:  MOVLW  02
1238:  MOVWF  69
1239:  BCF    0A.4
123A:  BSF    0A.3
123B:  BCF    03.6
123C:  GOTO   0E4
123D:  BSF    0A.4
123E:  BCF    0A.3
123F:  MOVLW  20
1240:  BTFSS  0C.4
1241:  GOTO   240
1242:  MOVWF  19
....................          if(dato>=28 && dato<=50) 
1243:  BSF    03.6
1244:  CLRF   68
1245:  CLRF   67
1246:  MOVLW  60
1247:  MOVWF  66
1248:  MOVLW  83
1249:  MOVWF  65
124A:  MOVF   63,W
124B:  MOVWF  6C
124C:  MOVF   62,W
124D:  MOVWF  6B
124E:  MOVF   61,W
124F:  MOVWF  6A
1250:  MOVF   60,W
1251:  MOVWF  69
1252:  BCF    0A.4
1253:  BCF    03.6
1254:  CALL   774
1255:  BSF    0A.4
1256:  BTFSC  03.0
1257:  GOTO   25A
1258:  BTFSS  03.2
1259:  GOTO   280
125A:  BSF    03.6
125B:  MOVF   63,W
125C:  MOVWF  68
125D:  MOVF   62,W
125E:  MOVWF  67
125F:  MOVF   61,W
1260:  MOVWF  66
1261:  MOVF   60,W
1262:  MOVWF  65
1263:  CLRF   6C
1264:  CLRF   6B
1265:  MOVLW  48
1266:  MOVWF  6A
1267:  MOVLW  84
1268:  MOVWF  69
1269:  BCF    0A.4
126A:  BCF    03.6
126B:  CALL   774
126C:  BSF    0A.4
126D:  BTFSC  03.0
126E:  GOTO   271
126F:  BTFSS  03.2
1270:  GOTO   280
....................             nuevaLinea(dato); 
1271:  BSF    03.6
1272:  MOVF   63,W
1273:  MOVWF  68
1274:  MOVF   62,W
1275:  MOVWF  67
1276:  MOVF   61,W
1277:  MOVWF  66
1278:  MOVF   60,W
1279:  MOVWF  65
127A:  BCF    0A.4
127B:  BSF    0A.3
127C:  BCF    03.6
127D:  CALL   436
127E:  BSF    0A.4
127F:  BCF    0A.3
....................          if(dato<28) 
1280:  BSF    03.6
1281:  MOVF   63,W
1282:  MOVWF  68
1283:  MOVF   62,W
1284:  MOVWF  67
1285:  MOVF   61,W
1286:  MOVWF  66
1287:  MOVF   60,W
1288:  MOVWF  65
1289:  CLRF   6C
128A:  CLRF   6B
128B:  MOVLW  60
128C:  MOVWF  6A
128D:  MOVLW  83
128E:  MOVWF  69
128F:  BCF    0A.4
1290:  BCF    03.6
1291:  CALL   774
1292:  BSF    0A.4
1293:  BTFSS  03.0
1294:  GOTO   2A2
....................             nuevaLinea(29); 
1295:  BSF    03.6
1296:  CLRF   68
1297:  CLRF   67
1298:  MOVLW  68
1299:  MOVWF  66
129A:  MOVLW  83
129B:  MOVWF  65
129C:  BCF    0A.4
129D:  BSF    0A.3
129E:  BCF    03.6
129F:  CALL   436
12A0:  BSF    0A.4
12A1:  BCF    0A.3
....................          if(dato>50) 
12A2:  BSF    03.6
12A3:  CLRF   68
12A4:  CLRF   67
12A5:  MOVLW  48
12A6:  MOVWF  66
12A7:  MOVLW  84
12A8:  MOVWF  65
12A9:  MOVF   63,W
12AA:  MOVWF  6C
12AB:  MOVF   62,W
12AC:  MOVWF  6B
12AD:  MOVF   61,W
12AE:  MOVWF  6A
12AF:  MOVF   60,W
12B0:  MOVWF  69
12B1:  BCF    0A.4
12B2:  BCF    03.6
12B3:  CALL   774
12B4:  BSF    0A.4
12B5:  BTFSS  03.0
12B6:  GOTO   2C4
....................             nuevaLinea(50); 
12B7:  BSF    03.6
12B8:  CLRF   68
12B9:  CLRF   67
12BA:  MOVLW  48
12BB:  MOVWF  66
12BC:  MOVLW  84
12BD:  MOVWF  65
12BE:  BCF    0A.4
12BF:  BSF    0A.3
12C0:  BCF    03.6
12C1:  CALL   436
12C2:  BSF    0A.4
12C3:  BCF    0A.3
....................          registro[pos]=0; 
12C4:  MOVLW  A0
12C5:  BSF    03.6
12C6:  ADDWF  5F,W
12C7:  MOVWF  04
12C8:  BCF    03.7
12C9:  CLRF   00
12CA:  INCF   5F,F
12CB:  GOTO   1B3
....................       } 
....................       glcd_text57(128/2-30, 0, (char*)"Guardando", 1, ON); 
12CC:  CLRF   78
12CD:  MOVLW  0A
12CE:  MOVWF  77
12CF:  MOVLW  54
12D0:  MOVWF  04
12D1:  BSF    03.7
12D2:  MOVF   78,W
12D3:  BCF    0A.4
12D4:  BCF    03.6
12D5:  CALL   24E
12D6:  BSF    0A.4
12D7:  MOVWF  00
12D8:  INCF   78,F
12D9:  INCF   04,F
12DA:  DECFSZ 77,F
12DB:  GOTO   2DD
12DC:  GOTO   2DF
12DD:  BSF    03.6
12DE:  GOTO   2D2
12DF:  MOVLW  22
12E0:  BSF    03.6
12E1:  MOVWF  67
12E2:  CLRF   68
12E3:  MOVLW  01
12E4:  MOVWF  6A
12E5:  MOVLW  54
12E6:  MOVWF  69
12E7:  MOVLW  01
12E8:  MOVWF  6B
12E9:  MOVWF  6C
12EA:  BCF    0A.4
12EB:  BCF    03.6
12EC:  CALL   417
12ED:  BSF    0A.4
....................       for(int pos=0; pos<nMediciones; pos++){ 
12EE:  BSF    03.6
12EF:  CLRF   64
12F0:  MOVF   64,W
12F1:  SUBLW  4F
12F2:  BTFSS  03.0
12F3:  GOTO   315
....................          write_eeprom(pos, registro[pos]); 
12F4:  MOVLW  A0
12F5:  ADDWF  64,W
12F6:  MOVWF  04
12F7:  BCF    03.7
12F8:  MOVF   00,W
12F9:  MOVWF  65
12FA:  BCF    03.6
12FB:  MOVF   0B,W
12FC:  MOVWF  77
12FD:  BCF    0B.7
12FE:  BSF    03.6
12FF:  MOVF   64,W
1300:  MOVWF  0D
1301:  MOVF   65,W
1302:  MOVWF  0C
1303:  BSF    03.5
1304:  BCF    0C.7
1305:  BSF    0C.2
1306:  MOVLW  55
1307:  MOVWF  0D
1308:  MOVLW  AA
1309:  MOVWF  0D
130A:  BSF    0C.1
130B:  BTFSC  0C.1
130C:  GOTO   30B
130D:  BCF    0C.2
130E:  MOVF   77,W
130F:  BCF    03.5
1310:  BCF    03.6
1311:  IORWF  0B,F
1312:  BSF    03.6
1313:  INCF   64,F
1314:  GOTO   2F0
....................       } 
....................       glcd_text57(128/2-30, 0, (char*)"Guardando", 1, OFF); 
1315:  CLRF   78
1316:  MOVLW  0A
1317:  MOVWF  77
1318:  MOVLW  54
1319:  MOVWF  04
131A:  BSF    03.7
131B:  MOVF   78,W
131C:  BCF    0A.4
131D:  BCF    03.6
131E:  CALL   24E
131F:  BSF    0A.4
1320:  MOVWF  00
1321:  INCF   78,F
1322:  INCF   04,F
1323:  DECFSZ 77,F
1324:  GOTO   326
1325:  GOTO   328
1326:  BSF    03.6
1327:  GOTO   31B
1328:  MOVLW  22
1329:  BSF    03.6
132A:  MOVWF  67
132B:  CLRF   68
132C:  MOVLW  01
132D:  MOVWF  6A
132E:  MOVLW  54
132F:  MOVWF  69
1330:  MOVLW  01
1331:  MOVWF  6B
1332:  CLRF   6C
1333:  BCF    0A.4
1334:  BCF    03.6
1335:  CALL   417
1336:  BSF    0A.4
....................    } 
.................... } 
....................  
1337:  BCF    0B.0
1338:  BCF    0A.3
1339:  BCF    0A.4
133A:  GOTO   02B
.................... #INT_RDA 
.................... void serial_interrupt() { 
....................    r_ = getc(); 
*
0D2D:  BTFSS  0C.5
0D2E:  GOTO   52D
0D2F:  MOVF   1A,W
0D30:  MOVWF  48
....................    toggleBT(r_); 
0D31:  MOVF   48,W
0D32:  BSF    03.6
0D33:  MOVWF  3D
*
0D66:  BCF    0C.5
0D67:  BCF    0A.3
0D68:  BCF    0A.4
0D69:  GOTO   02B
.................... } 
....................  
.................... ///Fin Interrupciones 
....................  
.................... void main() 
*
1800:  MOVF   03,W
1801:  ANDLW  1F
1802:  MOVWF  03
1803:  MOVLW  19
1804:  BSF    03.5
1805:  MOVWF  19
1806:  MOVLW  A6
1807:  MOVWF  18
1808:  MOVLW  90
1809:  BCF    03.5
180A:  MOVWF  18
180B:  MOVLW  FF
180C:  MOVWF  28
180D:  CLRF   39
180E:  CLRF   38
180F:  CLRF   3A
1810:  BCF    45.0
1811:  MOVLW  0A
1812:  MOVWF  46
1813:  MOVLW  06
1814:  MOVWF  47
1815:  BSF    45.1
1816:  BSF    03.5
1817:  BSF    1F.0
1818:  BSF    1F.1
1819:  BSF    1F.2
181A:  BCF    1F.3
181B:  BCF    03.5
181C:  CLRF   2A
181D:  MOVLW  49
181E:  MOVWF  29
181F:  MOVLW  2B
1820:  MOVWF  49
1821:  MOVLW  01
1822:  MOVWF  4B
1823:  MOVLW  A6
1824:  MOVWF  4A
1825:  MOVLW  47
1826:  BSF    03.5
1827:  BSF    03.6
1828:  MOVWF  26
1829:  CLRF   28
182A:  CLRF   27
182B:  BCF    03.5
182C:  BCF    03.6
182D:  BCF    03.7
.................... { 
....................    trisb=0b01000000; 
*
1832:  MOVLW  40
1833:  BSF    03.5
1834:  MOVWF  06
....................     
....................    setup_adc_ports(AN0); //seteamos el pin A0 como analogico 
1835:  BCF    1F.0
1836:  BSF    1F.1
1837:  BSF    1F.2
1838:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); //Establecemos el reloj interno 
1839:  BCF    03.5
183A:  BSF    1F.6
183B:  BSF    1F.7
183C:  BSF    03.5
183D:  BSF    1F.7
183E:  BCF    03.5
183F:  BSF    1F.0
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); //setup del timer0 
1840:  BSF    03.5
1841:  MOVF   01,W
1842:  ANDLW  C0
1843:  IORLW  07
1844:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //setup del timer1 
1845:  MOVLW  B5
1846:  BCF    03.5
1847:  MOVWF  10
....................    set_timer0(TMR0); //seteamos el timer0 
1848:  MOVLW  40
1849:  MOVWF  01
....................    set_timer1(TMR1); //setemaos el timer1 
184A:  CLRF   0E
184B:  MOVLW  0B
184C:  MOVWF  0F
184D:  MOVLW  DC
184E:  MOVWF  0E
....................     
....................    glcd_init(ON); //Inicializamos el lcd 
184F:  MOVLW  01
1850:  BSF    03.6
1851:  MOVWF  1D
1852:  BCF    0A.4
1853:  BCF    03.6
1854:  GOTO   56A
1855:  BSF    0A.4
....................     
....................    enable_interrupts(INT_RB); //Habilitamos las interrupciones del RB4-7 
1856:  BSF    0B.3
....................    enable_interrupts(INT_RDA);//Habilitamos las interrupciones del RDA 
1857:  BSF    03.5
1858:  BSF    0C.5
....................    enable_interrupts(GLOBAL); //Habilitamos las interrupciones globales 
1859:  MOVLW  C0
185A:  BCF    03.5
185B:  IORWF  0B,F
....................  
....................    glcd_text57(0,10,(char*)"Temperatura:",1,ON); //Escribimos el texto "Tempreatura:" en la posicion 0,10 
185C:  CLRF   78
185D:  MOVLW  0D
185E:  MOVWF  77
185F:  MOVLW  10
1860:  MOVWF  04
1861:  BSF    03.7
1862:  MOVF   78,W
1863:  BCF    0A.4
1864:  BCF    0A.3
1865:  CALL   25C
1866:  BSF    0A.4
1867:  BSF    0A.3
1868:  MOVWF  00
1869:  INCF   78,F
186A:  INCF   04,F
186B:  DECFSZ 77,F
186C:  GOTO   062
186D:  CLRF   27
186E:  BTFSC  0B.7
186F:  BSF    27.7
1870:  BCF    0B.7
1871:  BSF    03.6
1872:  CLRF   67
1873:  MOVLW  0A
1874:  MOVWF  68
1875:  MOVLW  01
1876:  MOVWF  6A
1877:  MOVLW  10
1878:  MOVWF  69
1879:  MOVLW  01
187A:  MOVWF  6B
187B:  MOVWF  6C
187C:  BCF    0A.4
187D:  BCF    0A.3
187E:  BCF    03.6
187F:  CALL   417
1880:  BSF    0A.4
1881:  BSF    0A.3
1882:  BTFSC  27.7
1883:  BSF    0B.7
1884:  CLRF   27
1885:  BTFSC  0B.7
1886:  BSF    27.7
1887:  BCF    0B.7
....................    glcd_line(0, 8, 128, 8, ON); //Pintamos una linea por debajo del barra de notificaciones 
1888:  BSF    03.6
1889:  CLRF   6C
188A:  MOVLW  08
188B:  MOVWF  6D
188C:  MOVLW  80
188D:  MOVWF  6E
188E:  MOVLW  08
188F:  MOVWF  6F
1890:  MOVLW  01
1891:  BSF    03.5
1892:  MOVWF  10
1893:  BCF    0A.4
1894:  BCF    03.5
1895:  BCF    03.6
1896:  CALL   358
1897:  BSF    0A.4
1898:  BTFSC  27.7
1899:  BSF    0B.7
189A:  CLRF   27
189B:  BTFSC  0B.7
189C:  BSF    27.7
189D:  BCF    0B.7
....................    glcd_line(0, 19, 128, 19, ON); //Pintamos una linea por debajo de la temperatura 
189E:  BSF    03.6
189F:  CLRF   6C
18A0:  MOVLW  13
18A1:  MOVWF  6D
18A2:  MOVLW  80
18A3:  MOVWF  6E
18A4:  MOVLW  13
18A5:  MOVWF  6F
18A6:  MOVLW  01
18A7:  BSF    03.5
18A8:  MOVWF  10
18A9:  BCF    0A.4
18AA:  BCF    03.5
18AB:  BCF    03.6
18AC:  CALL   358
18AD:  BSF    0A.4
18AE:  BTFSC  27.7
18AF:  BSF    0B.7
....................     
....................    set_adc_channel(0); //Seteamos el canal que vamos a leer 
18B0:  MOVLW  00
18B1:  MOVWF  78
18B2:  MOVF   1F,W
18B3:  ANDLW  C7
18B4:  IORWF  78,W
18B5:  MOVWF  1F
18B6:  CLRF   27
18B7:  BTFSC  0B.7
18B8:  BSF    27.7
18B9:  BCF    0B.7
....................    delay_ms(250); //Esperamos 250 ms para tener una captura mas real de la primera temperatura 
18BA:  MOVLW  FA
18BB:  BSF    03.6
18BC:  MOVWF  3D
18BD:  BCF    0A.4
18BE:  BCF    0A.3
18BF:  BCF    03.6
18C0:  CALL   26D
18C1:  BSF    0A.4
18C2:  BSF    0A.3
18C3:  BTFSC  27.7
18C4:  BSF    0B.7
....................    iAn=read_adc(); //Levantamos el dato 
18C5:  BSF    1F.2
18C6:  BTFSC  1F.2
18C7:  GOTO   0C6
18C8:  BSF    03.5
18C9:  MOVF   1E,W
18CA:  BCF    03.5
18CB:  MOVWF  43
18CC:  MOVF   1E,W
18CD:  MOVWF  44
18CE:  CLRF   27
18CF:  BTFSC  0B.7
18D0:  BSF    27.7
18D1:  BCF    0B.7
....................    y=(5.0*iAn*100.0)/1024.0; //Lo convertemos a temperatura. Esta es la primera captura 
18D2:  MOVF   44,W
18D3:  BSF    03.6
18D4:  MOVWF  66
18D5:  BCF    03.6
18D6:  MOVF   43,W
18D7:  BSF    03.6
18D8:  MOVWF  65
18D9:  BCF    0A.4
18DA:  BCF    0A.3
18DB:  BCF    03.6
18DC:  CALL   755
18DD:  BSF    0A.4
18DE:  BSF    0A.3
18DF:  BTFSC  27.7
18E0:  BSF    0B.7
18E1:  CLRF   27
18E2:  BTFSC  0B.7
18E3:  BSF    27.7
18E4:  BCF    0B.7
18E5:  BSF    03.5
18E6:  BSF    03.6
18E7:  CLRF   1C
18E8:  CLRF   1B
18E9:  MOVLW  20
18EA:  MOVWF  1A
18EB:  MOVLW  81
18EC:  MOVWF  19
18ED:  MOVF   7A,W
18EE:  MOVWF  20
18EF:  MOVF   79,W
18F0:  MOVWF  1F
18F1:  MOVF   78,W
18F2:  MOVWF  1E
18F3:  MOVF   77,W
18F4:  MOVWF  1D
18F5:  BCF    0A.4
18F6:  BCF    0A.3
18F7:  BCF    03.5
18F8:  BCF    03.6
18F9:  CALL   539
18FA:  BSF    0A.4
18FB:  BSF    0A.3
18FC:  BTFSC  27.7
18FD:  BSF    0B.7
18FE:  MOVF   7A,W
18FF:  BSF    03.6
1900:  MOVWF  20
1901:  MOVF   79,W
1902:  MOVWF  1F
1903:  MOVF   78,W
1904:  MOVWF  1E
1905:  MOVF   77,W
1906:  MOVWF  1D
1907:  BCF    03.6
1908:  CLRF   27
1909:  BTFSC  0B.7
190A:  BSF    27.7
190B:  BCF    0B.7
190C:  BSF    03.6
190D:  MOVF   20,W
190E:  BSF    03.5
190F:  MOVWF  1C
1910:  BCF    03.5
1911:  MOVF   1F,W
1912:  BSF    03.5
1913:  MOVWF  1B
1914:  BCF    03.5
1915:  MOVF   1E,W
1916:  BSF    03.5
1917:  MOVWF  1A
1918:  BCF    03.5
1919:  MOVF   1D,W
191A:  BSF    03.5
191B:  MOVWF  19
191C:  CLRF   20
191D:  CLRF   1F
191E:  MOVLW  48
191F:  MOVWF  1E
1920:  MOVLW  85
1921:  MOVWF  1D
1922:  BCF    0A.4
1923:  BCF    0A.3
1924:  BCF    03.5
1925:  BCF    03.6
1926:  CALL   539
1927:  BSF    0A.4
1928:  BSF    0A.3
1929:  BTFSC  27.7
192A:  BSF    0B.7
192B:  MOVF   7A,W
192C:  BSF    03.6
192D:  MOVWF  20
192E:  MOVF   79,W
192F:  MOVWF  1F
1930:  MOVF   78,W
1931:  MOVWF  1E
1932:  MOVF   77,W
1933:  MOVWF  1D
1934:  BCF    03.6
1935:  CLRF   27
1936:  BTFSC  0B.7
1937:  BSF    27.7
1938:  BCF    0B.7
1939:  BSF    03.6
193A:  MOVF   20,W
193B:  MOVWF  6C
193C:  MOVF   1F,W
193D:  MOVWF  6B
193E:  MOVF   1E,W
193F:  MOVWF  6A
1940:  MOVF   1D,W
1941:  MOVWF  69
1942:  BSF    03.5
1943:  CLRF   13
1944:  CLRF   12
1945:  CLRF   11
1946:  MOVLW  89
1947:  MOVWF  10
1948:  BCF    0A.4
1949:  BCF    03.5
194A:  BCF    03.6
194B:  CALL   000
194C:  BSF    0A.4
194D:  BTFSC  27.7
194E:  BSF    0B.7
194F:  MOVF   7A,W
1950:  MOVWF  3E
1951:  MOVF   79,W
1952:  MOVWF  3D
1953:  MOVF   78,W
1954:  MOVWF  3C
1955:  MOVF   77,W
1956:  MOVWF  3B
1957:  CLRF   27
1958:  BTFSC  0B.7
1959:  BSF    27.7
195A:  BCF    0B.7
....................    delay_ms(250); 
195B:  MOVLW  FA
195C:  BSF    03.6
195D:  MOVWF  3D
195E:  BCF    0A.4
195F:  BCF    0A.3
1960:  BCF    03.6
1961:  CALL   26D
1962:  BSF    0A.4
1963:  BSF    0A.3
1964:  BTFSC  27.7
1965:  BSF    0B.7
....................     
....................    set_SERIALsr(); 
1966:  BCF    0A.3
1967:  GOTO   33B
1968:  BSF    0A.3
....................     
....................    while(TRUE) { 
....................       if(habilitarLectura){ 
1969:  BTFSS  45.0
196A:  GOTO   4C1
....................          set_adc_channel(0); //Seteamos el canal que vamos a leer 
196B:  MOVLW  00
196C:  MOVWF  78
196D:  MOVF   1F,W
196E:  ANDLW  C7
196F:  IORWF  78,W
1970:  MOVWF  1F
....................          delay_us(10); //Esperamos 10 us 
1971:  MOVLW  03
1972:  MOVWF  77
1973:  DECFSZ 77,F
1974:  GOTO   173
....................          iAn=read_adc(); //Levantamos el dato 
1975:  BSF    1F.2
1976:  BTFSC  1F.2
1977:  GOTO   176
1978:  BSF    03.5
1979:  MOVF   1E,W
197A:  BCF    03.5
197B:  MOVWF  43
197C:  MOVF   1E,W
197D:  MOVWF  44
197E:  CLRF   27
197F:  BTFSC  0B.7
1980:  BSF    27.7
1981:  BCF    0B.7
....................          t=(5.0*iAn*100.0)/1024.0; //Lo convertemos a temperatura 
1982:  MOVF   44,W
1983:  BSF    03.6
1984:  MOVWF  66
1985:  BCF    03.6
1986:  MOVF   43,W
1987:  BSF    03.6
1988:  MOVWF  65
1989:  BCF    0A.4
198A:  BCF    0A.3
198B:  BCF    03.6
198C:  CALL   755
198D:  BSF    0A.4
198E:  BSF    0A.3
198F:  BTFSC  27.7
1990:  BSF    0B.7
1991:  CLRF   27
1992:  BTFSC  0B.7
1993:  BSF    27.7
1994:  BCF    0B.7
1995:  BSF    03.5
1996:  BSF    03.6
1997:  CLRF   1C
1998:  CLRF   1B
1999:  MOVLW  20
199A:  MOVWF  1A
199B:  MOVLW  81
199C:  MOVWF  19
199D:  MOVF   7A,W
199E:  MOVWF  20
199F:  MOVF   79,W
19A0:  MOVWF  1F
19A1:  MOVF   78,W
19A2:  MOVWF  1E
19A3:  MOVF   77,W
19A4:  MOVWF  1D
19A5:  BCF    0A.4
19A6:  BCF    0A.3
19A7:  BCF    03.5
19A8:  BCF    03.6
19A9:  CALL   539
19AA:  BSF    0A.4
19AB:  BSF    0A.3
19AC:  BTFSC  27.7
19AD:  BSF    0B.7
19AE:  MOVF   7A,W
19AF:  BSF    03.6
19B0:  MOVWF  20
19B1:  MOVF   79,W
19B2:  MOVWF  1F
19B3:  MOVF   78,W
19B4:  MOVWF  1E
19B5:  MOVF   77,W
19B6:  MOVWF  1D
19B7:  BCF    03.6
19B8:  CLRF   27
19B9:  BTFSC  0B.7
19BA:  BSF    27.7
19BB:  BCF    0B.7
19BC:  BSF    03.6
19BD:  MOVF   20,W
19BE:  BSF    03.5
19BF:  MOVWF  1C
19C0:  BCF    03.5
19C1:  MOVF   1F,W
19C2:  BSF    03.5
19C3:  MOVWF  1B
19C4:  BCF    03.5
19C5:  MOVF   1E,W
19C6:  BSF    03.5
19C7:  MOVWF  1A
19C8:  BCF    03.5
19C9:  MOVF   1D,W
19CA:  BSF    03.5
19CB:  MOVWF  19
19CC:  CLRF   20
19CD:  CLRF   1F
19CE:  MOVLW  48
19CF:  MOVWF  1E
19D0:  MOVLW  85
19D1:  MOVWF  1D
19D2:  BCF    0A.4
19D3:  BCF    0A.3
19D4:  BCF    03.5
19D5:  BCF    03.6
19D6:  CALL   539
19D7:  BSF    0A.4
19D8:  BSF    0A.3
19D9:  BTFSC  27.7
19DA:  BSF    0B.7
19DB:  MOVF   7A,W
19DC:  BSF    03.6
19DD:  MOVWF  20
19DE:  MOVF   79,W
19DF:  MOVWF  1F
19E0:  MOVF   78,W
19E1:  MOVWF  1E
19E2:  MOVF   77,W
19E3:  MOVWF  1D
19E4:  BCF    03.6
19E5:  CLRF   27
19E6:  BTFSC  0B.7
19E7:  BSF    27.7
19E8:  BCF    0B.7
19E9:  BSF    03.6
19EA:  MOVF   20,W
19EB:  MOVWF  6C
19EC:  MOVF   1F,W
19ED:  MOVWF  6B
19EE:  MOVF   1E,W
19EF:  MOVWF  6A
19F0:  MOVF   1D,W
19F1:  MOVWF  69
19F2:  BSF    03.5
19F3:  CLRF   13
19F4:  CLRF   12
19F5:  CLRF   11
19F6:  MOVLW  89
19F7:  MOVWF  10
19F8:  BCF    0A.4
19F9:  BCF    03.5
19FA:  BCF    03.6
19FB:  CALL   000
19FC:  BSF    0A.4
19FD:  BTFSC  27.7
19FE:  BSF    0B.7
19FF:  MOVF   7A,W
1A00:  MOVWF  42
1A01:  MOVF   79,W
1A02:  MOVWF  41
1A03:  MOVF   78,W
1A04:  MOVWF  40
1A05:  MOVF   77,W
1A06:  MOVWF  3F
....................           
....................          if(btST) 
1A07:  BTFSS  45.1
1A08:  GOTO   216
....................             sendINT('t', iAn, SEP); 
1A09:  MOVLW  74
1A0A:  BSF    03.6
1A0B:  MOVWF  1D
1A0C:  BCF    03.6
1A0D:  MOVF   43,W
1A0E:  BSF    03.6
1A0F:  MOVWF  1E
1A10:  MOVLW  0A
1A11:  MOVWF  1F
1A12:  BCF    0A.4
1A13:  BCF    03.6
1A14:  GOTO   6EF
1A15:  BSF    0A.4
1A16:  CLRF   27
1A17:  BTFSC  0B.7
1A18:  BSF    27.7
1A19:  BCF    0B.7
....................           
....................          if(t!=y){ //Si t es != al dato anterior refrescamos la temperatura y la enviamos al bluetooth 
1A1A:  MOVF   42,W
1A1B:  BSF    03.6
1A1C:  MOVWF  68
1A1D:  BCF    03.6
1A1E:  MOVF   41,W
1A1F:  BSF    03.6
1A20:  MOVWF  67
1A21:  BCF    03.6
1A22:  MOVF   40,W
1A23:  BSF    03.6
1A24:  MOVWF  66
1A25:  BCF    03.6
1A26:  MOVF   3F,W
1A27:  BSF    03.6
1A28:  MOVWF  65
1A29:  BCF    03.6
1A2A:  MOVF   3E,W
1A2B:  BSF    03.6
1A2C:  MOVWF  6C
1A2D:  BCF    03.6
1A2E:  MOVF   3D,W
1A2F:  BSF    03.6
1A30:  MOVWF  6B
1A31:  BCF    03.6
1A32:  MOVF   3C,W
1A33:  BSF    03.6
1A34:  MOVWF  6A
1A35:  BCF    03.6
1A36:  MOVF   3B,W
1A37:  BSF    03.6
1A38:  MOVWF  69
1A39:  BCF    0A.4
1A3A:  BCF    0A.3
1A3B:  BCF    03.6
1A3C:  CALL   774
1A3D:  BSF    0A.4
1A3E:  BSF    0A.3
1A3F:  BTFSC  27.7
1A40:  BSF    0B.7
1A41:  BTFSC  03.2
1A42:  GOTO   2D7
....................             //str[0] = '\0'; 
....................             sprintf(str, "%3.2fC", y); //Convertimos la temperatura float en un char* 
1A43:  CLRF   39
1A44:  MOVLW  2F
1A45:  MOVWF  38
1A46:  MOVLW  02
1A47:  MOVWF  04
1A48:  CLRF   27
1A49:  BTFSC  0B.7
1A4A:  BSF    27.7
1A4B:  BCF    0B.7
1A4C:  MOVF   3E,W
1A4D:  BSF    03.6
1A4E:  MOVWF  68
1A4F:  BCF    03.6
1A50:  MOVF   3D,W
1A51:  BSF    03.6
1A52:  MOVWF  67
1A53:  BCF    03.6
1A54:  MOVF   3C,W
1A55:  BSF    03.6
1A56:  MOVWF  66
1A57:  BCF    03.6
1A58:  MOVF   3B,W
1A59:  BSF    03.6
1A5A:  MOVWF  65
1A5B:  MOVLW  02
1A5C:  MOVWF  69
1A5D:  BCF    0A.4
1A5E:  BCF    0A.3
1A5F:  BCF    03.6
1A60:  CALL   639
1A61:  BSF    0A.4
1A62:  BSF    0A.3
1A63:  BTFSC  27.7
1A64:  BSF    0B.7
1A65:  CLRF   27
1A66:  BTFSC  0B.7
1A67:  BSF    27.7
1A68:  BCF    0B.7
1A69:  MOVLW  43
1A6A:  BSF    03.5
1A6B:  BSF    03.6
1A6C:  MOVWF  19
1A6D:  BCF    0A.4
1A6E:  BCF    0A.3
1A6F:  BCF    03.5
1A70:  BCF    03.6
1A71:  CALL   628
1A72:  BSF    0A.4
1A73:  BSF    0A.3
1A74:  BTFSC  27.7
1A75:  BSF    0B.7
1A76:  CLRF   27
1A77:  BTFSC  0B.7
1A78:  BSF    27.7
1A79:  BCF    0B.7
....................             glcd_text57(12*6, 10, str, 1, OFF); //borramos del lcd la temperatura anterior 
1A7A:  MOVLW  48
1A7B:  BSF    03.6
1A7C:  MOVWF  67
1A7D:  MOVLW  0A
1A7E:  MOVWF  68
1A7F:  CLRF   6A
1A80:  MOVLW  2F
1A81:  MOVWF  69
1A82:  MOVLW  01
1A83:  MOVWF  6B
1A84:  CLRF   6C
1A85:  BCF    0A.4
1A86:  BCF    0A.3
1A87:  BCF    03.6
1A88:  CALL   417
1A89:  BSF    0A.4
1A8A:  BSF    0A.3
1A8B:  BTFSC  27.7
1A8C:  BSF    0B.7
....................             sprintf(str, "%3.2fC", t); //Convertimos la temperatura float en un char* 
1A8D:  CLRF   39
1A8E:  MOVLW  2F
1A8F:  MOVWF  38
1A90:  MOVLW  02
1A91:  MOVWF  04
1A92:  CLRF   27
1A93:  BTFSC  0B.7
1A94:  BSF    27.7
1A95:  BCF    0B.7
1A96:  MOVF   42,W
1A97:  BSF    03.6
1A98:  MOVWF  68
1A99:  BCF    03.6
1A9A:  MOVF   41,W
1A9B:  BSF    03.6
1A9C:  MOVWF  67
1A9D:  BCF    03.6
1A9E:  MOVF   40,W
1A9F:  BSF    03.6
1AA0:  MOVWF  66
1AA1:  BCF    03.6
1AA2:  MOVF   3F,W
1AA3:  BSF    03.6
1AA4:  MOVWF  65
1AA5:  MOVLW  02
1AA6:  MOVWF  69
1AA7:  BCF    0A.4
1AA8:  BCF    0A.3
1AA9:  BCF    03.6
1AAA:  CALL   639
1AAB:  BSF    0A.4
1AAC:  BSF    0A.3
1AAD:  BTFSC  27.7
1AAE:  BSF    0B.7
1AAF:  CLRF   27
1AB0:  BTFSC  0B.7
1AB1:  BSF    27.7
1AB2:  BCF    0B.7
1AB3:  MOVLW  43
1AB4:  BSF    03.5
1AB5:  BSF    03.6
1AB6:  MOVWF  19
1AB7:  BCF    0A.4
1AB8:  BCF    0A.3
1AB9:  BCF    03.5
1ABA:  BCF    03.6
1ABB:  CALL   628
1ABC:  BSF    0A.4
1ABD:  BSF    0A.3
1ABE:  BTFSC  27.7
1ABF:  BSF    0B.7
1AC0:  CLRF   27
1AC1:  BTFSC  0B.7
1AC2:  BSF    27.7
1AC3:  BCF    0B.7
....................             glcd_text57(12*6, 10, str, 1, ON); //Escribimos la temperatura. 
1AC4:  MOVLW  48
1AC5:  BSF    03.6
1AC6:  MOVWF  67
1AC7:  MOVLW  0A
1AC8:  MOVWF  68
1AC9:  CLRF   6A
1ACA:  MOVLW  2F
1ACB:  MOVWF  69
1ACC:  MOVLW  01
1ACD:  MOVWF  6B
1ACE:  MOVWF  6C
1ACF:  BCF    0A.4
1AD0:  BCF    0A.3
1AD1:  BCF    03.6
1AD2:  CALL   417
1AD3:  BSF    0A.4
1AD4:  BSF    0A.3
1AD5:  BTFSC  27.7
1AD6:  BSF    0B.7
1AD7:  CLRF   27
1AD8:  BTFSC  0B.7
1AD9:  BSF    27.7
1ADA:  BCF    0B.7
....................          } 
....................          if(t<=40 && t>=35) 
1ADB:  MOVF   42,W
1ADC:  BSF    03.6
1ADD:  MOVWF  68
1ADE:  BCF    03.6
1ADF:  MOVF   41,W
1AE0:  BSF    03.6
1AE1:  MOVWF  67
1AE2:  BCF    03.6
1AE3:  MOVF   40,W
1AE4:  BSF    03.6
1AE5:  MOVWF  66
1AE6:  BCF    03.6
1AE7:  MOVF   3F,W
1AE8:  BSF    03.6
1AE9:  MOVWF  65
1AEA:  CLRF   6C
1AEB:  CLRF   6B
1AEC:  MOVLW  20
1AED:  MOVWF  6A
1AEE:  MOVLW  84
1AEF:  MOVWF  69
1AF0:  BCF    0A.4
1AF1:  BCF    0A.3
1AF2:  BCF    03.6
1AF3:  CALL   774
1AF4:  BSF    0A.4
1AF5:  BSF    0A.3
1AF6:  BTFSC  27.7
1AF7:  BSF    0B.7
1AF8:  BTFSC  03.0
1AF9:  GOTO   2FC
1AFA:  BTFSS  03.2
1AFB:  GOTO   324
1AFC:  CLRF   27
1AFD:  BTFSC  0B.7
1AFE:  BSF    27.7
1AFF:  BCF    0B.7
1B00:  BSF    03.6
1B01:  CLRF   68
1B02:  CLRF   67
1B03:  MOVLW  0C
1B04:  MOVWF  66
1B05:  MOVLW  84
1B06:  MOVWF  65
1B07:  BCF    03.6
1B08:  MOVF   42,W
1B09:  BSF    03.6
1B0A:  MOVWF  6C
1B0B:  BCF    03.6
1B0C:  MOVF   41,W
1B0D:  BSF    03.6
1B0E:  MOVWF  6B
1B0F:  BCF    03.6
1B10:  MOVF   40,W
1B11:  BSF    03.6
1B12:  MOVWF  6A
1B13:  BCF    03.6
1B14:  MOVF   3F,W
1B15:  BSF    03.6
1B16:  MOVWF  69
1B17:  BCF    0A.4
1B18:  BCF    0A.3
1B19:  BCF    03.6
1B1A:  CALL   774
1B1B:  BSF    0A.4
1B1C:  BSF    0A.3
1B1D:  BTFSC  27.7
1B1E:  BSF    0B.7
1B1F:  BTFSC  03.0
1B20:  GOTO   323
1B21:  BTFSS  03.2
1B22:  GOTO   324
....................             disable_interrupts(INT_TIMER0); 
1B23:  BCF    0B.5
1B24:  CLRF   27
1B25:  BTFSC  0B.7
1B26:  BSF    27.7
1B27:  BCF    0B.7
....................          if(t>40 || t<35) 
1B28:  BSF    03.6
1B29:  CLRF   68
1B2A:  CLRF   67
1B2B:  MOVLW  20
1B2C:  MOVWF  66
1B2D:  MOVLW  84
1B2E:  MOVWF  65
1B2F:  BCF    03.6
1B30:  MOVF   42,W
1B31:  BSF    03.6
1B32:  MOVWF  6C
1B33:  BCF    03.6
1B34:  MOVF   41,W
1B35:  BSF    03.6
1B36:  MOVWF  6B
1B37:  BCF    03.6
1B38:  MOVF   40,W
1B39:  BSF    03.6
1B3A:  MOVWF  6A
1B3B:  BCF    03.6
1B3C:  MOVF   3F,W
1B3D:  BSF    03.6
1B3E:  MOVWF  69
1B3F:  BCF    0A.4
1B40:  BCF    0A.3
1B41:  BCF    03.6
1B42:  CALL   774
1B43:  BSF    0A.4
1B44:  BSF    0A.3
1B45:  BTFSC  27.7
1B46:  BSF    0B.7
1B47:  BTFSC  03.0
1B48:  GOTO   36C
1B49:  CLRF   27
1B4A:  BTFSC  0B.7
1B4B:  BSF    27.7
1B4C:  BCF    0B.7
1B4D:  MOVF   42,W
1B4E:  BSF    03.6
1B4F:  MOVWF  68
1B50:  BCF    03.6
1B51:  MOVF   41,W
1B52:  BSF    03.6
1B53:  MOVWF  67
1B54:  BCF    03.6
1B55:  MOVF   40,W
1B56:  BSF    03.6
1B57:  MOVWF  66
1B58:  BCF    03.6
1B59:  MOVF   3F,W
1B5A:  BSF    03.6
1B5B:  MOVWF  65
1B5C:  CLRF   6C
1B5D:  CLRF   6B
1B5E:  MOVLW  0C
1B5F:  MOVWF  6A
1B60:  MOVLW  84
1B61:  MOVWF  69
1B62:  BCF    0A.4
1B63:  BCF    0A.3
1B64:  BCF    03.6
1B65:  CALL   774
1B66:  BSF    0A.4
1B67:  BSF    0A.3
1B68:  BTFSC  27.7
1B69:  BSF    0B.7
1B6A:  BTFSS  03.0
1B6B:  GOTO   36D
....................             enable_interrupts(INT_TIMER0); 
1B6C:  BSF    0B.5
1B6D:  CLRF   27
1B6E:  BTFSC  0B.7
1B6F:  BSF    27.7
1B70:  BCF    0B.7
....................          if(t<=50 && t>=28){ //Si t es menor o igual a 50 la agregamos al grafico 
1B71:  MOVF   42,W
1B72:  BSF    03.6
1B73:  MOVWF  68
1B74:  BCF    03.6
1B75:  MOVF   41,W
1B76:  BSF    03.6
1B77:  MOVWF  67
1B78:  BCF    03.6
1B79:  MOVF   40,W
1B7A:  BSF    03.6
1B7B:  MOVWF  66
1B7C:  BCF    03.6
1B7D:  MOVF   3F,W
1B7E:  BSF    03.6
1B7F:  MOVWF  65
1B80:  CLRF   6C
1B81:  CLRF   6B
1B82:  MOVLW  48
1B83:  MOVWF  6A
1B84:  MOVLW  84
1B85:  MOVWF  69
1B86:  BCF    0A.4
1B87:  BCF    0A.3
1B88:  BCF    03.6
1B89:  CALL   774
1B8A:  BSF    0A.4
1B8B:  BSF    0A.3
1B8C:  BTFSC  27.7
1B8D:  BSF    0B.7
1B8E:  BTFSC  03.0
1B8F:  GOTO   392
1B90:  BTFSS  03.2
1B91:  GOTO   416
1B92:  CLRF   27
1B93:  BTFSC  0B.7
1B94:  BSF    27.7
1B95:  BCF    0B.7
1B96:  BSF    03.6
1B97:  CLRF   68
1B98:  CLRF   67
1B99:  MOVLW  60
1B9A:  MOVWF  66
1B9B:  MOVLW  83
1B9C:  MOVWF  65
1B9D:  BCF    03.6
1B9E:  MOVF   42,W
1B9F:  BSF    03.6
1BA0:  MOVWF  6C
1BA1:  BCF    03.6
1BA2:  MOVF   41,W
1BA3:  BSF    03.6
1BA4:  MOVWF  6B
1BA5:  BCF    03.6
1BA6:  MOVF   40,W
1BA7:  BSF    03.6
1BA8:  MOVWF  6A
1BA9:  BCF    03.6
1BAA:  MOVF   3F,W
1BAB:  BSF    03.6
1BAC:  MOVWF  69
1BAD:  BCF    0A.4
1BAE:  BCF    0A.3
1BAF:  BCF    03.6
1BB0:  CALL   774
1BB1:  BSF    0A.4
1BB2:  BSF    0A.3
1BB3:  BTFSC  27.7
1BB4:  BSF    0B.7
1BB5:  BTFSC  03.0
1BB6:  GOTO   3B9
1BB7:  BTFSS  03.2
1BB8:  GOTO   416
1BB9:  CLRF   27
1BBA:  BTFSC  0B.7
1BBB:  BSF    27.7
1BBC:  BCF    0B.7
....................             nuevaLinea(t); //Dibujamos la nueva linea en el grafico. 
1BBD:  MOVF   42,W
1BBE:  BSF    03.6
1BBF:  MOVWF  68
1BC0:  BCF    03.6
1BC1:  MOVF   41,W
1BC2:  BSF    03.6
1BC3:  MOVWF  67
1BC4:  BCF    03.6
1BC5:  MOVF   40,W
1BC6:  BSF    03.6
1BC7:  MOVWF  66
1BC8:  BCF    03.6
1BC9:  MOVF   3F,W
1BCA:  BSF    03.6
1BCB:  MOVWF  65
1BCC:  BCF    0A.4
1BCD:  BCF    03.6
1BCE:  CALL   436
1BCF:  BSF    0A.4
1BD0:  BTFSC  27.7
1BD1:  BSF    0B.7
....................             glcd_text57(3, 0, (char*)"T>50", 1, OFF); //ocultamos la notificacion de t>50 
1BD2:  MOVLW  54
1BD3:  BSF    03.6
1BD4:  MOVWF  10
1BD5:  MOVLW  3E
1BD6:  MOVWF  11
1BD7:  MOVLW  35
1BD8:  MOVWF  12
1BD9:  MOVLW  30
1BDA:  MOVWF  13
1BDB:  CLRF   14
1BDC:  BCF    03.6
1BDD:  CLRF   27
1BDE:  BTFSC  0B.7
1BDF:  BSF    27.7
1BE0:  BCF    0B.7
1BE1:  MOVLW  03
1BE2:  BSF    03.6
1BE3:  MOVWF  67
1BE4:  CLRF   68
1BE5:  MOVLW  01
1BE6:  MOVWF  6A
1BE7:  MOVLW  10
1BE8:  MOVWF  69
1BE9:  MOVLW  01
1BEA:  MOVWF  6B
1BEB:  CLRF   6C
1BEC:  BCF    0A.4
1BED:  BCF    0A.3
1BEE:  BCF    03.6
1BEF:  CALL   417
1BF0:  BSF    0A.4
1BF1:  BSF    0A.3
1BF2:  BTFSC  27.7
1BF3:  BSF    0B.7
....................             glcd_text57(3, 0, (char*)"T<28", 1, OFF); //ocultamos la notificacion de t>50 
1BF4:  MOVLW  54
1BF5:  BSF    03.6
1BF6:  MOVWF  10
1BF7:  MOVLW  3C
1BF8:  MOVWF  11
1BF9:  MOVLW  32
1BFA:  MOVWF  12
1BFB:  MOVLW  38
1BFC:  MOVWF  13
1BFD:  CLRF   14
1BFE:  BCF    03.6
1BFF:  CLRF   27
1C00:  BTFSC  0B.7
1C01:  BSF    27.7
1C02:  BCF    0B.7
1C03:  MOVLW  03
1C04:  BSF    03.6
1C05:  MOVWF  67
1C06:  CLRF   68
1C07:  MOVLW  01
1C08:  MOVWF  6A
1C09:  MOVLW  10
1C0A:  MOVWF  69
1C0B:  MOVLW  01
1C0C:  MOVWF  6B
1C0D:  CLRF   6C
1C0E:  BCF    0A.4
1C0F:  BCF    0A.3
1C10:  BCF    03.6
1C11:  CALL   417
1C12:  BSF    0A.4
1C13:  BSF    0A.3
1C14:  BTFSC  27.7
1C15:  BSF    0B.7
1C16:  CLRF   27
1C17:  BTFSC  0B.7
1C18:  BSF    27.7
1C19:  BCF    0B.7
....................          } 
....................          if(t>50){ 
1C1A:  BSF    03.6
1C1B:  CLRF   68
1C1C:  CLRF   67
1C1D:  MOVLW  48
1C1E:  MOVWF  66
1C1F:  MOVLW  84
1C20:  MOVWF  65
1C21:  BCF    03.6
1C22:  MOVF   42,W
1C23:  BSF    03.6
1C24:  MOVWF  6C
1C25:  BCF    03.6
1C26:  MOVF   41,W
1C27:  BSF    03.6
1C28:  MOVWF  6B
1C29:  BCF    03.6
1C2A:  MOVF   40,W
1C2B:  BSF    03.6
1C2C:  MOVWF  6A
1C2D:  BCF    03.6
1C2E:  MOVF   3F,W
1C2F:  BSF    03.6
1C30:  MOVWF  69
1C31:  BCF    0A.4
1C32:  BCF    0A.3
1C33:  BCF    03.6
1C34:  CALL   774
1C35:  BSF    0A.4
1C36:  BSF    0A.3
1C37:  BTFSC  27.7
1C38:  BSF    0B.7
1C39:  BTFSS  03.0
1C3A:  GOTO   465
....................             glcd_text57(3, 0, (char*)"T>50", 1, ON); //Esto significa que no graficamos temperaturas superiores a 50 
1C3B:  MOVLW  54
1C3C:  BSF    03.6
1C3D:  MOVWF  10
1C3E:  MOVLW  3E
1C3F:  MOVWF  11
1C40:  MOVLW  35
1C41:  MOVWF  12
1C42:  MOVLW  30
1C43:  MOVWF  13
1C44:  CLRF   14
1C45:  BCF    03.6
1C46:  CLRF   27
1C47:  BTFSC  0B.7
1C48:  BSF    27.7
1C49:  BCF    0B.7
1C4A:  MOVLW  03
1C4B:  BSF    03.6
1C4C:  MOVWF  67
1C4D:  CLRF   68
1C4E:  MOVLW  01
1C4F:  MOVWF  6A
1C50:  MOVLW  10
1C51:  MOVWF  69
1C52:  MOVLW  01
1C53:  MOVWF  6B
1C54:  MOVWF  6C
1C55:  BCF    0A.4
1C56:  BCF    0A.3
1C57:  BCF    03.6
1C58:  CALL   417
1C59:  BSF    0A.4
1C5A:  BSF    0A.3
1C5B:  BTFSC  27.7
1C5C:  BSF    0B.7
....................             y=t; //igualamos el dato anterior al valor de temperatura para no refrescar otra vez el valor de la temperatura 
1C5D:  MOVF   42,W
1C5E:  MOVWF  3E
1C5F:  MOVF   41,W
1C60:  MOVWF  3D
1C61:  MOVF   40,W
1C62:  MOVWF  3C
1C63:  MOVF   3F,W
1C64:  MOVWF  3B
1C65:  CLRF   27
1C66:  BTFSC  0B.7
1C67:  BSF    27.7
1C68:  BCF    0B.7
....................          } 
....................          if(t<28){ 
1C69:  MOVF   42,W
1C6A:  BSF    03.6
1C6B:  MOVWF  68
1C6C:  BCF    03.6
1C6D:  MOVF   41,W
1C6E:  BSF    03.6
1C6F:  MOVWF  67
1C70:  BCF    03.6
1C71:  MOVF   40,W
1C72:  BSF    03.6
1C73:  MOVWF  66
1C74:  BCF    03.6
1C75:  MOVF   3F,W
1C76:  BSF    03.6
1C77:  MOVWF  65
1C78:  CLRF   6C
1C79:  CLRF   6B
1C7A:  MOVLW  60
1C7B:  MOVWF  6A
1C7C:  MOVLW  83
1C7D:  MOVWF  69
1C7E:  BCF    0A.4
1C7F:  BCF    0A.3
1C80:  BCF    03.6
1C81:  CALL   774
1C82:  BSF    0A.4
1C83:  BSF    0A.3
1C84:  BTFSC  27.7
1C85:  BSF    0B.7
1C86:  BTFSS  03.0
1C87:  GOTO   4B2
....................             glcd_text57(3, 0, (char*)"T<28", 1, ON); //Esto significa que no graficamos temperaturas superiores a 50 
1C88:  MOVLW  54
1C89:  BSF    03.6
1C8A:  MOVWF  10
1C8B:  MOVLW  3C
1C8C:  MOVWF  11
1C8D:  MOVLW  32
1C8E:  MOVWF  12
1C8F:  MOVLW  38
1C90:  MOVWF  13
1C91:  CLRF   14
1C92:  BCF    03.6
1C93:  CLRF   27
1C94:  BTFSC  0B.7
1C95:  BSF    27.7
1C96:  BCF    0B.7
1C97:  MOVLW  03
1C98:  BSF    03.6
1C99:  MOVWF  67
1C9A:  CLRF   68
1C9B:  MOVLW  01
1C9C:  MOVWF  6A
1C9D:  MOVLW  10
1C9E:  MOVWF  69
1C9F:  MOVLW  01
1CA0:  MOVWF  6B
1CA1:  MOVWF  6C
1CA2:  BCF    0A.4
1CA3:  BCF    0A.3
1CA4:  BCF    03.6
1CA5:  CALL   417
1CA6:  BSF    0A.4
1CA7:  BSF    0A.3
1CA8:  BTFSC  27.7
1CA9:  BSF    0B.7
....................             y=t; //igualamos el dato anterior al valor de temperatura para no refrescar otra vez el valor de la temperatura 
1CAA:  MOVF   42,W
1CAB:  MOVWF  3E
1CAC:  MOVF   41,W
1CAD:  MOVWF  3D
1CAE:  MOVF   40,W
1CAF:  MOVWF  3C
1CB0:  MOVF   3F,W
1CB1:  MOVWF  3B
1CB2:  CLRF   27
1CB3:  BTFSC  0B.7
1CB4:  BSF    27.7
1CB5:  BCF    0B.7
....................          } 
....................          delay_ms(250); 
1CB6:  MOVLW  FA
1CB7:  BSF    03.6
1CB8:  MOVWF  3D
1CB9:  BCF    0A.4
1CBA:  BCF    0A.3
1CBB:  BCF    03.6
1CBC:  CALL   26D
1CBD:  BSF    0A.4
1CBE:  BSF    0A.3
1CBF:  BTFSC  27.7
1CC0:  BSF    0B.7
....................       } 
1CC1:  GOTO   169
....................    } 
.................... } 
....................  
1CC2:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
